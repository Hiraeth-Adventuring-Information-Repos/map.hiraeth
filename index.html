<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive World Map Viewer</title>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>

    <!-- Google Font: EB Garamond -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap" rel="stylesheet">

    <style>
        /* --- Theme Variables --- */
        :root {
            /* Light Mode Backgrounds */
            --bg-primary: #fdfaf6; /* Lighter base */
            --bg-secondary: #f4f0eb; /* Slightly darker secondary */

            /* Light Mode Text */
            --text-primary: #6b2c25; /* User's Primary Color */
            --text-secondary: #bb9b73; /* User's Default Link Color */
            --popup-text: var(--text-primary); /* Match main text */

            /* Light Mode UI Elements */
            --border-color: #dcd3c8; /* Desaturated brown */
            --highlight-bg: rgba(212, 163, 106, 0.3); /* Based on Chapter Color w/ alpha */
            --active-bg: rgba(189, 137, 77, 0.5); /* Based on Page Color w/ alpha */
            --shadow-color: rgba(107, 44, 37, 0.15); /* Shadow based on primary */
            --slider-bg: #d4a36a; /* Chapter Color */
            --slider-color: white;
            --font-family-main: 'EB Garamond', serif;

            /* Light Mode Frosted Glass */
            --glass-bg-light: rgba(253, 250, 246, 0.75); /* Based on bg-primary w/ alpha */
            --glass-border-light: rgba(160, 82, 45, 0.3); /* Based on Shelf Color w/ alpha */
        }

        body.dark-theme {
            /* Dark Mode Backgrounds */
            --bg-primary: #222034; /* Darker version of user's primary */
            --bg-secondary: #1b1830; /* Even darker */

            /* Dark Mode Text */
            --text-primary: #e8e6f2; /* Light text for contrast */
            --text-secondary: #b9b8e0; /* User's Default Link Color */
            --popup-text: var(--text-primary);

            /* Dark Mode UI Elements */
            --border-color: #524f6c; /* User's Primary Color */
            --highlight-bg: rgba(237, 174, 73, 0.3); /* Based on Chapter Color w/ alpha */
            --active-bg: rgba(66, 159, 227, 0.4); /* Based on Page Color w/ alpha */
            --shadow-color: rgba(0, 0, 0, 0.3); /* Darker shadow */
            --slider-bg: #555;
            --slider-color: #429fe3; /* User's Page Color */
            /* font-family is inherited */

            /* Dark Mode Frosted Glass */
            --glass-bg-dark: rgba(34, 33, 50, 0.7); /* Based on user's primary w/ alpha */
            --glass-border-dark: rgba(245, 67, 91, 0.3); /* Based on Shelf Color w/ alpha */
        }

        /* --- Keyframes for WIP Popup Gradient Pulse --- */
        @keyframes pulseGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* --- Keyframes for Twinkling Stars --- */
        @keyframes twinkle {
            0% { opacity: 0; }
            50% { opacity: 0.6; } /* Adjust max brightness */
            100% { opacity: 0; }
        }

        /* --- Keyframes for Moving Clouds --- */
        @keyframes moveClouds {
            from { background-position-x: 0; }
            to { background-position-x: 1000px; } /* Adjust value based on image width & desired speed */
        }

        #map-blurb a,
        #map-blurb a:link,
        #map-blurb a:visited {
            color: inherit; /* Inherit color from blurb text */
            text-decoration: underline; /* Standard link underline */
            transition: color 0.2s ease;
        }

        #map-blurb a:hover,
        #map-blurb a:active {
            color: var(--text-secondary); /* Use secondary color on hover */
            text-decoration: none; /* Optional: remove underline on hover */
        }

        /* Ensure dark theme hover looks okay (it should inherit fine, but explicit rule is safe) */
        body.dark-theme #map-blurb a:hover,
        body.dark-theme #map-blurb a:active {
             color: var(--text-secondary);
        }


        /* Apply Variables & Base Styles */
        html, body {
            height: 100%; margin: 0; padding: 0; font-family: var(--font-family-main);
            background-color: var(--bg-primary); color: var(--text-primary);
            overflow: hidden; transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container { display: flex; height: 100%; width: 100%; }

        /* Sidebar styling */
        #sidebar {
            background-color: var(--glass-bg-light); backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); border-right: 1px solid var(--glass-border-light);
            width: 250px; padding: 15px; box-shadow: 2px 0 15px var(--shadow-color);
            overflow-y: auto; flex-shrink: 0;
            transition: width 0.3s ease, padding 0.3s ease, background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            box-sizing: border-box; position: relative; display: flex; flex-direction: column;
        }
        body.dark-theme #sidebar { background-color: var(--glass-bg-dark); border-right-color: var(--glass-border-dark); }
        #sidebar h2 {
            margin-top: 0; margin-bottom: 15px; font-size: 1.5rem; font-weight: 600;
            border-bottom: 1px solid var(--glass-border-light); padding-bottom: 10px;
            white-space: nowrap; color: var(--text-primary); flex-shrink: 0;
        }
        body.dark-theme #sidebar h2 { border-bottom-color: var(--glass-border-dark); }

        /* Region Toggle Button */
        #toggle-regions-btn {
            top: 189px; /* Position below measure tool */
        }
        #toggle-regions-btn svg {
            margin-top: 7px; /* Center the SVG icon */
            opacity: 0.6; /* Default: slightly dimmed */
        }
        #toggle-regions-btn.active svg {
            opacity: 1; /* Full opacity when active */
        }
        #toggle-regions-btn.active {
            background-color: var(--active-bg); /* Use active color */
        }

        /* Region Filter Panel */
        #region-filter-container {
            position: absolute;
            top: 185px; /* Align near the region button */
            left: 50px; /* Position to the right of the button */
            z-index: 999;
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            color: var(--text-primary);
            border-radius: 6px;
            padding: 10px 15px;
            width: 180px;
            max-height: calc(100vh - 200px);
            overflow-y: auto;
            box-shadow: 0 1px 5px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease, opacity 0.3s ease, transform 0.3s ease;
            opacity: 0;
            transform: scale(0.95);
            transform-origin: top left;
            pointer-events: none; /* Hidden by default */
        }
        #region-filter-container.visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        body.dark-theme #region-filter-container {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
        }

        /* Sidebar List Styling */
        #map-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #map-list li { border-radius: 4px; margin-bottom: 3px; overflow: hidden; }
        .map-item {
            padding: 10px 10px 10px 15px; cursor: pointer; transition: background-color 0.2s ease;
            white-space: nowrap; text-overflow: ellipsis; font-size: 1.1rem;
            background-color: transparent; display: block;
        }
        .map-item:hover { background-color: var(--highlight-bg); }
        .map-item.active { background-color: var(--active-bg); font-weight: 600; }
        .folder-header {
            padding: 10px 5px; cursor: pointer; font-weight: bold; display: flex;
            align-items: center; transition: background-color 0.2s ease; background-color: transparent;
            user-select: none; /* Prevent text selection on double click */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .folder-header:hover { background-color: var(--highlight-bg); }
        /* Style active folder header */
        .folder-header.active {
             background-color: var(--active-bg);
             font-weight: 600; /* Match map item active style */
        }
        .folder-toggle-icon { display: inline-block; width: 1.2em; text-align: center; margin-right: 5px; transition: transform 0.2s ease-in-out; }
        .folder.closed > .folder-header .folder-toggle-icon::before { content: '‚ñ∏'; }
        .folder:not(.closed) > .folder-header .folder-toggle-icon::before { content: '‚ñæ'; }
        .nested-list { list-style: none; padding: 0; margin: 0 0 0 15px; max-height: 1000px; overflow: hidden; transition: max-height 0.3s ease-out; }
        .folder.closed > .nested-list { max-height: 0; }

        /* --- Coming Soon Sidebar Item Styling --- */
        .map-item.coming-soon, .folder-header.coming-soon {
            color: var(--text-secondary); /* Use secondary text color */
            font-style: italic;
            cursor: not-allowed; /* Indicate non-interactive */
            opacity: 0.7;
        }
        /* Optional: Prevent hover effect or use a different one */
        .map-item.coming-soon:hover, .folder-header.coming-soon:hover {
            background-color: transparent; /* No highlight on hover */
        }
        /* Ensure dark theme also looks disabled */
        body.dark-theme .map-item.coming-soon,
        body.dark-theme .folder-header.coming-soon {
             color: var(--text-secondary); /* Already uses variable */
        }
        body.dark-theme .map-item.coming-soon:hover,
        body.dark-theme .folder-header.coming-soon:hover {
             background-color: transparent;
        }

        /* Map container */
        #map-container { flex-grow: 1; height: 100%; position: relative; overflow: hidden; }
        #map {
            height: 100%; width: 100%;
            background-color: var(--bg-secondary);
            transition: background-color 0.3s ease;
            position: relative; /* Needed for pseudo-elements */
            overflow: hidden; /* Needed for pseudo-elements */
        }
        /* --- NEW: Cursor style for measurement tool --- */
        #map.measuring-cursor {
            cursor: crosshair;
        }
        body.dark-theme #map {
            background-image: url('images/night-sky.png'); /* Base static stars */
            background-repeat: repeat;
            background-color: #050510;
        }

        /* --- Moving Clouds Effect (Light Mode Only) --- */
        body:not(.dark-theme) #map::before,
        body:not(.dark-theme) #map::after {
            background-image: url('images/clouds.png');
            background-repeat: repeat-x;
            background-size: auto 300px;
            background-color: #87CEEB;
            width: 100%;
            animation-name: moveClouds;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
            transition: opacity 0.5s ease-in-out;
            z-index: 0;
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            pointer-events: none;
        }
        body:not(.dark-theme) #map::before {
            background-position: 0 5%; opacity: 0.45; animation-duration: 75s;
        }
        body:not(.dark-theme) #map::after {
            background-position: 0 20%; opacity: 0.3; animation-duration: 110s; animation-delay: -10s;
        }

        /* --- Ensure Dark Theme Hides Clouds & Defines Stars --- */
        body.dark-theme #map::before,
        body.dark-theme #map::after {
            opacity: 0; /* Hide clouds by default */
        }
        body.dark-theme #map::before {
            background-image: radial-gradient(circle, white 1px, transparent 1.5px);
            background-size: 75px 75px; background-position: 0 0;
            animation: twinkle 6s linear infinite; animation-delay: 0s;
            opacity: 1; /* Base opacity for stars */
            z-index: 0; content: ''; position: absolute; top: 0; left: 0; height: 100%; width: 100%; pointer-events: none;
        }
        body.dark-theme #map::after {
            background-image: radial-gradient(circle, white 1px, transparent 1.5px);
            background-size: 55px 55px; background-position: 25px 25px;
            animation: twinkle 4s linear infinite; animation-delay: 2s;
            opacity: 1; /* Base opacity for stars */
             z-index: 0; content: ''; position: absolute; top: 0; left: 0; height: 100%; width: 100%; pointer-events: none;
        }
        /* --- End Theme Effects --- */


        /* Map Blurb */
        #map-blurb {
            position: absolute;
            top: 10px;
            right: 10px; /* Back to default right */
            z-index: 999; /* Below controls but above map */
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            color: var(--popup-text); /* Use popup text color */
            border-radius: 6px;
            padding: 8px 12px;
            max-width: 250px; /* Limit width */
            font-size: 0.9rem;
            box-shadow: 0 1px 5px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, opacity 0.3s ease;
            opacity: 0; /* Hidden by default */
            pointer-events: none; /* Don't block map clicks */
        }
        #map-blurb.visible {
            opacity: 1;
            pointer-events: auto;
        }
        body.dark-theme #map-blurb {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
        }

        /* Popups */
        .leaflet-popup-content-wrapper { background: var(--glass-bg-light); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); color: var(--popup-text); border-radius: 8px; box-shadow: 0 3px 14px var(--shadow-color); border: 1px solid var(--glass-border-light); }
        .leaflet-popup-tip { background: transparent; box-shadow: none; }
        body.dark-theme .leaflet-popup-content-wrapper { background: var(--glass-bg-dark); border-color: var(--glass-border-dark); }
        .leaflet-popup-content { margin: 15px; font-size: 1.1rem; line-height: 1.5; }
        .leaflet-popup-content h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.3rem; font-weight: 600; color: var(--popup-text); }
        .dark-theme .leaflet-popup-close-button { color: var(--text-secondary); }
        .dark-theme .leaflet-popup-close-button:hover { color: var(--text-primary); }

        /* --- Popup Link Styling --- */
        .leaflet-popup-content h3 a,
        .leaflet-popup-content h3 a:link,
        .leaflet-popup-content h3 a:visited {
            color: inherit; /* Inherit color from the h3 (uses --popup-text) */
            text-decoration: none; /* Remove default underline */
            border-bottom: 1px dotted; /* Subtle underline */
            transition: color 0.2s ease, border-bottom-color 0.2s ease;
        }
        .leaflet-popup-content h3 a:hover,
        .leaflet-popup-content h3 a:active {
            color: var(--text-secondary); /* Use secondary color on hover */
            border-bottom-style: solid; /* Make underline solid on hover */
        }
        /* Ensure dark theme hover looks okay */
        body.dark-theme .leaflet-popup-content h3 a:hover,
        body.dark-theme .leaflet-popup-content h3 a:active {
             color: var(--text-secondary); /* Already uses variable */
        }

        /* Buttons */
        #toggle-sidebar-btn { position: absolute; bottom: 43px; left: 15px; z-index: 1000; background-color: var(--glass-bg-light); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border: 1px solid var(--glass-border-light); color: var(--text-primary); border-radius: 4px; padding: 5px 8px; cursor: pointer; font-size: 1.2rem; line-height: 1; box-shadow: 0 1px 5px var(--shadow-color); transition: background-color 0.3s ease, border-color 0.3s ease; }
        #toggle-sidebar-btn:hover { background-color: rgba(255, 255, 255, 0.75); }
        body.dark-theme #toggle-sidebar-btn { background-color: var(--glass-bg-dark); border-color: var(--glass-border-dark); }
        body.dark-theme #toggle-sidebar-btn:hover { background-color: rgba(70, 70, 70, 0.75); }
        .container.sidebar-collapsed #sidebar { width: 0; padding-left: 0; padding-right: 0; overflow: hidden; border-right: none; }

        /* Default Leaflet Zoom Control Styling */
        .leaflet-control-zoom a { background-color: var(--glass-bg-light); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border: 1px solid var(--glass-border-light); color: var(--text-primary); border-bottom: 1px solid var(--glass-border-light); transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease; }
        .leaflet-control-zoom-in { border-bottom: 1px solid var(--glass-border-light); border-radius: 4px 4px 0 0; }
        .leaflet-control-zoom-out { border-radius: 0 0 4px 4px; border: 1px solid var(--glass-border-light); border-top: none; }
        .leaflet-control-zoom a:hover { background-color: rgba(255, 255, 255, 0.75); color: #000; }
        body.dark-theme .leaflet-control-zoom a { background-color: var(--glass-bg-dark); border-color: var(--glass-border-dark); color: var(--text-primary); }
        body.dark-theme .leaflet-control-zoom-in { border-bottom: 1px solid var(--glass-border-dark); }
        body.dark-theme .leaflet-control-zoom-out { border: 1px solid var(--glass-border-dark); border-top: none; }
        body.dark-theme .leaflet-control-zoom a:hover { background-color: rgba(70, 70, 70, 0.75); color: #fff; }

        /* --- Map Control Buttons Common Style --- */
        .map-control-button {
            position: absolute;
            left: 12px; /* Adjusted slightly for default zoom control */
            z-index: 1000;
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            color: var(--text-primary);
            border-radius: 4px;
            padding: 0; /* Remove padding for icon */
            width: 32px; /* Match zoom control width */
            height: 30px; /* Match zoom control height */
            cursor: pointer;
            font-size: 1.4rem; /* Adjust icon size */
            line-height: 30px; /* Center icon vertically */
            text-align: center;
            box-shadow: 0 1px 5px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, opacity 0.2s ease;
        }
        .map-control-button:hover {
            background-color: rgba(255, 255, 255, 0.75);
        }
        body.dark-theme .map-control-button {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
            color: var(--text-primary);
        }
        body.dark-theme .map-control-button:hover {
            background-color: rgba(70, 70, 70, 0.75);
        }
        /* --- END: Map Control Buttons Common Style --- */

        /* Marker Toggle Button */
        #toggle-markers-btn {
            top: 78px; /* Position below zoom controls */
            /* Inherits from .map-control-button */
        }
        #toggle-markers-btn::before {
            content: 'üìç';
            opacity: 1; /* Default: visible */
            transition: opacity 0.2s ease;
        }
        #toggle-markers-btn.markers-hidden::before {
            opacity: 0.5; /* Dimmed when hidden */
        }

        /* --- NEW: Filter Toggle Button --- */
        #toggle-filters-btn {
            top: 115px; /* Position below marker toggle */
            /* Inherits from .map-control-button */
        }
        #toggle-filters-btn::before {
            content: 'üîé'; /* Magnifying glass icon */
            opacity: 0.6; /* Default: slightly dimmed */
        }
        #toggle-filters-btn.active::before {
            opacity: 1; /* Full opacity when active */
        }
        #toggle-filters-btn.active {
             background-color: var(--active-bg); /* Use active color */
        }
        body.dark-theme #toggle-filters-btn.active {
             background-color: var(--active-bg); /* Use active color */
        }
        /* --- END: Filter Toggle Button --- */

        /* --- NEW: Filter Panel Styling --- */
        #poi-filter-container {
            position: absolute;
            top: 110px; /* Align near the filter button */
            left: 50px; /* Position to the right of the button */
            z-index: 999; /* Below controls, above map */
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            color: var(--text-primary);
            border-radius: 6px;
            padding: 10px 15px;
            width: 180px; /* Adjust width as needed */
            max-height: calc(100vh - 200px); /* Limit height */
            overflow-y: auto;
            box-shadow: 0 1px 5px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, opacity 0.3s ease, transform 0.3s ease;
            opacity: 0;
            transform: scale(0.95);
            transform-origin: top left;
            pointer-events: none; /* Hidden by default */
        }
        #poi-filter-container.visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        body.dark-theme #poi-filter-container {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
        }
        #poi-filter-container h3 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            padding-bottom: 5px;
            border-bottom: 1px solid var(--glass-border-light);
        }
        body.dark-theme #poi-filter-container h3 {
            border-bottom-color: var(--glass-border-dark);
        }
        .filter-item {
            display: block;
            margin-bottom: 4px;
            font-size: 0.95rem;
            cursor: pointer;
            user-select: none;
        }
        .filter-item input[type="checkbox"] {
            margin-right: 8px;
            vertical-align: middle;
            cursor: pointer;
        }
        .filter-item label {
            vertical-align: middle;
            cursor: pointer;
        }
        /* --- END: Filter Panel Styling --- */

        /* Measure Tool Button */
        #measure-tool-btn {
            top: 152px; /* Position below filter toggle */
            /* Inherits from .map-control-button */
        }
        #measure-tool-btn::before {
            content: 'üìè'; /* Ruler emoji */
            opacity: 0.6; /* Default: slightly dimmed */
        }
        #measure-tool-btn.active::before {
            opacity: 1; /* Full opacity when active */
        }
        #measure-tool-btn.active {
             background-color: var(--active-bg); /* Use active color */
        }
        body.dark-theme #measure-tool-btn.active {
             background-color: var(--active-bg); /* Use active color */
        }

        /* --- NEW: Search Control Container (Bottom Center) --- */
        #search-control-container {
            position: absolute;
            bottom: 40px; /* Above bottom link bar */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            border-radius: 6px;
            padding: 5px 10px;
            box-shadow: 0 -1px 5px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease, opacity 0.3s ease;
            display: none; /* Hidden by default, shown via JS */
        }
        body.dark-theme #search-control-container {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
        }
        #poi-search-input {
            width: 250px; /* Adjust width */
            padding: 6px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            box-sizing: border-box;
            font-family: inherit;
            font-size: 0.95rem;
            outline: none;
        }
        /* --- END: Search Control Container --- */

        /* --- NEW: Search Results Container --- */
        #search-results-container {
            position: absolute;
            bottom: 80px; /* Above search bar */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001; /* Above search bar, potentially above other controls */
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            border-radius: 6px;
            padding: 5px;
            box-shadow: 0 -1px 5px var(--shadow-color);
            width: 270px; /* Match search bar width roughly */
            max-height: 150px; /* Limit height */
            overflow-y: auto;
            display: none; /* Hidden by default */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        body.dark-theme #search-results-container {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
        }
        .search-result-item {
            padding: 6px 10px;
            font-size: 0.9rem;
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .search-result-item:last-child {
            margin-bottom: 0;
        }
        .search-result-item:hover {
            background-color: var(--highlight-bg);
        }
        .search-result-item strong { /* Optional: Highlight matching part */
            font-weight: bold;
            color: var(--text-secondary); /* Or another highlight color */
        }
        /* --- END: Search Results Container --- */


        /* Theme Toggle */
        .theme-switch-wrapper { display: flex; align-items: center; margin-top: auto; padding-top: 15px; border-top: 1px solid var(--glass-border-light); flex-shrink: 0; white-space: nowrap; overflow: hidden; }
        body.dark-theme .theme-switch-wrapper { border-top-color: var(--glass-border-dark); }
        .theme-switch-wrapper span { margin-left: 10px; font-size: 1rem; color: var(--text-secondary); }
        .theme-switch { position: relative; display: inline-block; width: 50px; height: 24px; flex-shrink: 0; }
        .theme-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--slider-bg); transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; }
        input:checked + .slider { background-color: #2196F3; } /* Keep blue for dark mode toggle */
        body.dark-theme input:checked + .slider { background-color: var(--slider-color); } /* Use theme variable for dark mode */
        body.dark-theme .slider { background-color: var(--slider-bg); } /* Use theme variable for dark mode */
        input:checked + .slider:before { transform: translateX(26px); }
        .slider.round { border-radius: 24px; }
        .slider.round:before { border-radius: 50%; }

        /* Bottom Link Bar */
        #bottom-link-bar { position: absolute; bottom: 0; left: 0; width: 100%; height: 28px; background-color: var(--glass-bg-light); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-top: 1px solid var(--glass-border-light); box-sizing: border-box; display: flex; align-items: center; justify-content: center; padding: 0 15px; z-index: 1000; transition: background-color 0.3s ease, border-color 0.3s ease; }
        #bottom-link-bar a { color: var(--text-secondary); text-decoration: none; font-size: 0.85rem; margin: 0 8px; transition: color 0.2s ease; }
        #bottom-link-bar a:hover { color: var(--text-primary); text-decoration: underline; }
        body.dark-theme #bottom-link-bar { background-color: var(--glass-bg-dark); border-top-color: var(--glass-border-dark); }
        body.dark-theme #bottom-link-bar a { color: var(--text-secondary); }
        body.dark-theme #bottom-link-bar a:hover { color: var(--text-primary); }

        /* WIP Popup */
        #wip-popup { position: fixed; bottom: 43px; right: 15px; z-index: 1001; padding: 8px 12px; border: 1px solid var(--glass-border-light); border-radius: 6px; box-shadow: 0 2px 6px var(--shadow-color); transition: border-color 0.3s ease, color 0.3s ease; background: linear-gradient(to right, #ff7e7e, #ffae70, #fff078, #ffae70, #ff7e7e); background-size: 300% 100%; animation: pulseGradient 30s ease-in-out infinite; }
        #wip-popup p { margin: 0; font-size: 0.8rem; color: var(--text-primary); text-align: center; white-space: nowrap; text-shadow: 0px 0px 3px rgba(0, 0, 0, 0.4); }
        body.dark-theme #wip-popup { border-color: var(--glass-border-dark); }
        body.dark-theme #wip-popup p { text-shadow: 0px 0px 3px rgba(0, 0, 0, 0.6); }

        /* --- Measurement Tooltip --- */
        .leaflet-tooltip.measure-tooltip {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            box-shadow: none;
            font-size: 0.9rem;
            padding: 3px 6px;
        }

        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 1.2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 250px;
        }

        .loading-text {
            margin: 10px 0;
        }

        .progress-container {
            width: 100%;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            width: 0%; /* Starts at 0% */
            background-color: #2196F3;
            border-radius: 5px;
            transition: width 0.3s ease;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3); /* Light grey border */
            border-left-color: #fff; /* White for the spinning part */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin-right: 10px; /* Space between spinner and text */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


    </style>
</head>
<body>
    <!-- Container and Map Structure -->
    <div class="container">
        <div id="sidebar">
            <h2>Select Map</h2>
            <!-- Search and Filter Section REMOVED from here -->
            <ul id="map-list">
                <!-- Populated by JS -->
            </ul>
            <div class="theme-switch-wrapper">
                <label class="theme-switch" for="theme-checkbox">
                    <input type="checkbox" id="theme-checkbox" />
                    <div class="slider round"></div>
                </label>
                <span>Dark Mode</span>
            </div>
        </div>
        <div id="map-container">
            <button id="toggle-sidebar-btn" title="Collapse Sidebar">&laquo;</button>
            <div id="map"></div>

            <!-- Map Blurb Display -->
            <div id="map-blurb"></div>

            <div id="loading-indicator" style="display: none;">
                <div class="spinner"></div>
                <div class="loading-text">Loading Map...</div>
                <div class="progress-container">
                    <div class="progress-bar"></div>
                </div>
            </div>            

            <!-- Map Control Buttons -->
            <button id="toggle-markers-btn" title="Toggle Markers" class="map-control-button leaflet-control" style="display: none;"></button>
            <button id="toggle-filters-btn" title="Toggle Filters" class="map-control-button leaflet-control" style="display: none;"></button> <!-- NEW Filter Button -->
            <button id="measure-tool-btn" title="Measure Distance" class="map-control-button leaflet-control" style="display: none;"></button>
            <button id="toggle-regions-btn" title="Toggle Regions" class="map-control-button leaflet-control" style="display: none;">
                <svg viewBox="0 0 24 24" width="16" height="16">
                    <path fill="currentColor" d="M15,19L9,16.89V5L15,7.11V19M20.5,3C20.44,3 20.39,3 20.34,3L15,5.1L9,3L3.36,4.9C3.15,4.97 3,5.15 3,5.38V20.5A0.5,0.5 0 0,0 3.5,21C3.55,21 3.61,21 3.66,20.97L9,18.9L15,21L20.64,19.1C20.85,19 21,18.85 21,18.62V3.5A0.5,0.5 0 0,0 20.5,3Z"/>
                </svg>
            </button>
            
            <!-- Region Filter Panel -->
            <div id="region-filter-container" class="leaflet-control">
                <h3>Region Types:</h3>
                <div class="filter-item">
                    <input type="checkbox" id="region-toggle-all" checked>
                    <label for="region-toggle-all">Show All / Hide All</label>
                </div>
                <!-- Region type filters will be added here -->
            </div>
            <!-- END: Map Control Buttons -->

            <!-- NEW: Filter Panel (moved from sidebar) -->
            <div id="poi-filter-container" class="leaflet-control"> <!-- Added leaflet-control for potential future integration -->
                 <h3>Filter by Type:</h3>
                 <!-- Checkboxes will be populated by JS -->
                 <div class="filter-item">
                     <input type="checkbox" id="filter-toggle-all" checked>
                     <label for="filter-toggle-all">Show All / Hide All</label>
                 </div>
            </div>
            <!-- END: Filter Panel -->

            <!-- NEW: Search Control Container -->
            <div id="search-control-container" class="leaflet-control">
                <input type="search" id="poi-search-input" placeholder="Search locations...">
            </div>
            <!-- END: Search Control Container -->

            <!-- NEW: Search Results Container -->
            <div id="search-results-container" class="leaflet-control">
                <!-- Results populated by JS -->
            </div>
            <!-- END: Search Results Container -->


            <!-- Bottom Link Bar -->
            <div id="bottom-link-bar">
                <a href="https://jsnj.link/maps-to-wiki" target="_blank">Wiki</a> |
                <a href="https://jsnj.link/maps-blog-post" target="_blank">Blog</a> |
                <a href="about.html" class="back-link">About </a> |
                <a href="https://jsnj.link/map-hiraeth-source" target="_blank">Source </a>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>

    <!-- Main Application JS -->
    <script>
        let loadingProgressInterval = null;
        let loadingProgress = 0;
        // Add to your global variables
        let currentRegionGroup = null;
        let regionsVisible = false;
        let regionFiltersPanelVisible = false;

        // Function to add regions to map (modified to use mapData structure)
        function addRegionsToMap(mapId) {
            // Clear previous regions
            if (!currentRegionGroup) {
                currentRegionGroup = L.layerGroup().addTo(map);
            } else {
                currentRegionGroup.clearLayers();
            }
            
            // Find the map data
            const selectedMap = findMapRecursive(mapData, mapId);
            if (!selectedMap || !selectedMap.regions || !Array.isArray(selectedMap.regions)) {
                console.log(`No regions found for map: ${mapId}`);
                return;
            }
            
            // Add each region as a polygon
            selectedMap.regions.forEach(region => {
                if (!region.coordinates || region.coordinates.length < 3) {
                    console.warn(`Invalid coordinates for region: ${region.name}`);
                    return;
                }
                
                const polygon = L.polygon(region.coordinates, {
                    color: region.color || '#3388ff',
                    fillColor: region.fillColor || '#3388ff',
                    fillOpacity: regionsVisible ? (region.fillOpacity || 0.2) : 0,
                    weight: 2,
                    opacity: regionsVisible ? 1 : 0
                });
                
                // Add popup with region info
                let popupContent = `<h3>${region.name}</h3>`;
                if (region.description) {
                    popupContent += `<p>${region.description}</p>`;
                }
                if (region.wikiLink) {
                    popupContent += `<p><a href="${region.wikiLink}" target="_blank" rel="noopener noreferrer">Learn more</a></p>`;
                }
                polygon.bindPopup(popupContent);
                
                // Store region data with the polygon for filtering
                polygon.regionData = region;
                
                // Add to the region group
                currentRegionGroup.addLayer(polygon);
                
                // Ensure regions are behind markers
                polygon.bringToBack();
            });
        }

        // Populate region filters based on the loaded map
        function populateRegionFilters(mapId) {
            // Clear existing filters except toggle-all
            const existingFilters = regionFilterContainer.querySelectorAll('.filter-item:not(:first-child)');
            existingFilters.forEach(el => el.remove());
            
            const selectedMap = findMapRecursive(mapData, mapId);
            if (!selectedMap || !selectedMap.regions || !Array.isArray(selectedMap.regions) || selectedMap.regions.length === 0) {
                toggleRegionsBtn.style.display = 'none';
                regionFilterContainer.classList.remove('visible');
                return;
            }
            
            // Get unique region types
            const regionTypes = [...new Set(selectedMap.regions.map(r => r.type).filter(Boolean))];
            
            // Add filter for each type
            regionTypes.forEach(type => {
                const filterId = `filter-region-${type.replace(/\s+/g, '-')}`;
                const div = document.createElement('div');
                div.className = 'filter-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = filterId;
                checkbox.value = type;
                checkbox.className = 'region-type-filter';
                checkbox.checked = true;
                
                checkbox.addEventListener('change', updateVisibleRegions);
                
                const label = document.createElement('label');
                label.htmlFor = filterId;
                label.textContent = type.charAt(0).toUpperCase() + type.slice(1); // Capitalize
                
                div.appendChild(checkbox);
                div.appendChild(label);
                regionFilterContainer.appendChild(div);
            });
            
            // Show regions button if there are regions
            toggleRegionsBtn.style.display = regionTypes.length > 0 ? 'block' : 'none';
        }

        // --- Initialize Leaflet Map ---
        const map = L.map('map', {
            crs: L.CRS.Simple,
            minZoom: -3,
            maxZoom: 4,
            attributionControl: false,
            zoomControl: false // Disable default zoom, using custom styled one
        });
        // Add styled zoom control
        L.control.zoom({ position: 'topleft' }).addTo(map);

        const poiTypeGroups = {
            "Settlements": ["City", "Town", "Village", "Hamlet", "Settlement", "Capital"],
            "Structures": ["Castle", "Fortress", "Fort", "Tower", "Ruin", "Temple", "Shrine", "Mine", "Lighthouse", "Bridge", "Dungeon", "Lair", "Camp", "Asylum", "Landmark"],
            "Natural Features": ["Mountain", "Peak", "Forest", "Wood", "River", "Lake", "Cave", "Cavern", "Coast", "Bay", "Cove", "Swamp", "Marsh", "Desert", "Natural Landmark"],
            "Other": ["Point of Interest", "Region", "Portal"],
            "Unknown": ["Unknown"]
        };

        // --- Auto-generate a reverse map for quick lookup (Type -> Group) ---
        const typeToGroupMap = {};
        for (const groupName in poiTypeGroups) {
            poiTypeGroups[groupName].forEach(type => {
                typeToGroupMap[type] = groupName;
            });
        }
        // --- END: POI Type Grouping Configuration ---

        // --- Global variables ---
        let currentImageLayer = null;
        let currentMarkerGroup = null; // Holds currently *visible* markers
        let allMapMarkers = []; // Holds *all* markers for the loaded map
        let currentBounds = null;
        let currentlyLoadedMapId = null;
        let currentSidebarState = 'o';
        let markersVisible = true; // Overall visibility toggle state
        const transitionDuration = 300; // ms for sidebar animation
        let filtersPanelVisible = false; // NEW: State for filter panel visibility

        // --- Measurement Tool State ---
        let isMeasuring = false;
        let measurementStartPoint = null;
        let measurementLayerGroup = L.layerGroup().addTo(map); // For temp markers/lines

        // --- DOM Elements ---
        const container = document.querySelector('.container');
        const sidebar = document.getElementById('sidebar');
        const mapListElement = document.getElementById('map-list');
        const toggleBtn = document.getElementById('toggle-sidebar-btn');
        const themeToggle = document.getElementById('theme-checkbox');
        const bodyElement = document.body;
        const mapElement = document.getElementById('map'); // Get map div
        const mapBlurbElement = document.getElementById('map-blurb');
        const toggleMarkersBtn = document.getElementById('toggle-markers-btn');
        // --- NEW/MODIFIED: Search/Filter/Measure Elements ---
        const searchControlContainer = document.getElementById('search-control-container'); // NEW
        const poiSearchInput = document.getElementById('poi-search-input');
        const searchResultsContainer = document.getElementById('search-results-container'); // NEW
        const poiFilterContainer = document.getElementById('poi-filter-container'); // Now the panel
        const filterToggleAllCheckbox = document.getElementById('filter-toggle-all');
        const toggleFiltersBtn = document.getElementById('toggle-filters-btn'); // NEW Filter Button
        const measureToolBtn = document.getElementById('measure-tool-btn');
        const loadingIndicator = document.getElementById('loading-indicator');


        // --- Helper Functions ---
        function findMapRecursive(items, id) {
            for (const item of items) {
                if (item.id === id) { return item; }
                if (item.type === 'folder' && item.children) {
                    const found = findMapRecursive(item.children, id);
                    if (found) return found;
                }
            }
            return null;
        }

        function findFirstLoadableIdRecursive(items) {
            for (const item of items) {
                if (item.id && item.status !== 'coming-soon') return item.id;
                if (item.type === 'folder' && item.children) {
                    const foundId = findFirstLoadableIdRecursive(item.children);
                    if (foundId) return foundId;
                }
            }
            // Fallback: If only coming-soon items exist, return the first ID found
            for (const item of items) {
                 if (item.id) return item.id;
                 if (item.type === 'folder' && item.children) {
                     const foundId = findFirstLoadableIdRecursive(item.children); // Re-run without status check
                     if (foundId) return foundId;
                 }
            }
            return null;
        }

        function parseHash() {
            const hash = window.location.hash.substring(1);
            let mapId = null;
            let sidebarState = null;
            if (hash) {
                const parts = hash.split('-s=');
                mapId = parts[0];
                if (parts.length > 1 && ['o', 'c'].includes(parts[1])) {
                    sidebarState = parts[1];
                }
            }
            const defaultMapId = findFirstLoadableIdRecursive(mapData);

            return {
                mapId: mapId || defaultMapId,
                sidebarState: sidebarState || 'o'
            };
        }
        function generateHash(mapId, sidebarState) {
            return `#${mapId || ''}-s=${sidebarState}`;
        }

        // --- Function to Set Sidebar State ---
        function setSidebarState(state, updateHash = true) {
            const shouldBeCollapsed = (state === 'c');
            const isCurrentlyCollapsed = container.classList.contains('sidebar-collapsed');
            if (shouldBeCollapsed !== isCurrentlyCollapsed) {
                console.log(`Setting sidebar state to: ${state}`);
                container.classList.toggle('sidebar-collapsed', shouldBeCollapsed);
                toggleBtn.innerHTML = shouldBeCollapsed ? '&raquo;' : '&laquo;';
                toggleBtn.title = shouldBeCollapsed ? 'Expand Sidebar' : 'Collapse Sidebar';

                // Invalidate map size after CSS transition completes
                setTimeout(() => { map.invalidateSize({ animate: true }); }, transitionDuration);

                 currentSidebarState = state;
                 if (updateHash && currentlyLoadedMapId) {
                     const newHash = generateHash(currentlyLoadedMapId, state);
                     console.log("Updating hash from setSidebarState:", newHash);
                     history.replaceState(null, '', newHash); // Use replaceState for sidebar toggle
                 }
            } else {
                 currentSidebarState = state;
                 console.log(`Sidebar already in state: ${state}`);
            }
        }

        // --- Helper Function to Update the "Toggle All" Checkbox State ---
        function updateToggleAllCheckboxState() {
            const allSpecificFilters = poiFilterContainer.querySelectorAll('.poi-filter-checkbox:not(#filter-toggle-all)');
            const checkedSpecificFilters = poiFilterContainer.querySelectorAll('.poi-filter-checkbox:not(#filter-toggle-all):checked');

            if (allSpecificFilters.length === 0) {
                filterToggleAllCheckbox.checked = true;
                filterToggleAllCheckbox.indeterminate = false;
            } else if (checkedSpecificFilters.length === 0) {
                filterToggleAllCheckbox.checked = false;
                filterToggleAllCheckbox.indeterminate = false;
            } else if (checkedSpecificFilters.length === allSpecificFilters.length) {
                filterToggleAllCheckbox.checked = true;
                filterToggleAllCheckbox.indeterminate = false;
            } else {
                filterToggleAllCheckbox.checked = false;
                filterToggleAllCheckbox.indeterminate = true;
            }
        }

        // --- Map Data Configuration ---
        // IMPORTANT: Ensure you have created .webp versions of your map images!
        // IMPORTANT: Add scalePixels and scaleKilometers for maps needing measurement.
        // *** REPLACE PLACEHOLDER SCALE VALUES BELOW WITH YOUR ACTUAL VALUES ***
        const mapData = [
            {
                type: 'folder',
                id: 'main_continent',
                name: 'Content Map',
                width: 8192,
                height: 6144,
                imageUrl: 'maps/Fair-Content.webp',
                // --- ADD SCALE IF KNOWN ---
                // scalePixels: 1000, // Example: 1000 pixels...
                // scaleKilometers: 50, // Example: ...represents 50 km
                blurb: "The main continent, featuring diverse regions from frozen peaks to bustling capitals.",
                pointsOfInterest: [
                    // No POIs here in this example, add if needed
                ],
                children: [
                    {
                        id: 'icebeach_detail',
                        name: 'Icebeach',
                        width: 7016,
                        height: 4960,
                        imageUrl: 'maps/IceBeach.webp',
                        scalePixels: 3,
                        scaleKilometers: 1,
                        blurb: "A detailed view of the <a href='https://www.hiraeth.wiki/books/players-guide-to-icebeach' target='_blank' rel='noopener noreferrer'>Icebeach region</a>, known for its harsh climate and resilient settlements.",
                        pointsOfInterest: [
                             {
                                coords: [3516, 3698],
                                name: "Castgate",
                                type: "City",
                                description: "Renowned for its picturesque beauty and protective magical dome, this town thrives on fishing, shipbuilding, and gemstone mining, serving as a hub influenced by the Athenaeum and marked by historical battles.",
                                wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/casgate"
                             },
                             {
                                coords: [2736, 4098],
                                name: "Flamore",
                                type: "Ruin",
                                description: "This now ruined Wizard's college was a blacksite training ground.",
                                wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/flamores-school-of-experimental-wizardry"
                             },
                             {
                                coords: [2310, 2722],
                                name: "Fractured Point",
                                type: "Capital",
                                description: "Perched on a rocky crag, this walled town often serves as the first stop for visitors, acting as a lighthouse and beacon where traders find ways to prosper despite the harsh conditions.",
                                wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/the-fractured-point"
                             },
                             { coords: [3422, 4370], name: "Gernerum", type: "Village", description: "Now destroyed after a battle with a mechanical dragon, this former town was once home to several notable figures from Icebeach history, with only a hag rumored to have survived.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/gernerum" },
                             { coords: [780, 1080], name: "Houlen Top", type: "Town", description: "Known as the \"breadbasket of the north,\" this southernmost town cultivates grains and root vegetables in its valley, though its inhabitants are notably guarded against outsiders.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/howlentop" },
                             { coords: [3876, 2990], name: "Icemoor", type: "Settlement", description: "Once tasked with watching the Winrich Glacier from its tall tower, this settlement is now mostly abandoned, left with only a few older men maintaining the vigil after the endless winter.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/icemoor" },
                             { coords: [4358, 2976], name: "Little Rock Mentle Asylam", type: "Asylum", description: "This small institution holds some of the most hardened crimnals of the Gilded Nations.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/little-rock-mental-asylum" },
                             { coords: [2938, 4182], name: "Morana's Fang", type: "Mountain", description: "The tallest point in the world.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/moranas-fang" },
                             { coords: [604, 2416], name: "Mt. Solaria", type: "Mountain", description: "A large mountian said to be inhabited by a dragon.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/mt-solaria" },
                             { coords: [1664, 3372], name: "Ottiker", type: "Town", description: "Founded by immigrants on the shores of Sleetmond Lake, this town is recognized for its winery, despite recent conflicts with local druids halting deliveries.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/niror" },
                             { coords: [1210, 3924], name: "Quilt", type: "Hamlet", description: "Situated on the Foaming Loch, this small community practices fish farming and is named for the distinctive dyed quilts crafted from local Icesheep wool.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/quilt" },
                             { coords: [1356, 1620], name: "Shiverwallow", type: "Village", description: "Protected by a wooden wall extending into the now-frozen harbor, this town boasts the largest fishing fleet, adapting its industry to ice fishing during the eternal winter.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/shiverwallow" },
                             { coords: [2154, 3588], name: "Sleetmond", type: "Settlement", description: "Home to druidic practices centered around The Hope Tree and a Sugar Maple orchard, this small lakeside town supplements its diet with fish and unique Icebeach sheep, though its ways are sometimes distrusted.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/sleetmond" },
                             { coords: [1116, 4038], name: "The Foaming Burrow", type: "Cavern", description: "The origin of the river, how water bubbles forth outo of this cave.", wikiLink: "TBD" },
                             { coords: [2036, 3074], name: "The Hope Tree", type: "Natural Landmark", description: "A tall tree provides shelter and wamth in the surrounding area.  It is said the tree is super magical and its leaves can make a healing tea.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/the-hope-tree" },
                             { coords: [2862, 4840], name: "Thrawbreak", type: "Hamlet", description: "Nestled below the Auruan mountains, this quiet, isolated town originated as a mountaineering camp and is now known for its resilient tavern culture amidst surrounding ruins.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/thrawbreak" },
                             { coords: [4266, 3192], name: "Whitedrift", type: "Settlement", description: "Located at the mouth of the Curse Run near the Winrich glacier, this small town houses an unstable population tasked with monitoring the glacier, including some former asylum inmates.", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/whitedrift" },
                             { coords: [4002, 3488], name: "Winrich Fortress", type: "Fortress", description: "The Ancient fortress of a long dead and powerful Lich", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/winrich-fortress" },
                             { coords: [716, 1508], name: "Wynwood Peak", type: "Mountain", description: "This smaller mountian is said to be a place were the...", wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach/page/wynwood-peak" }
                        ],
                        regions: [
                                {
                                    id: "region-kingdom-of-icebeach",
                                    name: "Kingdom of Icebeach",
                                    description: "The northern kingdom known for its harsh climate",
                                    type: "political",
                                    color: "#3388ff",
                                    fillColor: "#3388ff",
                                    fillOpacity: 0.2,
                                    wikiLink: "https://www.hiraeth.wiki/books/players-guide-to-icebeach",
                                    coordinates: [
                                        [3000,2000],
                                        [3680,2176],
                                        [4000,2500],
                                        [3800,3500],
                                        [2900,3000],
                                        [3000,2000]]
                                    },
                                    {
                                    id: "region-winrich-glacier",
                                    name: "Winrich Glacier",
                                    description: "",
                                    type: "terrain",
                                    color: "#33aa33",
                                    fillColor: "#33aa33",
                                    fillOpacity: 0.2,
                                    wikiLink: "",
                                    coordinates: [
                                        [3694,3695],
                                        [3738,3777],
                                        [3752,3818],
                                        [3730,3841],
                                        [3733,3887],
                                        [3758,3910],
                                        [3748,3942],
                                        [3708,3935],
                                        [3680,3940],
                                        [3654,3919],
                                        [3639,3936],
                                        [3626,3944],
                                        [3611,3944],
                                        [3587,3955],
                                        [3567,3965],
                                        [3561,3972],
                                        [3547,3991],
                                        [3532,4006],
                                        [3504,4030],
                                        [3491,4035],
                                        [3483,4041],
                                        [3474,4046],
                                        [3462,4065],
                                        [3452,4074],
                                        [3451,4087],
                                        [3451,4095],
                                        [3440,4095],
                                        [3440,4123],
                                        [3436,4138],
                                        [3435,4143],
                                        [3435,4158],
                                        [3436,4173],
                                        [3436,4179],
                                        [3429,4183],
                                        [3425,4185],
                                        [3425,4205],
                                        [3421,4228],
                                        [3411,4242],
                                        [3409,4261],
                                        [3408,4285],
                                        [3409,4304],
                                        [3390,4292],
                                        [3374,4273],
                                        [3363,4265],
                                        [3352,4241],
                                        [3338,4232],
                                        [3325,4236],
                                        [3325,4256],
                                        [3319,4261],
                                        [3312,4264],
                                        [3307,4269],
                                        [3301,4285],
                                        [3290,4284],
                                        [3286,4291],
                                        [3286,4291],
                                        [3276,4281],
                                        [3253,4246],
                                        [3225,4234],
                                        [3210,4244],
                                        [3198,4256],
                                        [3196,4273],
                                        [3187,4298],
                                        [3172,4311],
                                        [3152,4286],
                                        [3132,4244],
                                        [3111,4285],
                                        [3098,4273],
                                        [3091,4285],
                                        [3074,4267],
                                        [3047,4217],
                                        [3018,4265],
                                        [2988,4222],
                                        [3025,4190],
                                        [2984,4145],
                                        [3010,4111],
                                        [3000,4094],
                                        [3078,3988],
                                        [3106,3985],
                                        [3109,4036],
                                        [3175,3917],
                                        [3203,3923],
                                        [3203,3950],
                                        [3235,3877],
                                        [3266,3844],
                                        [3296,3859],
                                        [3296,3878],
                                        [3299,3862],
                                        [3308,3899],
                                        [3342,3835],
                                        [3694,3695]
                                ]
                                }
                            ]
                    },
                    {
                        id: 'Old-Lin',
                        name: 'Old-Lin',
                        status: 'coming-soon' // Mark as unavailable
                    },
                    {
                        id: 'southern-thalassia',
                        name: 'Southern Thalassia',
                        status: 'coming-soon'
                    }
                ]
            },
            {
                 id: 'system',
                 name: 'Solar System',
                 status: 'coming-soon'
                 // No scale needed for this type of map perhaps
            }
        ];

        // --- MODIFIED: Function to Update Visible Markers AND Search Results ---
        function updateVisibleMarkersAndSearch() {
            if (!currentMarkerGroup || allMapMarkers.length === 0) {
                // Hide map-based controls if no markers
                searchControlContainer.style.display = 'none';
                searchResultsContainer.style.display = 'none';
                poiFilterContainer.classList.remove('visible'); // Hide filter panel
                toggleFiltersBtn.style.display = 'none'; // Hide filter button
                filtersPanelVisible = false;
                toggleFiltersBtn.classList.remove('active');
                return;
            }

            // Ensure map-based controls are potentially visible if markers exist
            searchControlContainer.style.display = 'block';
            toggleFiltersBtn.style.display = 'block'; // Show filter button

            const searchTerm = poiSearchInput.value.toLowerCase().trim();
            searchResultsContainer.innerHTML = ''; // Clear previous results
            let searchResultFound = false;

            // Get the set of *specifically* checked group filters
            const activeSpecificGroupFilters = new Set();
            poiFilterContainer.querySelectorAll('.poi-filter-checkbox:not(#filter-toggle-all):checked').forEach(checkbox => {
                 activeSpecificGroupFilters.add(checkbox.value);
            });

            allMapMarkers.forEach(marker => {
                const poi = marker.poiData;
                if (!poi) return;

                const nameMatch = !searchTerm || poi.name.toLowerCase().includes(searchTerm);

                const specificType = poi.type || 'Unknown';
                const poiGroup = typeToGroupMap[specificType] || 'Other';
                let groupMatch = false;
                if (activeSpecificGroupFilters.size > 0) {
                    groupMatch = activeSpecificGroupFilters.has(poiGroup);
                }

                // Update marker visibility on map
                if (markersVisible && nameMatch && groupMatch) {
                    if (!currentMarkerGroup.hasLayer(marker)) {
                        currentMarkerGroup.addLayer(marker);
                    }
                } else {
                    if (currentMarkerGroup.hasLayer(marker)) {
                        currentMarkerGroup.removeLayer(marker);
                    }
                }

                // --- NEW: Populate Search Results ---
                if (searchTerm && nameMatch) { // Only add to results if search term exists and name matches
                    searchResultFound = true;
                    const resultItem = document.createElement('div');
                    resultItem.className = 'search-result-item';
                    // Basic highlighting (optional)
                    const highlightedName = poi.name.replace(
                        new RegExp(searchTerm, 'gi'),
                        '<strong>$&</strong>'
                    );
                    resultItem.innerHTML = highlightedName; // Use innerHTML for highlighting
                    resultItem.title = `Go to ${poi.name}`;
                    resultItem.addEventListener('click', () => {
                        map.flyTo(marker.getLatLng(), Math.max(map.getZoom(), 1)); // Fly to marker, ensure zoom >= 1
                        marker.openPopup();
                        // Clear search and hide results
                        poiSearchInput.value = '';
                        searchResultsContainer.style.display = 'none';
                        searchResultsContainer.innerHTML = '';
                    });
                    searchResultsContainer.appendChild(resultItem);
                }
                // --- END: Populate Search Results ---
            });

            // Show/hide search results container
            searchResultsContainer.style.display = searchResultFound ? 'block' : 'none';
        }


        // --- MODIFIED: Function to Populate Filter Checkboxes (in the panel) ---
        function populateFilters(pointsOfInterest) {
            // Clear existing filters (except the 'Toggle All' template)
            const existingFilters = poiFilterContainer.querySelectorAll('.filter-item:not(:first-child)');
            existingFilters.forEach(el => el.remove());

            const hasPOIs = pointsOfInterest && pointsOfInterest.length > 0;

            // Hide filter panel and button if no POIs
            if (!hasPOIs) {
                poiFilterContainer.classList.remove('visible');
                toggleFiltersBtn.style.display = 'none';
                filtersPanelVisible = false;
                toggleFiltersBtn.classList.remove('active');
                filterToggleAllCheckbox.checked = true;
                filterToggleAllCheckbox.indeterminate = false;
                return;
            }

            // Determine relevant groups for this map
            const relevantGroups = new Set();
            pointsOfInterest.forEach(poi => {
                const specificType = poi.type || 'Unknown';
                const group = typeToGroupMap[specificType] || 'Other';
                relevantGroups.add(group);
            });

            const sortedGroups = Array.from(relevantGroups).sort();
            let filtersAdded = false;

            // Create checkboxes for relevant groups
            sortedGroups.forEach(groupName => {
                if (!groupName || (poiTypeGroups[groupName] && poiTypeGroups[groupName].length === 0)) {
                    return;
                }
                filtersAdded = true; // Mark that we added at least one filter

                const filterId = `filter-group-${groupName.replace(/\s+/g, '-')}`;
                const div = document.createElement('div');
                div.className = 'filter-item';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = filterId;
                checkbox.value = groupName;
                checkbox.checked = true; // Default checked
                checkbox.className = 'poi-filter-checkbox';

                checkbox.addEventListener('change', () => {
                    updateVisibleMarkersAndSearch(); // Update markers/search first
                    updateToggleAllCheckboxState(); // Then update master toggle appearance
                });

                const label = document.createElement('label');
                label.htmlFor = filterId;
                label.textContent = groupName;

                div.appendChild(checkbox);
                div.appendChild(label);
                poiFilterContainer.appendChild(div);
            });

            // Show/hide the filter *button* based on whether filters were actually added
            toggleFiltersBtn.style.display = filtersAdded ? 'block' : 'none';
            // Ensure panel is hidden initially and button is not active
            poiFilterContainer.classList.remove('visible');
            filtersPanelVisible = false;
            toggleFiltersBtn.classList.remove('active');

            filterToggleAllCheckbox.checked = true;
            filterToggleAllCheckbox.indeterminate = false;
        }


// --- Function to Load/Switch Map (Updated with Regions) ---
function loadMap(mapId, updateHash = true) {
    // --- NEW: Reset and show loading indicator with progress bar ---
    if (loadingIndicator) {
        loadingIndicator.style.display = 'flex'; // Use flex for alignment
        const progressBar = loadingIndicator.querySelector('.progress-bar');
        const loadingText = loadingIndicator.querySelector('.loading-text'); // Get text element
        const spinner = loadingIndicator.querySelector('.spinner'); // Get spinner

        // Reset progress bar and text
        loadingProgress = 0;
        if (progressBar) progressBar.style.width = '0%';
        if (loadingText) loadingText.textContent = "Loading Map...";
        if (spinner) spinner.style.display = 'block'; // Ensure spinner is visible

        // Clear any existing interval
        if (loadingProgressInterval) clearInterval(loadingProgressInterval);

        // Start fake progress that goes to 90% (saving last 10% for actual completion)
        loadingProgressInterval = setInterval(() => {
            if (loadingProgress < 90) {
                // Use a slightly more consistent increment for smoother feel
                loadingProgress += 2 + Math.random() * 3;
                loadingProgress = Math.min(loadingProgress, 90); // Cap at 90%
                if (progressBar) progressBar.style.width = loadingProgress + '%';
            } else {
                // Once we hit 90%, clear the interval, the rest happens on load/error
                clearInterval(loadingProgressInterval);
                loadingProgressInterval = null;
            }
        }, 150); // Faster interval for quicker initial progress
    }
    // --- END: Loading Indicator Setup ---

    // Deactivate measurement tool if active
    if (isMeasuring) {
        toggleMeasurementTool(); // Turn it off
    }
    measurementLayerGroup.clearLayers();

    // --- Hide Search/Filter/Region UI during load ---
    searchControlContainer.style.display = 'none';
    searchResultsContainer.style.display = 'none';
    poiFilterContainer.classList.remove('visible');
    toggleFiltersBtn.style.display = 'none';
    filtersPanelVisible = false;
    toggleFiltersBtn.classList.remove('active');
    poiSearchInput.value = ''; // Clear search input
    // --- NEW: Hide Region UI ---
    toggleRegionsBtn.style.display = 'none';
    regionFilterContainer.classList.remove('visible');
    regionFiltersPanelVisible = false;
    toggleRegionsBtn.classList.remove('active');
    // --- END: Hide Region UI ---

    const selectedMap = findMapRecursive(mapData, mapId);

    // --- Clear Filter Checkboxes (important before populateFilters) ---
    const existingFilters = poiFilterContainer.querySelectorAll('.filter-item:not(:first-child)');
    existingFilters.forEach(el => el.remove());
    filterToggleAllCheckbox.checked = true;
    filterToggleAllCheckbox.indeterminate = false;

    // --- NEW: Clear Region Filter Checkboxes ---
    const existingRegionFilters = regionFilterContainer.querySelectorAll('.filter-item:not(:first-child)');
    existingRegionFilters.forEach(el => el.remove());
    if (regionToggleAllCheckbox) regionToggleAllCheckbox.checked = true; // Check if exists
    // --- END: Clear Region Filter Checkboxes ---

    if (!selectedMap || selectedMap.status === 'coming-soon') {
        console.warn("Attempted to load map data not found or coming soon:", mapId);
        if (selectedMap) { alert(`The map "${selectedMap.name}" is coming soon!`); }
        if (currentImageLayer) map.removeLayer(currentImageLayer);
        if (currentMarkerGroup) map.removeLayer(currentMarkerGroup);
        if (currentRegionGroup) map.removeLayer(currentRegionGroup); // NEW: Remove regions
        currentImageLayer = null;
        currentMarkerGroup = null;
        currentRegionGroup = null; // NEW: Reset region group
        allMapMarkers = [];
        currentlyLoadedMapId = null;
        mapBlurbElement.classList.remove('visible');
        toggleMarkersBtn.style.display = 'none';
        measureToolBtn.style.display = 'none';
        toggleFiltersBtn.style.display = 'none'; // Hide filter button
        searchControlContainer.style.display = 'none'; // Hide search
        toggleRegionsBtn.style.display = 'none'; // NEW: Hide region button
        if (updateHash) { history.pushState(null, '', generateHash('', currentSidebarState)); }

        // --- NEW: Hide loading indicator on failure/coming soon ---
        if (loadingIndicator) {
            if (loadingProgressInterval) clearInterval(loadingProgressInterval);
            loadingIndicator.style.display = 'none';
        }
        return;
    }

    if (mapId === currentlyLoadedMapId) {
         console.log(`Map ${mapId} is already loaded.`);
         if (updateHash) {
             const currentHash = generateHash(mapId, currentSidebarState);
             if (window.location.hash !== currentHash) {
                  console.log("Updating hash from loadMap (state change only):", currentHash);
                  history.replaceState(null, '', currentHash);
             }
         }
         // --- NEW: Hide loading indicator if map already loaded ---
         if (loadingIndicator) {
             if (loadingProgressInterval) clearInterval(loadingProgressInterval);
             loadingIndicator.style.display = 'none';
         }
         return;
    }

    console.log(`Loading map: ${selectedMap.name} (ID: ${mapId})`);

    // Remove previous layers
    if (currentImageLayer) map.removeLayer(currentImageLayer);
    if (currentMarkerGroup) map.removeLayer(currentMarkerGroup);
    if (currentRegionGroup) map.removeLayer(currentRegionGroup); // NEW: Remove regions

    // Reset marker state
    currentMarkerGroup = L.layerGroup();
    allMapMarkers = [];
    // NEW: Reset region state
    currentRegionGroup = L.layerGroup().addTo(map); // Add immediately so it's under markers
    regionsVisible = false; // Reset visibility state
    regionFiltersPanelVisible = false; // Reset panel state

    const mapHeight = selectedMap.height;
    const mapWidth = selectedMap.width;
    if (isNaN(mapHeight) || isNaN(mapWidth) || !selectedMap.imageUrl) {
        console.error(`Invalid dimensions or missing imageUrl for map ID ${mapId}`);
        mapBlurbElement.classList.remove('visible');
        toggleMarkersBtn.style.display = 'none';
        measureToolBtn.style.display = 'none';
        toggleFiltersBtn.style.display = 'none';
        searchControlContainer.style.display = 'none';
        toggleRegionsBtn.style.display = 'none'; // NEW: Hide region button
        currentlyLoadedMapId = null;
        if (updateHash) { history.pushState(null, '', generateHash('', currentSidebarState)); }

        // --- NEW: Hide loading indicator on invalid map data ---
        if (loadingIndicator) {
            if (loadingProgressInterval) clearInterval(loadingProgressInterval);
            const loadingText = loadingIndicator.querySelector('.loading-text');
            const progressBar = loadingIndicator.querySelector('.progress-bar');
            const spinner = loadingIndicator.querySelector('.spinner');
            if(loadingText) loadingText.textContent = "Error: Invalid map data.";
            if(progressBar) progressBar.style.width = '0%';
            if(spinner) spinner.style.display = 'none'; // Hide spinner on error
            setTimeout(() => { loadingIndicator.style.display = 'none'; }, 3000);
        }
        return;
    }
    currentBounds = [[0, 0], [mapHeight, mapWidth]];

    // Main Image Layer
    currentImageLayer = L.imageOverlay(selectedMap.imageUrl, currentBounds);

    // --- FIXED: Preload image and setup handlers to avoid race condition ---
    const preloadImg = new Image();
    let imageLoaded = false; // Flag to prevent double execution
    let loadingComplete = false; // Flag to track if finishLoading has run
    let loadingTimeout = null; // Variable for the fallback timer

    // Function to handle successful loading - will only run once
    function finishLoading() {
        if (loadingComplete) return; // Guard against double execution
        loadingComplete = true; // Mark as complete
        clearTimeout(loadingTimeout); // Clear the fallback timer

        console.log("Image overlay loaded (or timed out).");
        if (loadingIndicator) {
            const progressBar = loadingIndicator.querySelector('.progress-bar');
            if (progressBar) {
                // Complete the progress bar animation
                progressBar.style.width = '100%';
                // Hide after a short delay to show completion
                setTimeout(() => {
                    // Ensure interval is cleared *before* hiding
                    if (loadingProgressInterval) clearInterval(loadingProgressInterval);
                    loadingProgressInterval = null; // Reset interval variable
                    loadingIndicator.style.display = 'none';
                }, 300); // Short delay to see 100%
            } else {
                // Fallback if no progress bar
                if (loadingProgressInterval) clearInterval(loadingProgressInterval);
                loadingProgressInterval = null;
                loadingIndicator.style.display = 'none';
            }
        }
        // Fit bounds *after* image is loaded and indicator is handled
        map.fitBounds(currentBounds);
    }

    // Handler for the preloaded image
    preloadImg.onload = function() {
        console.log("Preload image onload fired.");
        imageLoaded = true;
        finishLoading();
    };

    // Handler for the Leaflet layer's load event (backup)
    currentImageLayer.on('load', function() {
        console.log("Leaflet image layer onload fired.");
        imageLoaded = true; // Mark as loaded just in case preload didn't fire
        finishLoading();
    });

    // --- MODIFIED: Image Error Handler ---
    currentImageLayer.on('error', function() {
         if (loadingComplete) return; // Don't run error if loading already finished
         loadingComplete = true; // Mark as complete to prevent finishLoading timer
         clearTimeout(loadingTimeout); // Clear the fallback timer

         console.error("Image overlay failed to load:", selectedMap.imageUrl);
         if (loadingIndicator) {
             // Clear interval immediately on error
             if (loadingProgressInterval) clearInterval(loadingProgressInterval);
             loadingProgressInterval = null;

             const progressBar = loadingIndicator.querySelector('.progress-bar');
             const loadingText = loadingIndicator.querySelector('.loading-text');
             const spinner = loadingIndicator.querySelector('.spinner');

             if (progressBar) progressBar.style.width = '0%'; // Reset progress
             if (loadingText) loadingText.textContent = "Error loading map image.";
             if (spinner) spinner.style.display = 'none'; // Hide spinner on error

             // Hide after a delay to show error message
             setTimeout(() => { loadingIndicator.style.display = 'none'; }, 3000);
         }
         // Clear map state on error
         if (currentImageLayer) map.removeLayer(currentImageLayer);
         currentImageLayer = null;
         currentlyLoadedMapId = null; // Prevent hash updates for failed load
         // Also hide map-specific controls
         toggleMarkersBtn.style.display = 'none';
         measureToolBtn.style.display = 'none';
         toggleFiltersBtn.style.display = 'none';
         searchControlContainer.style.display = 'none';
         toggleRegionsBtn.style.display = 'none'; // NEW: Hide region button
    });

    // --- ADDED: Fallback timer to ensure loading completes ---
    loadingTimeout = setTimeout(() => {
        console.warn("Loading fallback timer triggered.");
        finishLoading(); // Force completion if events haven't fired
    }, 8000); // 8 seconds max wait time

    // Start preloading the image *after* setting up handlers
    preloadImg.src = selectedMap.imageUrl;

    // Add layer to map *after* setting up handlers
    currentImageLayer.addTo(map);
    // --- END: Preload and Handler Fix ---

    // Add Points of Interest
    const points = selectedMap.pointsOfInterest || [];
    populateFilters(points); // Populate POI filters

    points.forEach(point => {
        if (point.coords && point.coords.length === 2 && !isNaN(point.coords[0]) && !isNaN(point.coords[1])) {
            // Check bounds carefully: Lat (Y) is coord[0], Lng (X) is coord[1]
            if (point.coords[0] >= 0 && point.coords[0] <= mapHeight && point.coords[1] >= 0 && point.coords[1] <= mapWidth) {
                 const marker = L.marker(point.coords);
                 marker.poiData = point; // Store POI data
                 let popupContent = '';
                 if (point.wikiLink) {
                     popupContent += `<h3><a href="${point.wikiLink}" target="_blank" rel="noopener noreferrer" title="Visit wiki page for ${point.name}">${point.name}</a></h3>`;
                 } else {
                     popupContent += `<h3>${point.name}</h3>`;
                 }
                 popupContent += `<p><em>Type: ${point.type || 'Unknown'}</em></p>`;
                 popupContent += `<p>${point.description || ''}</p>`;
                 marker.bindPopup(popupContent);
                 allMapMarkers.push(marker);
            } else { console.warn(`POI coordinates out of bounds for map ${selectedMap.name}: ${point.name}`, point.coords); }
        } else { console.warn(`Invalid coordinates for POI: ${point.name}`, point.coords); }
    });

    // Add marker group to map
    currentMarkerGroup.addTo(map);

    // Perform initial filtering/search (shows all markers by default, hides search results)
    updateVisibleMarkersAndSearch();
    updateToggleAllCheckboxState(); // Ensure POI toggle all is correct

    // --- NEW: Add Regions ---
    addRegionsToMap(mapId);
    populateRegionFilters(mapId); // Populate region filters
    // --- END: Add Regions ---

    // Show/hide marker toggle and search based on POIs existing
    const hasPOIs = allMapMarkers.length > 0;
    toggleMarkersBtn.style.display = hasPOIs ? 'block' : 'none';
    searchControlContainer.style.display = hasPOIs ? 'block' : 'none'; // Show search bar if POIs exist

    // Show/hide measure button based on scale info
    const hasValidScale = typeof selectedMap.scalePixels === 'number' && selectedMap.scalePixels > 0 &&
                          typeof selectedMap.scaleKilometers === 'number' && selectedMap.scaleKilometers > 0;
    measureToolBtn.style.display = hasValidScale ? 'block' : 'none';

    // --- NEW: Show/hide regions button based on regions existing ---
    const hasRegions = selectedMap && selectedMap.regions && Array.isArray(selectedMap.regions) && selectedMap.regions.length > 0;
    toggleRegionsBtn.style.display = hasRegions ? 'block' : 'none';
    // --- END: Show/hide regions button ---

    toggleMarkersBtn.classList.toggle('markers-hidden', !markersVisible); // Set initial state for marker toggle

    // map.fitBounds(currentBounds); // Moved to finishLoading function

    // Update Map Blurb
    if (selectedMap.blurb) {
        mapBlurbElement.innerHTML = selectedMap.blurb;
        mapBlurbElement.classList.add('visible');
    } else {
        mapBlurbElement.innerHTML = '';
        mapBlurbElement.classList.remove('visible');
    }

    // Update Sidebar Active State
    document.querySelectorAll('#map-list .map-item, #map-list .folder-header').forEach(item => item.classList.remove('active'));
    const activeMapItem = document.querySelector(`#map-list .map-item[data-map-id="${mapId}"]`);
    const activeFolderHeader = document.querySelector(`#map-list .folder-header[data-map-id="${mapId}"]`);
    if (activeMapItem) {
        activeMapItem.classList.add('active');
        let parent = activeMapItem.closest('.nested-list');
        while (parent) {
            const folderLi = parent.closest('.folder');
            if (folderLi && folderLi.classList.contains('closed')) { folderLi.classList.remove('closed'); }
            parent = folderLi?.parentElement.closest('.nested-list');
        }
    } else if (activeFolderHeader) {
        activeFolderHeader.classList.add('active');
         const folderLi = activeFolderHeader.closest('.folder');
         if (folderLi && folderLi.classList.contains('closed')) { folderLi.classList.remove('closed'); }
    }

    currentlyLoadedMapId = mapId;
    if (updateHash) {
        const newHash = generateHash(mapId, currentSidebarState);
        console.log("Updating hash from loadMap:", newHash);
        // Use pushState here for new map loads to allow back/forward
        history.pushState({ mapId: mapId, sidebarState: currentSidebarState }, selectedMap.name, newHash);
    }
    console.log(`Finished setting up map load for: ${selectedMap.name}`); // Note: Actual finish is async
}


// --- Additional JavaScript for Region Toggle Logic ---

// --- Region variables ---
// let currentRegionGroup = null; // Defined globally earlier
// let regionsVisible = false; // Defined globally earlier
// let regionFiltersPanelVisible = false; // Defined globally earlier

// --- Region DOM Elements ---
const toggleRegionsBtn = document.getElementById('toggle-regions-btn');
const regionFilterContainer = document.getElementById('region-filter-container');
const regionToggleAllCheckbox = document.getElementById('region-toggle-all');

// --- Toggle regions button click handler ---
if (toggleRegionsBtn) {
    toggleRegionsBtn.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent map click
        regionsVisible = !regionsVisible;
        toggleRegionsBtn.title = regionsVisible ? "Hide Regions" : "Show Regions";
        toggleRegionsBtn.classList.toggle('active', regionsVisible);

        // Toggle filter panel visibility along with the main toggle
        if (regionsVisible && !regionFiltersPanelVisible) {
            toggleRegionFilterPanel(); // Show panel if turning regions on
        } else if (!regionsVisible && regionFiltersPanelVisible) {
            toggleRegionFilterPanel(); // Hide panel if turning regions off
        }

        updateVisibleRegions(); // Apply visibility changes
    });
}

// --- Toggle region filter panel visibility ---
function toggleRegionFilterPanel() {
    regionFiltersPanelVisible = !regionFiltersPanelVisible;
    if (regionFilterContainer) {
        regionFilterContainer.classList.toggle('visible', regionFiltersPanelVisible);
    }
    // Note: We don't toggle the main button's active state here,
    // that's tied to whether regions *are* visible, not just the panel.
}

// --- Update region visibility based on main toggle and filters ---
function updateVisibleRegions() {
    if (!currentRegionGroup) return;

    // Get the currently checked region type filters
    const typeFilters = regionFilterContainer ? regionFilterContainer.querySelectorAll('.region-type-filter:checked') : [];
    const typeFilterValues = Array.from(typeFilters).map(cb => cb.value);
    const allTypesChecked = regionToggleAllCheckbox ? regionToggleAllCheckbox.checked : true;

    currentRegionGroup.eachLayer(layer => {
        const region = layer.regionData;
        if (!region) return;

        // Determine if the region's type matches the selected filters
        // A region matches if 'Show All' is checked OR its type is in the checked list
        const typeMatch = allTypesChecked || typeFilterValues.includes(region.type);

        // Set visibility based on *both* the main toggle AND the type filter match
        if (regionsVisible && typeMatch) {
            layer.setStyle({
                opacity: 1, // Make border visible
                fillOpacity: region.fillOpacity || 0.2 // Use defined fill opacity
            });
            layer.bringToBack(); // Ensure regions stay behind markers
        } else {
            layer.setStyle({
                opacity: 0, // Hide border
                fillOpacity: 0 // Hide fill
            });
        }
    });
}

// --- Region "Toggle All" checkbox logic ---
if (regionToggleAllCheckbox) {
    regionToggleAllCheckbox.addEventListener('change', () => {
        const isChecked = regionToggleAllCheckbox.checked;
        if (regionFilterContainer) {
            regionFilterContainer.querySelectorAll('.region-type-filter').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
        }
        regionToggleAllCheckbox.indeterminate = false; // Reset indeterminate state
        updateVisibleRegions(); // Trigger update based on new filter state
    });
}

// --- Helper Function to Update the Region "Toggle All" Checkbox State ---
// (Call this after populating filters or when individual filters change)
function updateRegionToggleAllCheckboxState() {
    if (!regionFilterContainer || !regionToggleAllCheckbox) return;

    const allSpecificFilters = regionFilterContainer.querySelectorAll('.region-type-filter');
    const checkedSpecificFilters = regionFilterContainer.querySelectorAll('.region-type-filter:checked');

    if (allSpecificFilters.length === 0) {
        regionToggleAllCheckbox.checked = true;
        regionToggleAllCheckbox.indeterminate = false;
    } else if (checkedSpecificFilters.length === 0) {
        regionToggleAllCheckbox.checked = false;
        regionToggleAllCheckbox.indeterminate = false;
    } else if (checkedSpecificFilters.length === allSpecificFilters.length) {
        regionToggleAllCheckbox.checked = true;
        regionToggleAllCheckbox.indeterminate = false;
    } else {
        // Partially checked
        regionToggleAllCheckbox.checked = false; // Or true, depending on preference
        regionToggleAllCheckbox.indeterminate = true;
    }
}


// --- Prevent map click when clicking inside the region filter panel ---
if (regionFilterContainer) {
    regionFilterContainer.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent map click listener from firing
    });
}

// --- Modify the map click handler to close the region filter panel ---
map.on('click', function(e) {
    // Only log if not in measurement mode
    if (!isMeasuring && currentBounds) {
        console.log(`Map clicked at: [${Math.round(e.latlng.lat)}, ${Math.round(e.latlng.lng)}] (Y, X from bottom-left)`);
    }

    // Hide POI filter panel if clicking outside
    if (filtersPanelVisible && poiFilterContainer && !poiFilterContainer.contains(e.originalEvent.target) && e.originalEvent.target !== toggleFiltersBtn && !toggleFiltersBtn.contains(e.originalEvent.target)) {
         toggleFilterPanel();
    }

    // Hide search results if clicking outside
    if (searchResultsContainer && searchResultsContainer.style.display === 'block' && !searchResultsContainer.contains(e.originalEvent.target) && e.originalEvent.target !== poiSearchInput) {
        searchResultsContainer.style.display = 'none';
    }

    // --- NEW: Hide region filter panel if clicking outside ---
    if (regionFiltersPanelVisible && regionFilterContainer && !regionFilterContainer.contains(e.originalEvent.target) && e.originalEvent.target !== toggleRegionsBtn && !toggleRegionsBtn.contains(e.originalEvent.target)) {
        toggleRegionFilterPanel();
    }
    // --- END: Hide region filter panel ---

    // Measurement logic is handled in its own listener now (handleMeasurementClick)
});

// --- Modify populateRegionFilters to update toggle all state ---
function populateRegionFilters(mapId) {
    // Clear existing filters except toggle-all
    const existingFilters = regionFilterContainer ? regionFilterContainer.querySelectorAll('.filter-item:not(:first-child)') : [];
    existingFilters.forEach(el => el.remove());

    const selectedMap = findMapRecursive(mapData, mapId);
    const hasRegions = selectedMap && selectedMap.regions && Array.isArray(selectedMap.regions) && selectedMap.regions.length > 0;

    if (!hasRegions || !regionFilterContainer) {
        if (toggleRegionsBtn) toggleRegionsBtn.style.display = 'none';
        if (regionFilterContainer) regionFilterContainer.classList.remove('visible');
        regionFiltersPanelVisible = false; // Ensure panel state is false
        if (toggleRegionsBtn) toggleRegionsBtn.classList.remove('active'); // Ensure button is not active
        return;
    }

    // Get unique region types
    const regionTypes = [...new Set(selectedMap.regions.map(r => r.type).filter(Boolean))].sort();

    // Add filter for each type
    regionTypes.forEach(type => {
        const filterId = `filter-region-${type.replace(/\s+/g, '-')}`;
        const div = document.createElement('div');
        div.className = 'filter-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = filterId;
        checkbox.value = type;
        checkbox.className = 'region-type-filter';
        checkbox.checked = true; // Default to checked

        checkbox.addEventListener('change', () => {
            updateVisibleRegions(); // Update map display first
            updateRegionToggleAllCheckboxState(); // Then update the master toggle appearance
        });

        const label = document.createElement('label');
        label.htmlFor = filterId;
        label.textContent = type.charAt(0).toUpperCase() + type.slice(1); // Capitalize

        div.appendChild(checkbox);
        div.appendChild(label);
        regionFilterContainer.appendChild(div);
    });

    // Show regions button if there are regions
    if (toggleRegionsBtn) toggleRegionsBtn.style.display = 'block';

    // Ensure panel is hidden initially and button is not active
    regionFilterContainer.classList.remove('visible');
    regionFiltersPanelVisible = false;
    if (toggleRegionsBtn) toggleRegionsBtn.classList.remove('active');

    // Set initial state of the "Toggle All" checkbox
    updateRegionToggleAllCheckboxState();
}

        // --- Populate Sidebar (Recursive Function) ---
        function populateSidebar(parentElement, items) {
            items.forEach(item => {
                const listItem = document.createElement('li');

                if (item.type === 'folder') {
                    listItem.classList.add('folder', 'closed');
                    const header = document.createElement('div');
                    header.classList.add('folder-header');
                    header.innerHTML = `<span class="folder-toggle-icon"></span><span>${item.name}</span>`;
                    const nestedList = document.createElement('ul');
                    nestedList.classList.add('nested-list');
                    if (item.children && item.children.length > 0) {
                        populateSidebar(nestedList, item.children);
                    }

                    header.addEventListener('click', (e) => {
                        e.stopPropagation();
                        listItem.classList.toggle('closed');
                    });

                    if (item.id) {
                        header.dataset.mapId = item.id;
                        if (item.status === 'coming-soon') {
                            header.title = `${item.name} - Coming Soon!`;
                            header.classList.add('coming-soon');
                            header.addEventListener('dblclick', (e) => {
                                e.stopPropagation();
                                alert(`The map "${item.name}" is coming soon!`);
                            });
                        } else {
                            header.title = `Click to toggle '${item.name}', double-click to load map.`;
                            header.addEventListener('dblclick', (e) => {
                                e.stopPropagation();
                                loadMap(item.id, true);
                            });
                        }
                    } else {
                         header.title = `Click to toggle '${item.name}'.`;
                    }
                    listItem.appendChild(header);
                    listItem.appendChild(nestedList);

                } else { // Regular map item or coming soon map item
                    listItem.classList.add('map-item');
                    listItem.textContent = item.name;
                    listItem.dataset.mapId = item.id;

                    if (item.status === 'coming-soon') {
                        listItem.classList.add('coming-soon');
                        listItem.textContent = `${item.name} (Soon)`;
                        listItem.title = `${item.name} - Coming Soon!`;
                        listItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            alert(`The map "${item.name}" is coming soon!`);
                        });
                    } else {
                        listItem.title = `Load map: ${item.name}`;
                        listItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            loadMap(item.id, true);
                        });
                    }
                }
                parentElement.appendChild(listItem);
            });
        }
        populateSidebar(mapListElement, mapData);

        // --- Sidebar Toggle Button Logic ---
        toggleBtn.addEventListener('click', () => {
            const newState = container.classList.contains('sidebar-collapsed') ? 'o' : 'c';
            setSidebarState(newState, true);
        });

        // --- Theme Toggle Logic ---
        function applyTheme(theme) {
            if (theme === 'dark') { bodyElement.classList.add('dark-theme'); themeToggle.checked = true; }
            else { bodyElement.classList.remove('dark-theme'); themeToggle.checked = false; }
        }
        themeToggle.addEventListener('change', () => {
            const newTheme = themeToggle.checked ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme); applyTheme(newTheme);
        });
        const savedTheme = localStorage.getItem('theme') || 'light';
        applyTheme(savedTheme);

        // --- Helper: Log Coordinates on Click (Modified) ---
        map.on('click', function(e) {
            // Only log if not in measurement mode
            if (!isMeasuring && currentBounds) {
                console.log(`Map clicked at: [${Math.round(e.latlng.lat)}, ${Math.round(e.latlng.lng)}] (Y, X from bottom-left)`);
            }
            // Hide filter panel if clicking outside of it or its button
            if (filtersPanelVisible && !poiFilterContainer.contains(e.originalEvent.target) && e.originalEvent.target !== toggleFiltersBtn && !toggleFiltersBtn.contains(e.originalEvent.target)) {
                 toggleFilterPanel();
            }
            // Hide search results if clicking outside
            if (searchResultsContainer.style.display === 'block' && !searchResultsContainer.contains(e.originalEvent.target) && e.originalEvent.target !== poiSearchInput) {
                searchResultsContainer.style.display = 'none';
            }
            // Measurement logic is handled in its own listener now
        });


        // --- Handle Hash Changes / Back/Forward Navigation ---
        window.addEventListener('beforeunload', () => {
            if (loadingProgressInterval) clearInterval(loadingProgressInterval);
        });


        // --- Marker Toggle Button Logic ---
        toggleMarkersBtn.addEventListener('click', () => {
            markersVisible = !markersVisible;
            toggleMarkersBtn.title = markersVisible ? "Hide Markers" : "Show Markers";
            toggleMarkersBtn.classList.toggle('markers-hidden', !markersVisible);
            // Re-run the filter/search logic
            updateVisibleMarkersAndSearch();
            console.log(`Markers toggled. Visible: ${markersVisible}`);
        });

        // --- NEW: Filter Panel Toggle Logic ---
        function toggleFilterPanel() {
            filtersPanelVisible = !filtersPanelVisible;
            poiFilterContainer.classList.toggle('visible', filtersPanelVisible);
            toggleFiltersBtn.classList.toggle('active', filtersPanelVisible);
            toggleFiltersBtn.title = filtersPanelVisible ? "Hide Filters" : "Show Filters";
        }
        toggleFiltersBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent map click listener from firing immediately
            toggleFilterPanel();
        });

        // --- Search Input Logic ---
        poiSearchInput.addEventListener('input', updateVisibleMarkersAndSearch);
        // Prevent map click when clicking inside search input
        poiSearchInput.addEventListener('click', (e) => e.stopPropagation());
        // Prevent map click when clicking inside search results
        searchResultsContainer.addEventListener('click', (e) => e.stopPropagation());


        // --- Filter "Toggle All" Logic (in the panel) ---
        filterToggleAllCheckbox.addEventListener('change', () => {
            const isChecked = filterToggleAllCheckbox.checked;
            poiFilterContainer.querySelectorAll('.poi-filter-checkbox:not(#filter-toggle-all)').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
            filterToggleAllCheckbox.indeterminate = false;
            updateVisibleMarkersAndSearch(); // Trigger update
        });
        // Prevent map click when clicking inside filter panel
        poiFilterContainer.addEventListener('click', (e) => e.stopPropagation());


        // --- Measurement Tool Logic ---
        function handleMeasurementClick(e) {
            if (!isMeasuring || !currentlyLoadedMapId) return;

            // --- NEW: Prevent measurement if clicking on a control ---
            if (e.originalEvent.target.closest('.leaflet-control')) {
                console.log("Measurement click ignored (on control).");
                return;
            }

            const clickPoint = e.latlng;
            const currentMapInfo = findMapRecursive(mapData, currentlyLoadedMapId);

            const scalePx = currentMapInfo?.scalePixels;
            const scaleKm = currentMapInfo?.scaleKilometers;
            const hasValidScale = typeof scalePx === 'number' && scalePx > 0 &&
                                  typeof scaleKm === 'number' && scaleKm > 0;

            // Clear previous line/end marker if starting a new measurement pair
            measurementLayerGroup.eachLayer(layer => {
                if (layer instanceof L.Polyline || (layer.options && layer.options.isEndPoint)) {
                    measurementLayerGroup.removeLayer(layer);
                }
            });

            if (!measurementStartPoint) {
                // First click
                measurementStartPoint = clickPoint;
                L.circleMarker(measurementStartPoint, {
                    radius: 5, color: 'red', fillColor: '#f03', fillOpacity: 0.8, interactive: false
                }).addTo(measurementLayerGroup)
                  .bindTooltip("Start point. Click second point.", { permanent: false, direction: 'top', className: 'measure-tooltip', offset: L.point(0, -5) })
                  .openTooltip();

            } else {
                // Second click
                const endPoint = clickPoint;
                const pixelDistance = map.distance(measurementStartPoint, endPoint);
                let distanceString = `${pixelDistance.toFixed(0)} pixels`;

                if (hasValidScale) {
                    const kmDistance = (pixelDistance / scalePx) * scaleKm;
                    distanceString = `${kmDistance.toFixed(2)} km`;
                } else {
                    console.warn(`Measurement: Scale information missing or invalid for map ${currentlyLoadedMapId}. Displaying pixels.`);
                    distanceString += " (Scale unknown)";
                }

                 L.circleMarker(endPoint, {
                    radius: 5, color: 'blue', fillColor: '#30f', fillOpacity: 0.8, interactive: false, isEndPoint: true
                }).addTo(measurementLayerGroup);

                L.polyline([measurementStartPoint, endPoint], {
                    color: 'yellow', weight: 2, dashArray: '5, 5', interactive: false
                }).addTo(measurementLayerGroup)
                  .bindTooltip(`${distanceString}`, { permanent: true, direction: 'center', className: 'measure-tooltip' })
                  .openTooltip();

                measurementStartPoint = null; // Reset for next measurement
            }
        }

        function toggleMeasurementTool() {
            isMeasuring = !isMeasuring;
            measureToolBtn.classList.toggle('active', isMeasuring);
            mapElement.classList.toggle('measuring-cursor', isMeasuring);

            if (isMeasuring) {
                measureToolBtn.title = "Deactivate Measure Tool (Click map)";
                // Add listener with higher priority to potentially intercept clicks before others
                map.on('click', handleMeasurementClick);
                measurementLayerGroup.clearLayers();
                measurementStartPoint = null;
                // --- NEW: Hide filter panel when measuring ---
                if (filtersPanelVisible) {
                    toggleFilterPanel();
                }
            } else {
                measureToolBtn.title = "Measure Distance";
                map.off('click', handleMeasurementClick);
                // Optionally clear graphics when deactivating
                // measurementLayerGroup.clearLayers();
                measurementStartPoint = null;
            }
        }

        measureToolBtn.addEventListener('click', (e) => {
             e.stopPropagation(); // Prevent map click
             toggleMeasurementTool();
        });


        // --- Initial Page Load Logic ---
        function initializeApp() {
            // Show loading indicator at start of initialization
            if (loadingIndicator) {
                loadingIndicator.style.display = 'flex';
                const progressBar = loadingIndicator.querySelector('.progress-bar');
                if (progressBar) progressBar.style.width = '0%';
            }

            const { mapId: initialMapId, sidebarState: initialSidebarState } = parseHash();
            let mapToLoadData = findMapRecursive(mapData, initialMapId);
            let mapIdToLoad = initialMapId;

            if (!mapToLoadData || mapToLoadData.status === 'coming-soon') {
                console.log("Initial hash map not loadable, finding default.");
                mapIdToLoad = findFirstLoadableIdRecursive(mapData);
                mapToLoadData = findMapRecursive(mapData, mapIdToLoad);
            }

            console.log("Initializing App. Map to Load:", mapIdToLoad, "Initial Sidebar State:", initialSidebarState);

            setSidebarState(initialSidebarState, false);

            // Hide controls initially
            toggleMarkersBtn.style.display = 'none';
            toggleFiltersBtn.style.display = 'none';
            measureToolBtn.style.display = 'none';
            searchControlContainer.style.display = 'none';
            searchResultsContainer.style.display = 'none';
            poiFilterContainer.classList.remove('visible');

            if (mapIdToLoad && mapToLoadData && mapToLoadData.status !== 'coming-soon') {
                markersVisible = true; // Default to visible
                loadMap(mapIdToLoad, false); // loadMap now handles visibility of controls
            } else {
                console.error("No loadable map data found for initialization.");
                sidebar.innerHTML = '<h2>Select Map</h2><p>No maps available.</p>'; // Keep sidebar basics
                mapBlurbElement.classList.remove('visible');
                
                // Make sure to hide loading indicator here
                if (loadingIndicator) {
                    if (loadingProgressInterval) clearInterval(loadingProgressInterval);
                    loadingIndicator.style.display = 'none';
                }
                
                history.replaceState(null, '', generateHash('', initialSidebarState));
                return; // Stop initialization here
            }

            // Ensure the history state is correct after potentially loading a default map
            const correctInitialHash = generateHash(currentlyLoadedMapId, currentSidebarState);
            console.log("Replacing initial history state with:", correctInitialHash);
            history.replaceState({ mapId: currentlyLoadedMapId, sidebarState: currentSidebarState }, mapToLoadData?.name || '', correctInitialHash);
        }

        initializeApp(); // Run initialization

    </script>

    <!-- Work in Progress Popup -->
    <div id="wip-popup">
        <p>This site is a Work in Progress</p>
        <p>Markers, Names, and Map May Not Be Acurate</p>
    </div>

</body>
</html>