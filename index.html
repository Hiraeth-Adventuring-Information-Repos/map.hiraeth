<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta property="og:description" content="Explore interactive maps, discover points of interest, and measure distances in Hiraeth!">

    <meta property="og:image" content="https://maps.hiraeth.wiki/images/hiraeth-maps-preview.png">
    <meta property="og:url" content="https://maps.hiraeth.wiki/">
    <title>HAG Interactive World Map Viewer</title>
    <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=EB+Garamond:ital,wght@0,400..800;1,400..800&display=swap" rel="stylesheet">

    <style>
        /* --- Theme Variables --- */
        :root {
            /* Light Mode Backgrounds */
            --bg-primary: #fdfaf6; /* Lighter base */
            --bg-secondary: #f4f0eb; /* Slightly darker secondary */

            /* Light Mode Text */
            --text-primary: #6b2c25; /* User's Primary Color */
            --text-secondary: #bb9b73; /* User's Default Link Color */
            --popup-text: var(--text-primary); /* Match main text */

            /* Light Mode UI Elements */
            --border-color: #dcd3c8; /* Desaturated brown */
            --highlight-bg: rgba(212, 163, 106, 0.3); /* Based on Chapter Color w/ alpha */
            --active-bg: rgba(189, 137, 77, 0.5); /* Based on Page Color w/ alpha */
            --shadow-color: rgba(107, 44, 37, 0.15); /* Shadow based on primary */
            --slider-bg: #d4a36a; /* Chapter Color */
            --slider-color: white;
            --font-family-main: 'EB Garamond', serif;

            /* Light Mode Frosted Glass */
            --glass-bg-light: rgba(253, 250, 246, 0.75); /* Based on bg-primary w/ alpha */
            --glass-border-light: rgba(160, 82, 45, 0.3); /* Based on Shelf Color w/ alpha */
        }

        body.dark-theme {
            /* Dark Mode Backgrounds */
            --bg-primary: #222034; /* Darker version of user's primary */
            --bg-secondary: #1b1830; /* Even darker */

            /* Dark Mode Text */
            --text-primary: #e8e6f2; /* Light text for contrast */
            --text-secondary: #b9b8e0; /* User's Default Link Color */
            --popup-text: var(--text-primary);

            /* Dark Mode UI Elements */
            --border-color: #524f6c; /* User's Primary Color */
            --highlight-bg: rgba(237, 174, 73, 0.3); /* Based on Chapter Color w/ alpha */
            --active-bg: rgba(66, 159, 227, 0.4); /* Based on Page Color w/ alpha */
            --shadow-color: rgba(0, 0, 0, 0.3); /* Darker shadow */
            --slider-bg: #555;
            --slider-color: #429fe3; /* User's Page Color */
            /* font-family is inherited */

            /* Dark Mode Frosted Glass */
            --glass-bg-dark: rgba(34, 33, 50, 0.7); /* Based on user's primary w/ alpha */
            --glass-border-dark: rgba(245, 67, 91, 0.3); /* Based on Shelf Color w/ alpha */
        }

        /* --- Keyframes for WIP Popup Gradient Pulse --- */
        @keyframes pulseGradient {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* --- /* --- Keyframes for Twinkling Stars --- */

        /* --- Base Dark Theme Map Style --- */
        body.dark-theme #map {
            /* Set the background image */
            background-image: url('images/night-sky.webp');

            /* Ensure it tiles */
            background-repeat: repeat;

            /* Fallback color if image fails */
            background-color: #050510;

            /* These might no longer be strictly necessary, but often harmless */
            position: relative;
            overflow: hidden;
        }


        /* --- Keyframes for Moving Clouds --- */
        @keyframes moveClouds {
            from { background-position-x: 0; }
            to { background-position-x: 1000px; } /* Adjust value based on image width & desired speed */
        }

        #map-blurb a,
        #map-blurb a:link,
        #map-blurb a:visited {
            color: inherit; /* Inherit color from blurb text */
            text-decoration: underline; /* Standard link underline */
            transition: color 0.2s ease;
        }

        #map-blurb a:hover,
        #map-blurb a:active {
            color: var(--text-secondary); /* Use secondary color on hover */
            text-decoration: none; /* Optional: remove underline on hover */
        }

        /* Ensure dark theme hover looks okay (it should inherit fine, but explicit rule is safe) */
        body.dark-theme #map-blurb a:hover,
        body.dark-theme #map-blurb a:active {
             color: var(--text-secondary);
        }


        /* Apply Variables & Base Styles */
        html, body {
            height: 100%; margin: 0; padding: 0; font-family: var(--font-family-main);
            background-color: var(--bg-primary); color: var(--text-primary);
            overflow: hidden; transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container { display: flex; height: 100%; width: 100%; }

        /* Sidebar styling */
        #sidebar {
            background-color: var(--glass-bg-light); backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px); border-right: 1px solid var(--glass-border-light);
            width: 250px; padding: 15px; box-shadow: 2px 0 15px var(--shadow-color);
            overflow-y: auto; flex-shrink: 0;
            transition: width 0.3s ease, padding 0.3s ease, background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
            box-sizing: border-box; position: relative; display: flex; flex-direction: column;
        }
        body.dark-theme #sidebar { background-color: var(--glass-bg-dark); border-right-color: var(--glass-border-dark); }
        #sidebar h2 {
            margin-top: 0; margin-bottom: 15px; font-size: 1.5rem; font-weight: 600;
            border-bottom: 1px solid var(--glass-border-light); padding-bottom: 10px;
            white-space: nowrap; color: var(--text-primary); flex-shrink: 0;
        }
        body.dark-theme #sidebar h2 { border-bottom-color: var(--glass-border-dark); }

        /* Sidebar List Styling */
        #map-list { list-style: none; padding: 0; margin: 0; overflow-y: auto; flex-grow: 1; }
        #map-list li { border-radius: 4px; margin-bottom: 3px; overflow: hidden; }
        .map-item {
            padding: 10px 10px 10px 15px; cursor: pointer; transition: background-color 0.2s ease;
            white-space: nowrap; text-overflow: ellipsis; font-size: 1.1rem;
            background-color: transparent; display: block;
        }
        .map-item:hover { background-color: var(--highlight-bg); }
        .map-item.active { background-color: var(--active-bg); font-weight: 600; }
        .folder-header {
            padding: 10px 5px; cursor: pointer; font-weight: bold; display: flex;
            align-items: center; transition: background-color 0.2s ease; background-color: transparent;
            user-select: none; /* Prevent text selection on double click */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        .folder-header:hover { background-color: var(--highlight-bg); }
        /* Style active folder header */
        .folder-header.active {
             background-color: var(--active-bg);
             font-weight: 600; /* Match map item active style */
        }
        .folder-toggle-icon { display: inline-block; width: 1.2em; text-align: center; margin-right: 5px; transition: transform 0.2s ease-in-out; }
        .folder.closed > .folder-header .folder-toggle-icon::before { content: '‚ñ∏'; }
        .folder:not(.closed) > .folder-header .folder-toggle-icon::before { content: '‚ñæ'; }
        .nested-list { list-style: none; padding: 0; margin: 0 0 0 15px; max-height: 1000px; overflow: hidden; transition: max-height 0.3s ease-out; }
        .folder.closed > .nested-list { max-height: 0; }

        /* --- Coming Soon Sidebar Item Styling --- */
        .map-item.coming-soon, .folder-header.coming-soon {
            color: var(--text-secondary); /* Use secondary text color */
            font-style: italic;
            cursor: not-allowed; /* Indicate non-interactive */
            opacity: 0.7;
        }
        /* Optional: Prevent hover effect or use a different one */
        .map-item.coming-soon:hover, .folder-header.coming-soon:hover {
            background-color: transparent; /* No highlight on hover */
        }
        /* Ensure dark theme also looks disabled */
        body.dark-theme .map-item.coming-soon,
        body.dark-theme .folder-header.coming-soon {
             color: var(--text-secondary); /* Already uses variable */
        }
        body.dark-theme .map-item.coming-soon:hover,
        body.dark-theme .folder-header.coming-soon:hover {
             background-color: transparent;
        }

        /* Map container */
        #map-container { flex-grow: 1; height: 100%; position: relative; overflow: hidden; }
        #map {
            height: 100%; width: 100%;
            background-color: var(--bg-secondary);
            transition: background-color 0.3s ease;
            position: relative; /* Needed for pseudo-elements */
            overflow: hidden; /* Needed for pseudo-elements */
        }
        /* --- NEW: Cursor style for measurement tool --- */
        #map.measuring-cursor {
            cursor: crosshair;
        }
        body.dark-theme #map {
            /* background-image: url('images/night-sky.png'); */ /* Base static stars - REMOVED for CSS stars */
            background-repeat: repeat;
            background-color: #050510;
        }

        /* --- Moving Clouds Effect (Light Mode Only) --- */
        body:not(.dark-theme) #map::before,
        body:not(.dark-theme) #map::after {
            background-image: url('images/clouds.webp');
            background-repeat: repeat-x;
            background-size: auto 300px;
            background-color: #87CEEB;
            width: 100%;
            animation-name: moveClouds;
            animation-timing-function: linear;
            animation-iteration-count: infinite;
            transition: opacity 0.5s ease-in-out;
            z-index: 0;
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            pointer-events: none;
        }
        body:not(.dark-theme) #map::before {
            background-position: 0 5%; opacity: 0.45; animation-duration: 75s;
        }
        body:not(.dark-theme) #map::after {
            background-position: 0 20%; opacity: 0.3; animation-duration: 110s; animation-delay: -10s;
        }
        
        body.embedded-view #search-control-container {
            bottom: 10px; /* Adjust from 40px when bottom bar is hidden */
        }
        /* --- Enhanced Dark Theme Stars --- */
        body.dark-theme #map::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            background-image:
                radial-gradient(circle, rgba(255, 255, 255, 0.9) 1px, transparent 1.5px),
                radial-gradient(circle, rgba(255, 255, 255, 0.8) 0.5px, transparent 1px);
            background-size:
                75px 75px,
                50px 50px;
            background-position:
                0 0,
                25px 25px;
            animation: twinkleEnhanced 8s infinite;
            opacity: 1; /* Ensure visible */
        }

        body.dark-theme #map::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            pointer-events: none;
            background-image:
                radial-gradient(circle, rgba(255, 255, 255, 0.8) 0.7px, transparent 1px),
                radial-gradient(circle, rgba(255, 255, 255, 0.7) 0.3px, transparent 0.6px);
            background-size:
                60px 60px,
                35px 35px;
            background-position:
                15px 15px,
                40px 40px;
            animation: twinkleSubtle 5s infinite;
            animation-delay: 2s;
            opacity: 1; /* Ensure visible */
        }

        /* Third star layer for more variety */
        body.dark-theme #map > div:first-child::before { /* Target inner Leaflet container */
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0; /* Keep behind map elements */
            pointer-events: none;
            background-image:
                radial-gradient(circle, rgba(220, 240, 255, 0.9) 0.2px, transparent 0.5px);
            background-size: 30px 30px;
            background-position: 5px 10px;
            animation: twinkleEnhanced 6s infinite;
            animation-delay: 1s;
            opacity: 1; /* Ensure visible */
        }
        /* --- End Theme Effects --- */


        /* Map Blurb */
        #map-blurb {
            position: absolute;
            top: 50px; 
            right: 10px;
            z-index: 999;
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            color: var(--popup-text); /* Use popup text color */
            border-radius: 6px;
            padding: 8px 12px;
            max-width: 250px; /* Limit width */
            font-size: 0.9rem;
            box-shadow: 0 1px 5px var(--shadow-color);
            opacity: 0; /* Hidden by default */
            pointer-events: none; /* Don't block map clicks when hidden */
            transition: opacity 0.3s ease, transform 0.3s ease; /* Add transform to transition */
            transform: scale(0.95); /* Start slightly smaller */
            transform-origin: top right; /* Animate from the corner */
        }
        #map-blurb.visible {
            opacity: 1;
            transform: scale(1); /* Scale to full size when visible */
            pointer-events: auto;
        }
        body.dark-theme #map-blurb {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
        }

        /* Popups */
        .leaflet-popup-content-wrapper { background: var(--glass-bg-light); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); color: var(--popup-text); border-radius: 8px; box-shadow: 0 3px 14px var(--shadow-color); border: 1px solid var(--glass-border-light); }
        .leaflet-popup-tip { background: transparent; box-shadow: none; }
        body.dark-theme .leaflet-popup-content-wrapper { background: var(--glass-bg-dark); border-color: var(--glass-border-dark); }
        .leaflet-popup-content { margin: 15px; font-size: 1.1rem; line-height: 1.5; }
        .leaflet-popup-content h3 { margin-top: 0; margin-bottom: 10px; font-size: 1.3rem; font-weight: 600; color: var(--popup-text); }
        .dark-theme .leaflet-popup-close-button { color: var(--text-secondary); }
        .dark-theme .leaflet-popup-close-button:hover { color: var(--text-primary); }

        /* --- Popup Link Styling --- */
        .leaflet-popup-content h3 a,
        .leaflet-popup-content h3 a:link,
        .leaflet-popup-content h3 a:visited {
            color: inherit; /* Inherit color from the h3 (uses --popup-text) */
            text-decoration: none; /* Remove default underline */
            border-bottom: 1px dotted; /* Subtle underline */
            transition: color 0.2s ease, border-bottom-color 0.2s ease;
        }
        .leaflet-popup-content h3 a:hover,
        .leaflet-popup-content h3 a:active {
            color: var(--text-secondary); /* Use secondary color on hover */
            border-bottom-style: solid; /* Make underline solid on hover */
        }
        /* Ensure dark theme hover looks okay */
        body.dark-theme .leaflet-popup-content h3 a:hover,
        body.dark-theme .leaflet-popup-content h3 a:active {
             color: var(--text-secondary); /* Already uses variable */
        }
        /* Buttons */
        #toggle-sidebar-btn {
            position: absolute;
            bottom: 43px;
            left: 15px;
            /* Change z-index from 1000 to 1002 (or higher than the popup) */
            z-index: 1002;
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            color: var(--text-primary);
            border-radius: 4px;
            padding: 5px 8px;
            cursor: pointer;
            font-size: 1.2rem;
            line-height: 1;
            box-shadow: 0 1px 5px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        #toggle-sidebar-btn:hover { background-color: rgba(255, 255, 255, 0.75); }
        body.dark-theme #toggle-sidebar-btn { background-color: var(--glass-bg-dark); border-color: var(--glass-border-dark); }
        body.dark-theme #toggle-sidebar-btn:hover { background-color: rgba(70, 70, 70, 0.75); }
        .container.sidebar-collapsed #sidebar { width: 0; padding-left: 0; padding-right: 0; overflow: hidden; border-right: none; }

        /* Default Leaflet Zoom Control Styling */
        .leaflet-control-zoom a { background-color: var(--glass-bg-light); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); border: 1px solid var(--glass-border-light); color: var(--text-primary); border-bottom: 1px solid var(--glass-border-light); transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease; }
        .leaflet-control-zoom-in { border-bottom: 1px solid var(--glass-border-light); border-radius: 4px 4px 0 0; }
        .leaflet-control-zoom-out { border-radius: 0 0 4px 4px; border: 1px solid var(--glass-border-light); border-top: none; }
        .leaflet-control-zoom a:hover { background-color: rgba(255, 255, 255, 0.75); color: #000; }
        body.dark-theme .leaflet-control-zoom a { background-color: var(--glass-bg-dark); border-color: var(--glass-border-dark); color: var(--text-primary); }
        body.dark-theme .leaflet-control-zoom-in { border-bottom: 1px solid var(--glass-border-dark); }
        body.dark-theme .leaflet-control-zoom-out { border: 1px solid var(--glass-border-dark); border-top: none; }
        body.dark-theme .leaflet-control-zoom a:hover { background-color: rgba(70, 70, 70, 0.75); color: #fff; }

        /* --- Map Control Buttons Common Style --- */
        .map-control-button {
            position: absolute;
            left: 12px; /* Adjusted slightly for default zoom control */
            z-index: 1000;
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            color: var(--text-primary);
            border-radius: 4px;
            padding: 0; /* Remove padding for icon */
            width: 32px; /* Match zoom control width */
            height: 30px; /* Match zoom control height */
            cursor: pointer;
            font-size: 1.4rem; /* Adjust icon size */
            line-height: 30px; /* Center icon vertically */
            text-align: center;
            box-shadow: 0 1px 5px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, opacity 0.2s ease;
            display: none; /* Hide by default, shown via JS */
        }
        .map-control-button:hover {
            background-color: rgba(255, 255, 255, 0.75);
        }
        
        /* --- CORRECTED: Blurb Toggle Button --- */
        #toggle-blurb-btn {
            top: 10px;
            right: 10px; /* Position in the top right corner */
            left: auto; /* IMPORTANT: Override the 'left' from .map-control-button */
            z-index: 1000; /* Ensure it's above the map */
            display: none; /* Hide by default, JS will show it */
        }
        #toggle-blurb-btn.active {
             background-color: var(--active-bg);
        }
        /* --- END CORRECTION --- */
        
        body.dark-theme .map-control-button {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
            color: var(--text-primary);
        }
        body.dark-theme .map-control-button:hover {
            background-color: rgba(70, 70, 70, 0.75);
        }
        /* --- END: Map Control Buttons Common Style --- */

        /* Marker Toggle Button (Now controls Markers & Regions) */
        #toggle-markers-btn {
            top: 78px; /* Position below zoom controls */
            /* Inherits from .map-control-button */
        }
        #toggle-markers-btn::before {
            content: 'üìç';
            opacity: 1; /* Default: visible */
            transition: opacity 0.2s ease;
        }
        #toggle-markers-btn.markers-hidden::before {
            opacity: 0.5; /* Dimmed when hidden */
        }

        /* --- Filter Toggle Button (Now uses Map Icon) --- */
        #toggle-filters-btn {
            top: 115px; /* Position below marker toggle */
            /* Inherits from .map-control-button */
            /* Icon is now applied via JS-injected style */
        }
        /* #toggle-filters-btn::before { ... } - Removed, handled by JS */
        #toggle-filters-btn.active {
             background-color: var(--active-bg); /* Use active color */
        }
        body.dark-theme #toggle-filters-btn.active {
             background-color: var(--active-bg); /* Use active color */
        }
        /* --- END: Filter Toggle Button --- */

        /* --- Filter Panel Styling (Now includes POI and Region filters) --- */
        #poi-filter-container {
            position: absolute;
            top: 110px; /* Align near the filter button */
            left: 50px; /* Position to the right of the button */
            z-index: 999; /* Below controls, above map */
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            color: var(--text-primary);
            border-radius: 6px;
            padding: 10px 15px;
            width: 180px; /* Adjust width as needed */
            max-height: calc(100vh - 200px); /* Limit height */
            overflow-y: auto;
            box-shadow: 0 1px 5px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease, color 0.3s ease, opacity 0.3s ease, transform 0.3s ease;
            opacity: 0;
            transform: scale(0.95);
            transform-origin: top left;
            pointer-events: none; /* Hidden by default */
        }
        #poi-filter-container.visible {
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
        }
        body.dark-theme #poi-filter-container {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
        }
        #poi-filter-container h3 { /* Style for section headers */
            margin-top: 10px; /* Add space above subsequent headers */
            margin-bottom: 8px;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-secondary);
            padding-bottom: 5px;
            border-bottom: 1px solid var(--glass-border-light);
        }
        #poi-filter-container h3:first-of-type {
             margin-top: 0; /* No top margin for the very first header */
        }
        body.dark-theme #poi-filter-container h3 {
            border-bottom-color: var(--glass-border-dark);
        }
        .filter-item {
            display: block;
            margin-bottom: 4px;
            font-size: 0.95rem;
            cursor: pointer;
            user-select: none;
        }
        .filter-item input[type="checkbox"] {
            margin-right: 8px;
            vertical-align: middle;
            cursor: pointer;
        }
        .filter-item label {
            vertical-align: middle;
            cursor: pointer;
        }
        /* --- END: Filter Panel Styling --- */

        /* Measure Tool Button */
        #measure-tool-btn {
            top: 152px; /* Position below filter toggle */
            /* Inherits from .map-control-button */
        }
        #measure-tool-btn::before {
            content: 'üìè'; /* Ruler emoji */
            opacity: 0.6; /* Default: slightly dimmed */
        }
        #measure-tool-btn.active::before {
            opacity: 1; /* Full opacity when active */
        }
        #measure-tool-btn.active {
             background-color: var(--active-bg); /* Use active color */
        }
        body.dark-theme #measure-tool-btn.active {
             background-color: var(--active-bg); /* Use active color */
        }

        /* Sound Toggle Button */
        #toggle-sound-btn {
            top: 189px; /* Position below measure tool */
            /* Inherits from .map-control-button */
            display: block; /* Make visible by default */
        }

        /* --- Search Control Container (Bottom Center) --- */
        #search-control-container {
            position: absolute;
            bottom: 40px; /* Above bottom link bar */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            border-radius: 6px;
            padding: 5px 10px;
            box-shadow: 0 -1px 5px var(--shadow-color);
            transition: background-color 0.3s ease, border-color 0.3s ease, opacity 0.3s ease;
            display: none; /* Hidden by default, shown via JS */
        }
        body.dark-theme #search-control-container {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
        }
        #poi-search-input {
            width: 250px; /* Adjust width */
            padding: 6px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
            box-sizing: border-box;
            font-family: inherit;
            font-size: 0.95rem;
            outline: none;
        }
        /* --- END: Search Control Container --- */

        /* --- Search Results Container --- */
        #search-results-container {
            position: absolute;
            bottom: 80px; /* Above search bar */
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001; /* Above search bar, potentially above other controls */
            background-color: var(--glass-bg-light);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border-light);
            border-radius: 6px;
            padding: 5px;
            box-shadow: 0 -1px 5px var(--shadow-color);
            width: 270px; /* Match search bar width roughly */
            max-height: 150px; /* Limit height */
            overflow-y: auto;
            display: none; /* Hidden by default */
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }
        body.dark-theme #search-results-container {
            background-color: var(--glass-bg-dark);
            border-color: var(--glass-border-dark);
        }
        .search-result-item {
            padding: 6px 10px;
            font-size: 0.9rem;
            color: var(--text-primary);
            cursor: pointer;
            border-radius: 4px;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .search-result-item:last-child {
            margin-bottom: 0;
        }
        .search-result-item:hover {
            background-color: var(--highlight-bg);
        }
        .search-result-item strong { /* Optional: Highlight matching part */
            font-weight: bold;
            color: var(--text-secondary); /* Or another highlight color */
        }
        /* --- END: Search Results Container --- */


        /* Theme Toggle */
        .theme-switch-wrapper { display: flex; align-items: center; margin-top: auto; padding-top: 15px; border-top: 1px solid var(--glass-border-light); flex-shrink: 0; white-space: nowrap; overflow: hidden; }
        body.dark-theme .theme-switch-wrapper { border-top-color: var(--glass-border-dark); }
        .theme-switch-wrapper span { margin-left: 10px; font-size: 1rem; color: var(--text-secondary); }
        .theme-switch { position: relative; display: inline-block; width: 50px; height: 24px; flex-shrink: 0; }
        .theme-switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--slider-bg); transition: .4s; }
        .slider:before { position: absolute; content: ""; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white; transition: .4s; }
        input:checked + .slider { background-color: #2196F3; } /* Keep blue for dark mode toggle */
        body.dark-theme input:checked + .slider { background-color: var(--slider-color); } /* Use theme variable for dark mode */
        body.dark-theme .slider { background-color: var(--slider-bg); } /* Use theme variable for dark mode */
        input:checked + .slider:before { transform: translateX(26px); }
        .slider.round { border-radius: 24px; }
        .slider.round:before { border-radius: 50%; }

        /* Bottom Link Bar */
        #bottom-link-bar { position: absolute; bottom: 0; left: 0; width: 100%; height: 28px; background-color: var(--glass-bg-light); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-top: 1px solid var(--glass-border-light); box-sizing: border-box; display: flex; align-items: center; justify-content: center; padding: 0 15px; z-index: 1000; transition: background-color 0.3s ease, border-color 0.3s ease; }
        #bottom-link-bar a { color: var(--text-secondary); text-decoration: none; font-size: 0.85rem; margin: 0 8px; transition: color 0.2s ease; }
        #bottom-link-bar a:hover { color: var(--text-primary); text-decoration: underline; }
        body.dark-theme #bottom-link-bar { background-color: var(--glass-bg-dark); border-top-color: var(--glass-border-dark); }
        body.dark-theme #bottom-link-bar a { color: var(--text-secondary); }
        body.dark-theme #bottom-link-bar a:hover { color: var(--text-primary); }

        /* WIP Popup */
        #wip-popup {
            position: fixed;
            bottom: 43px;
            right: 15px;
            /* Lower z-index to be behind the search bar (z-index: 1000) */
            z-index: 999;
            padding: 8px 12px;
            border: 1px solid var(--glass-border-light);
            border-radius: 6px;
            box-shadow: 0 2px 6px var(--shadow-color);
            transition: border-color 0.3s ease, color 0.3s ease;
            background: linear-gradient(to right, #ff7e7e, #ffae70, #fff078, #ffae70, #ff7e7e);
            background-size: 300% 100%;
            animation: pulseGradient 30s ease-in-out infinite;
        }

        #wip-popup p { margin: 0; font-size: 0.8rem; color: var(--text-primary); text-align: center; white-space: nowrap; text-shadow: 0px 0px 3px rgba(0, 0, 0, 0.4); }
        body.dark-theme #wip-popup { border-color: var(--glass-border-dark); }
        body.dark-theme #wip-popup p { text-shadow: 0px 0px 3px rgba(0, 0, 0, 0.6); }

        /* --- Measurement Tooltip --- */
        .leaflet-tooltip.measure-tooltip {
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            box-shadow: none;
            font-size: 0.9rem;
            padding: 3px 6px;
        }

        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1001;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 1.2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 250px;
        }

        .loading-text {
            margin: 10px 0;
        }

        .progress-container {
            width: 100%;
            height: 10px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            width: 0%; /* Starts at 0% */
            background-color: #2196F3;
            border-radius: 5px;
            transition: width 0.3s ease;
        }

        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3); /* Light grey border */
            border-left-color: #fff; /* White for the spinning part */
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            margin-right: 10px; /* Space between spinner and text */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @media (max-width: 768px) {
          /* Styles specifically for screens 768px wide or less */

          #sidebar {
            width: 200px; /* Example: Make sidebar narrower */
            /* Or you might hide it completely and use the toggle */
          }
         .leaflet-control-zoom {
            display: none;
         }

          .map-control-button {
            /* Example: Make map buttons larger for touch */
            width: 40px;
            height: 40px;
            font-size: 1.6rem;
            line-height: 40px; /* Adjust line-height too */
          }

          /* Adjust button positions if needed */
          #toggle-markers-btn { top: 70px; }
          #toggle-filters-btn { top: 118px; }
          #measure-tool-btn { top: 166px; }
          #toggle-sound-btn { top: 214px; }

          #poi-search-input {
            width: 180px; /* Example: Adjust search input width */
          }
          #search-control-container {
               /* Maybe adjust padding or position */
               padding: 5px;
           }

          #map-blurb {
            max-width: 150px;
            font-size: 0.8rem;
            padding: 6px 10px;
          }

          .leaflet-popup-content {
               font-size: 1rem; /* Slightly smaller popup text */
           }

          /* Add other adjustments as needed: font sizes, padding, margins */
        }

        @media (max-width: 480px) {
            /* Styles for even smaller screens (optional) */
            #sidebar {
               /* Maybe hide it by default on very small screens */
               /* width: 0; */
               /* position: fixed; /* Example: make it an overlay */
               /* height: 100%; */
               /* left: -200px; /* Start off-screen */
               /* transition: left 0.3s ease; */
            }
            /* Add styles to show/hide overlay sidebar */

            #bottom-link-bar {
               font-size: 0.75rem; /* Smaller text on bottom bar */
               height: auto; /* Allow wrapping */
               padding: 5px;
               flex-wrap: wrap; /* Allow links to wrap */
               justify-content: space-around;
            }
             #bottom-link-bar a {
                 margin: 2px 5px;
             }
        }
        @media (max-width: 600px) { /* Adjust breakpoint as needed */
            #wip-popup {
                 /* Center horizontally */
                 left: 50%;
                 transform: translateX(-50%);
                 /* Remove right positioning */
                 right: auto;
                 /* Position it above the search bar */
                 /* (search bar is bottom: 40px, estimate its height + spacing) */
                 bottom: 85px; /* Adjust this value as needed */
                 /* Ensure it doesn't overlap the toggle button */
                 max-width: calc(100% - 30px); /* Prevent full width */
            }
            #wip-popup.fade-out {
                 opacity: 0;
                 transform: translateY(15px); /* Optional slide down */
                 pointer-events: none; /* Prevent interaction after fading */
            }
        }
        
</style>
</head>
<body>
    <div class="container">
        <div id="sidebar">
            <h2>Select Map</h2>
            <ul id="map-list">
                </ul>
            <div class="theme-switch-wrapper">
                <label class="theme-switch" for="theme-checkbox">
                    <input type="checkbox" id="theme-checkbox" />
                    <div class="slider round"></div>
                </label>
                <span>Dark Mode</span>
            </div>
        </div>
        <div id="map-container">
            <button id="toggle-sidebar-btn" title="Collapse Sidebar">&laquo;</button>
            <div id="map"></div>

            <div id="map-blurb"></div>
            <button id="toggle-blurb-btn" class="map-control-button leaflet-control" title="Toggle Map Info">‚ÑπÔ∏è</button>

            <div id="loading-indicator" style="display: none;">
                <div class="spinner"></div>
                <div class="loading-text">Loading Map Data...</div>
                <div class="progress-container">
                    <div class="progress-bar"></div>
                </div>
            </div>

            <button id="toggle-markers-btn" title="Toggle Markers" class="map-control-button leaflet-control"></button>
            <button id="toggle-filters-btn" title="Toggle Filters" class="map-control-button leaflet-control"></button>
            <button id="measure-tool-btn" title="Measure Distance" class="map-control-button leaflet-control"></button>
            <button id="toggle-sound-btn" title="Toggle Sound" class="map-control-button leaflet-control">
                <span id="sound-icon">üîá</span> </button>

            <div id="poi-filter-container" class="leaflet-control">
                 <h3>Filter by Type:</h3>
                 <div class="filter-item">
                     <input type="checkbox" id="filter-toggle-all" checked>
                     <label for="filter-toggle-all">Show All / Hide All</label>
                 </div>
                 </div>
            <div id="search-control-container" class="leaflet-control">
                <input type="search" id="poi-search-input" placeholder="Search locations...">
            </div>
            <div id="search-results-container" class="leaflet-control">
                </div>
            <div id="bottom-link-bar">
                <a href="https://jsnj.link/maps-to-wiki" target="_blank">Wiki</a> |
                <a href="https://jsnj.link/maps-blog-post" target="_blank">Blog</a> |
                <a href="about.html" class="back-link">About </a> |
                <a href="https://jsnj.link/map-hiraeth-source" target="_blank">Source </a>
            </div>
        </div>
    </div>

    <audio id="light-ambient" loop preload="auto"> <source src="sounds/gentle-winds.mp3" type="audio/mpeg">
      Your browser does not support the audio element.
    </audio>
    <audio id="dark-ambient" loop preload="auto"> <source src="sounds/night-ambient.mp3" type="audio/mpeg">
      Your browser does not support the audio element.
    </audio>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>

    <script>
        // --- Global Variables ---
        let mapData = []; // Will be populated by loadMapData
        let loadingProgressInterval = null;
        let loadingProgress = 0;
        let currentRegionGroup = null;
        let regionsVisible = false; // Overall region visibility toggle
        let currentRoadGroup = null; // Holds currently displayed road layers
        // let regionFiltersPanelVisible = false; // No longer needed as separate panel
        
        // --- Measurement Tool State ---
        let isMeasuring = false; // Existing
        let measurementStartPoint = null; // Existing
        let measurementLayerGroup; // Declare it here

        // --- Initialize Leaflet Map ---
        const map = L.map('map', {
            crs: L.CRS.Simple,
            minZoom: -3,
            maxZoom: 4,
            attributionControl: false,
            zoomControl: false // Disable default zoom, using custom styled one
        });

        // NOW Initialize measurementLayerGroup
        measurementLayerGroup = L.layerGroup().addTo(map);


        // --- NEW: Multi-Point Measurement State ---
        let isMeasuringMultiPoint = false; // Tracks if multi-point mode is active
        let multiPointPath = []; // Array of L.LatLng objects for the current path
        let multiPointPolyline = null; // The L.Polyline layer for the drawn path
        let multiPointVertexMarkers = []; // Array of L.CircleMarker for vertices
        let multiPointSegmentTooltips = []; // Array of L.Tooltip for segment lengths (optional)
        let multiPointTotalTooltip = null; // L.Tooltip for the total path length
        let temporaryMouseMoveLine = null; // L.Polyline for the line from last point to cursor
        let temporaryMouseMoveTooltip = null; // L.Tooltip for the temporary line's length


        // --- Initialize Leaflet Map ---
        // Add styled zoom control
        L.control.zoom({ position: 'topleft' }).addTo(map);

        const poiTypeGroups = {
            "Settlements": ["City", "Town", "Village", "Hamlet", "Settlement", "Capital"],
            "Structures": ["Castle", "Fortress", "Fort", "Tower", "Ruin", "Temple", "Shrine", "Mine", "Lighthouse", "Bridge", "Dungeon", "Lair", "Camp", "Asylum", "Landmark"],
            "Natural Features": ["Mountain", "Peak", "Forest", "Wood", "River", "Lake", "Cave", "Cavern", "Coast", "Bay", "Cove", "Swamp", "Marsh", "Desert", "Natural Landmark"],
            "Other": ["Point of Interest", "Region", "Portal"],
            "Unknown": ["Unknown"]
        };
        
        function getUrlParameters() {
            const params = {};
            const queryString = window.location.search.substring(1);
            const pairs = queryString.split('&');
            
            for (const pair of pairs) {
                const [key, value] = pair.split('=');
                if (key) params[decodeURIComponent(key)] = decodeURIComponent(value || '');
            }
            return params;
        }

        // --- Auto-generate a reverse map for quick lookup (Type -> Group) ---
        const typeToGroupMap = {};
        for (const groupName in poiTypeGroups) {
            poiTypeGroups[groupName].forEach(type => {
                typeToGroupMap[type] = groupName;
            });
        }
        // --- END: POI Type Grouping Configuration ---

        // --- More Global variables ---
        let currentImageLayer = null;
        let currentMarkerGroup = null; // Holds currently *visible* markers
        let allMapMarkers = []; // Holds *all* markers for the loaded map
        let currentBounds = null;
        let currentlyLoadedMapId = null;
        let currentSidebarState = 'o';
        let markersVisible = true; // <--- THIS SHOULD BE TRUE FOR VISIBLE BY DEFAULT
        const transitionDuration = 300; // ms for sidebar animation
        let filtersPanelVisible = false; // State for combined filter panel visibility

        // --- DOM Elements ---
        const container = document.querySelector('.container');
        const sidebar = document.getElementById('sidebar');
        const mapListElement = document.getElementById('map-list');
        const toggleBtn = document.getElementById('toggle-sidebar-btn');
        const themeToggle = document.getElementById('theme-checkbox');
        const bodyElement = document.body;
        const mapElement = document.getElementById('map'); // Get map div
        const toggleBlurbBtn = document.getElementById('toggle-blurb-btn');
        const mapBlurbElement = document.getElementById('map-blurb');
        const toggleMarkersBtn = document.getElementById('toggle-markers-btn');
        const searchControlContainer = document.getElementById('search-control-container');
        const poiSearchInput = document.getElementById('poi-search-input');
        const searchResultsContainer = document.getElementById('search-results-container');
        const poiFilterContainer = document.getElementById('poi-filter-container');
        const filterToggleAllCheckbox = document.getElementById('filter-toggle-all');
        const toggleFiltersBtn = document.getElementById('toggle-filters-btn');
        const measureToolBtn = document.getElementById('measure-tool-btn');
        const loadingIndicator = document.getElementById('loading-indicator');
        // Sound elements
        const lightAmbient = document.getElementById('light-ambient');
        const darkAmbient = document.getElementById('dark-ambient');
        const toggleSoundBtn = document.getElementById('toggle-sound-btn');
        const soundIcon = document.getElementById('sound-icon');
        let soundEnabled = false;


        // --- Helper Functions ---
        function findMapRecursive(items, id) {
            for (const item of items) {
                if (item.id === id) { return item; }
                if (item.type === 'folder' && item.children) {
                    const found = findMapRecursive(item.children, id);
                    if (found) return found;
                }
            }
            return null;
        }

        function findFirstLoadableIdRecursive(items) {
            for (const item of items) {
                if (item.id && item.status !== 'coming-soon') return item.id;
                if (item.type === 'folder' && item.children) {
                    const foundId = findFirstLoadableIdRecursive(item.children);
                    if (foundId) return foundId;
                }
            }
            // Fallback: If only coming-soon items exist, return the first ID found
            for (const item of items) {
                 if (item.id) return item.id;
                 if (item.type === 'folder' && item.children) {
                      const foundId = findFirstLoadableIdRecursive(item.children); // Re-run without status check
                      if (foundId) return foundId;
                 }
            }
            return null;
        }

        function parseHash() {
            const hash = window.location.hash.substring(1);
            let mapId = null;
            let sidebarState = null;
            if (hash) {
                const parts = hash.split('-s=');
                mapId = parts[0];
                if (parts.length > 1 && ['o', 'c'].includes(parts[1])) {
                    sidebarState = parts[1];
                }
            }
            // Default map ID determination moved to initializeApp after data is loaded
            return {
                mapId: mapId, // May be null initially
                sidebarState: sidebarState || 'o'
            };
        }
        
        // --- FIX: Corrected generateHash to only return the hash fragment ---
        function generateHash(mapId, sidebarState) {
            return `#${mapId || ''}-s=${sidebarState}`;
        }

        // --- Function to Set Sidebar State ---
        function setSidebarState(state, updateHash = true) {
            const shouldBeCollapsed = (state === 'c');
            const isCurrentlyCollapsed = container.classList.contains('sidebar-collapsed');
            if (shouldBeCollapsed !== isCurrentlyCollapsed) {
                console.log(`Setting sidebar state to: ${state}`);
                container.classList.toggle('sidebar-collapsed', shouldBeCollapsed);
                toggleBtn.innerHTML = shouldBeCollapsed ? '&raquo;' : '&laquo;';
                toggleBtn.title = shouldBeCollapsed ? 'Expand Sidebar' : 'Collapse Sidebar';

                // Invalidate map size after CSS transition completes
                setTimeout(() => { map.invalidateSize({ animate: true }); }, transitionDuration);

                 currentSidebarState = state;
                 if (updateHash && currentlyLoadedMapId) {
                    // --- FIX: Update history with search params and new hash ---
                    const newHash = generateHash(currentlyLoadedMapId, state);
                    const currentSearch = window.location.search;
                    const newUrl = `${currentSearch}${newHash}`;
                    console.log("Updating URL from setSidebarState:", newUrl);
                    history.replaceState(null, '', newUrl); // Use replaceState for sidebar toggle
                 }
            } else {
                 currentSidebarState = state;
                 console.log(`Sidebar already in state: ${state}`);
            }
        }

        // --- Helper Function to Update the "Toggle All" Checkbox State ---
        function updateToggleAllCheckboxState() {
            // Update indeterminate state for each region group parent
            const regionGroupCheckboxes = poiFilterContainer.querySelectorAll('.region-group-filter');
            regionGroupCheckboxes.forEach(groupCheckbox => {
                const groupName = groupCheckbox.value;
                const childCheckboxes = poiFilterContainer.querySelectorAll(`.region-type-filter[data-group="${groupName}"]`);
                const checkedChildren = poiFilterContainer.querySelectorAll(`.region-type-filter[data-group="${groupName}"]:checked`);

                if (checkedChildren.length === 0) {
                    groupCheckbox.checked = false;
                    groupCheckbox.indeterminate = false;
                } else if (checkedChildren.length === childCheckboxes.length) {
                    groupCheckbox.checked = true;
                    groupCheckbox.indeterminate = false;
                } else {
                    groupCheckbox.checked = false;
                    groupCheckbox.indeterminate = true;
                }
            });

            // Update master "Show All / Hide All" checkbox state
            const allTopLevelFilters = poiFilterContainer.querySelectorAll(
                '.poi-filter-checkbox:not(#filter-toggle-all), .region-group-filter, .line-type-filter'
            );
            const checkedTopLevelFilters = poiFilterContainer.querySelectorAll(
                '.poi-filter-checkbox:not(#filter-toggle-all):checked, .region-group-filter:checked:not(:indeterminate), .line-type-filter:checked'
            );
            const indeterminateTopLevelFilters = poiFilterContainer.querySelectorAll('.region-group-filter:indeterminate');

            if (allTopLevelFilters.length === 0) {
                filterToggleAllCheckbox.checked = true;
                filterToggleAllCheckbox.indeterminate = false;
            } else if (indeterminateTopLevelFilters.length > 0 || (checkedTopLevelFilters.length > 0 && checkedTopLevelFilters.length < allTopLevelFilters.length)) {
                filterToggleAllCheckbox.checked = false;
                filterToggleAllCheckbox.indeterminate = true;
            } else if (checkedTopLevelFilters.length === allTopLevelFilters.length) {
                filterToggleAllCheckbox.checked = true;
                filterToggleAllCheckbox.indeterminate = false;
            } else { // All are unchecked
                filterToggleAllCheckbox.checked = false;
                filterToggleAllCheckbox.indeterminate = false;
            }
        }

        // --- Function to Update Visible Markers AND Search Results ---
        function updateVisibleMarkersAndSearch() {
            if (!currentMarkerGroup || allMapMarkers.length === 0) {
                // Hide map-based controls if no markers
                searchControlContainer.style.display = 'none';
                searchResultsContainer.style.display = 'none';
                // Don't hide filter panel/button here, regions might still need filtering
                return;
            }

            // Ensure map-based controls are potentially visible if markers exist
            searchControlContainer.style.display = 'block';

            const searchTerm = poiSearchInput.value.toLowerCase().trim();
            searchResultsContainer.innerHTML = ''; // Clear previous results
            let searchResultFound = false;

            // Get the set of *specifically* checked POI group filters
            const activeSpecificGroupFilters = new Set();
            poiFilterContainer.querySelectorAll('.poi-filter-checkbox:not(#filter-toggle-all):checked').forEach(checkbox => {
                 activeSpecificGroupFilters.add(checkbox.value);
            });
            const allPoiGroupsChecked = filterToggleAllCheckbox.checked && !filterToggleAllCheckbox.indeterminate; // True if master toggle is fully checked

            allMapMarkers.forEach(marker => {
                const poi = marker.poiData;
                if (!poi) return;

                const nameMatch = !searchTerm || poi.name.toLowerCase().includes(searchTerm);

                const specificType = poi.type || 'Unknown';
                const poiGroup = typeToGroupMap[specificType] || 'Other';
                // A POI group matches if the master toggle is checked OR its specific group is checked
                const groupMatch = allPoiGroupsChecked || activeSpecificGroupFilters.has(poiGroup);

                // Update marker visibility on map
                if (markersVisible && nameMatch && groupMatch) { // Governed by markersVisible
                    if (!currentMarkerGroup.hasLayer(marker)) {
                        currentMarkerGroup.addLayer(marker);
                    }
                } else {
                    if (currentMarkerGroup.hasLayer(marker)) {
                        currentMarkerGroup.removeLayer(marker);
                    }
                }

                // --- Populate Search Results ---
                if (searchTerm && nameMatch) { // Only add to results if search term exists and name matches
                    searchResultFound = true;
                    const resultItem = document.createElement('div');
                    resultItem.className = 'search-result-item';
                    const highlightedName = poi.name.replace(
                        new RegExp(searchTerm, 'gi'),
                        '<strong>$&</strong>'
                    );
                    resultItem.innerHTML = highlightedName;
                    resultItem.title = `Go to ${poi.name}`;
                    resultItem.addEventListener('click', () => {
                        map.flyTo(marker.getLatLng(), Math.max(map.getZoom(), 1));
                        marker.openPopup();
                        poiSearchInput.value = '';
                        searchResultsContainer.style.display = 'none';
                        searchResultsContainer.innerHTML = '';
                    });
                    searchResultsContainer.appendChild(resultItem);
                }
            });

            // Show/hide search results container
            searchResultsContainer.style.display = searchResultFound ? 'block' : 'none';
        }


        // --- Function to Populate Filter Checkboxes (in the panel) ---
        function populateFilters(pointsOfInterest, mapId) {
            // Clear existing dynamic filters (headers, dividers, specific checkboxes)
            const dynamicElements = poiFilterContainer.querySelectorAll('h3:not(:first-of-type), hr, .filter-item:not(:first-child), .filter-group-container');
            dynamicElements.forEach(el => el.remove());

            const hasPOIs = pointsOfInterest && pointsOfInterest.length > 0;
            const selectedMap = findMapRecursive(mapData, mapId);
            const hasRegions = selectedMap && selectedMap.regions && Array.isArray(selectedMap.regions) && selectedMap.regions.length > 0;
            const hasRoads = selectedMap && selectedMap.roads && Array.isArray(selectedMap.roads) && selectedMap.roads.length > 0; // New check for roads

            // Hide filter button if no POIs, no regions, and no roads
            if (!hasPOIs && !hasRegions && !hasRoads) {
                poiFilterContainer.classList.remove('visible');
                toggleFiltersBtn.style.display = 'none';
                filtersPanelVisible = false;
                toggleFiltersBtn.classList.remove('active');
                filterToggleAllCheckbox.checked = true;
                filterToggleAllCheckbox.indeterminate = false;
                return;
            }

            // PART 1: Add POI type filters (existing logic)
            if (hasPOIs) {
                if (poiFilterContainer.querySelector('h3')) {
                    const poiHeader = document.createElement('h3');
                    poiHeader.textContent = "POI Types:";
                    poiFilterContainer.appendChild(poiHeader);
                }
                const relevantGroups = new Set();
                pointsOfInterest.forEach(poi => {
                    const specificType = poi.type || 'Unknown';
                    const group = typeToGroupMap[specificType] || 'Other';
                    relevantGroups.add(group);
                });
                const sortedGroups = Array.from(relevantGroups).sort();
                sortedGroups.forEach(groupName => {
                    if (!groupName || (poiTypeGroups[groupName] && poiTypeGroups[groupName].length === 0)) return;
                    const filterId = `filter-group-${groupName.replace(/\s+/g, '-')}`;
                    const div = document.createElement('div');
                    div.className = 'filter-item';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = filterId;
                    checkbox.value = groupName;
                    checkbox.checked = true;
                    checkbox.className = 'poi-filter-checkbox';
                    const label = document.createElement('label');
                    label.htmlFor = filterId;
                    label.textContent = groupName;
                    div.appendChild(checkbox);
                    div.appendChild(label);
                    poiFilterContainer.appendChild(div);
                });
            }

            // PART 2: Add region type filters (NEW HIERARCHICAL LOGIC)
            if (hasRegions && selectedMap.filterGroups && selectedMap.filterGroups.Regions) {
                if (hasPOIs) {
                    const divider = document.createElement('hr');
                    divider.style.margin = '10px 0';
                    divider.style.borderColor = 'var(--glass-border-light)';
                    bodyElement.classList.contains('dark-theme') && (divider.style.borderColor = 'var(--glass-border-dark)');
                    poiFilterContainer.appendChild(divider);
                }
                const regionHeader = document.createElement('h3');
                regionHeader.textContent = "Region Types:";
                poiFilterContainer.appendChild(regionHeader);

                const regionFilterGroups = selectedMap.filterGroups.Regions;

                for (const groupName in regionFilterGroups) {
                    if (Object.hasOwnProperty.call(regionFilterGroups, groupName)) {
                        const values = regionFilterGroups[groupName];
                        if (!Array.isArray(values) || values.length === 0) continue;

                        const groupContainer = document.createElement('div');
                        groupContainer.className = 'filter-group-container';
                        const groupFilterId = `filter-region-group-${groupName.replace(/\s+/g, '-')}`;
                        const groupDiv = document.createElement('div');
                        groupDiv.className = 'filter-item';
                        const groupCheckbox = document.createElement('input');
                        groupCheckbox.type = 'checkbox';
                        groupCheckbox.id = groupFilterId;
                        groupCheckbox.value = groupName;
                        groupCheckbox.checked = true;
                        groupCheckbox.className = 'region-group-filter';
                        const groupLabel = document.createElement('label');
                        groupLabel.htmlFor = groupFilterId;
                        groupLabel.textContent = groupName;
                        groupDiv.appendChild(groupCheckbox);
                        groupDiv.appendChild(groupLabel);
                        groupContainer.appendChild(groupDiv);

                        const nestedList = document.createElement('div');
                        nestedList.className = 'nested-filter-list';
                        nestedList.style.marginLeft = '20px';

                        values.forEach(value => {
                            const filterId = `filter-region-value-${value.replace(/\s+/g, '-')}`;
                            const div = document.createElement('div');
                            div.className = 'filter-item';
                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.id = filterId;
                            checkbox.value = value;
                            checkbox.checked = true;
                            checkbox.className = 'region-type-filter';
                            checkbox.dataset.group = groupName;
                            const label = document.createElement('label');
                            label.htmlFor = filterId;
                            label.textContent = value;
                            div.appendChild(checkbox);
                            div.appendChild(label);
                            nestedList.appendChild(div);
                        });
                        groupContainer.appendChild(nestedList);
                        poiFilterContainer.appendChild(groupContainer);
                    }
                }
            }

            // PART 3: Add line type filters (New)
            if (hasRoads) {
                if (hasPOIs || hasRegions) { // Add divider if other filters are present
                    const divider = document.createElement('hr');
                    divider.style.margin = '10px 0';
                    divider.style.borderColor = 'var(--glass-border-light)';
                    bodyElement.classList.contains('dark-theme') && (divider.style.borderColor = 'var(--glass-border-dark)');
                    poiFilterContainer.appendChild(divider);
                }

                const lineHeader = document.createElement('h3');
                lineHeader.textContent = "Line Types:";
                poiFilterContainer.appendChild(lineHeader);

                const lineTypes = [...new Set(selectedMap.roads.map(r => r.type || "Unnamed Road Type").filter(Boolean))].sort();

                lineTypes.forEach(type => {
                    const filterId = `filter-line-${(type || "untyped").replace(/\s+/g, '-').toLowerCase()}`;
                    const div = document.createElement('div');
                    div.className = 'filter-item';
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = filterId;
                    checkbox.value = type;
                    checkbox.checked = true; // Default checked
                    checkbox.className = 'line-type-filter'; // Specific class for line filters

                    const label = document.createElement('label');
                    label.htmlFor = filterId;
                    label.textContent = type.charAt(0).toUpperCase() + type.slice(1); // Capitalize

                    div.appendChild(checkbox);
                    div.appendChild(label);
                    poiFilterContainer.appendChild(div);
                });
            }

            // Show filter button since we have filters
            toggleFiltersBtn.style.display = 'block';

            // Ensure panel is hidden initially and button is not active
            poiFilterContainer.classList.remove('visible');
            filtersPanelVisible = false;
            toggleFiltersBtn.classList.remove('active');

            // Set initial state of the master toggle
            updateToggleAllCheckboxState();
        }


        // --- Function to Load/Switch Map ---
        function loadMap(mapId, updateHash = true) {
            // --- Show loading indicator ---
            if (loadingIndicator) {
                loadingIndicator.style.display = 'flex';
                const progressBar = loadingIndicator.querySelector('.progress-bar');
                const loadingText = loadingIndicator.querySelector('.loading-text');
                const spinner = loadingIndicator.querySelector('.spinner');

                loadingProgress = 0;
                if (progressBar) progressBar.style.width = '0%';
                if (loadingText) loadingText.textContent = "Loading Map...";
                if (spinner) spinner.style.display = 'block';

                if (loadingProgressInterval) clearInterval(loadingProgressInterval);
                loadingProgressInterval = setInterval(() => {
                    if (loadingProgress < 90) {
                        loadingProgress += 2 + Math.random() * 3;
                        loadingProgress = Math.min(loadingProgress, 90);
                        if (progressBar) progressBar.style.width = loadingProgress + '%';
                    } else {
                        clearInterval(loadingProgressInterval);
                        loadingProgressInterval = null;
                    }
                }, 150);
            }
            // --- END: Loading Indicator Setup ---

            if (isMeasuring) toggleMeasurementTool(); // Assuming this is for the old tool
            if (isMeasuringMultiPoint) finalizeMultiPointMeasure(false); // Finalize new tool if active
            measurementLayerGroup.clearLayers();


            // --- Hide Search/Filter UI during load ---
            searchControlContainer.style.display = 'none';
            searchResultsContainer.style.display = 'none';
            poiFilterContainer.classList.remove('visible');
            toggleFiltersBtn.style.display = 'none';
            filtersPanelVisible = false;
            toggleFiltersBtn.classList.remove('active');
            poiSearchInput.value = '';

            const selectedMap = findMapRecursive(mapData, mapId);

            // --- Clear Filter Checkboxes ---
            const dynamicFilters = poiFilterContainer.querySelectorAll('h3:not(:first-of-type), hr, .filter-item:not(:first-child)');
            dynamicFilters.forEach(el => el.remove());
            filterToggleAllCheckbox.checked = true;
            filterToggleAllCheckbox.indeterminate = false;

            // Remove previous layers
            if (currentImageLayer) map.removeLayer(currentImageLayer);
            if (currentMarkerGroup) map.removeLayer(currentMarkerGroup);
            if (currentRegionGroup) map.removeLayer(currentRegionGroup);
            if (currentRoadGroup) map.removeLayer(currentRoadGroup);
            currentRoadGroup = L.layerGroup().addTo(map); 

            currentImageLayer = null;
            currentMarkerGroup = null;
            currentRegionGroup = null;
            currentRoadGroup = null; // Explicitly nullify before reinitialization
            allMapMarkers = [];

            if (!selectedMap || selectedMap.status === 'coming-soon') {
                console.warn("Attempted to load map data not found or coming soon:", mapId);
                if (selectedMap) alert(`The map "${selectedMap.name}" is coming soon!`);
                currentlyLoadedMapId = null;
                mapBlurbElement.classList.remove('visible');
                toggleMarkersBtn.style.display = 'none';
                measureToolBtn.style.display = 'none';
                toggleFiltersBtn.style.display = 'none';
                searchControlContainer.style.display = 'none';
                if (updateHash) {
                    // --- FIX: Update history with search params and new hash ---
                    const newHash = generateHash('', currentSidebarState);
                    const currentSearch = window.location.search;
                    history.pushState(null, '', `${currentSearch}${newHash}`);
                }

                if (loadingIndicator) {
                    if (loadingProgressInterval) clearInterval(loadingProgressInterval);
                    loadingIndicator.style.display = 'none';
                }
                return;
            }
            
            // --- This block was removed as the logic is now handled by the history.pushState below ---

            if (mapId === currentlyLoadedMapId) {
                 console.log(`Map ${mapId} is already loaded.`);
                 if (updateHash) {
                     // --- FIX: Ensure the full correct URL is in the history state ---
                     const newHash = generateHash(mapId, currentSidebarState);
                     const currentSearch = window.location.search;
                     const newUrl = `${currentSearch}${newHash}`;
                     if (window.location.href !== new URL(newUrl, window.location.href).href) {
                          history.replaceState(null, '', newUrl);
                     }
                 }
                 if (loadingIndicator) {
                     if (loadingProgressInterval) clearInterval(loadingProgressInterval);
                     loadingIndicator.style.display = 'none';
                 }
                 return;
            }

            console.log(`Loading map: ${selectedMap.name} (ID: ${mapId})`);

            // Initialize Layer Groups for this map load
            currentMarkerGroup = L.layerGroup(); // Not added to map until populated
            currentRegionGroup = L.layerGroup().addTo(map); // Add to map immediately
            currentRoadGroup = L.layerGroup().addTo(map);   // Add to map immediately
            console.log("Initialized currentRoadGroup in loadMap:", currentRoadGroup, "Is L.LayerGroup:", currentRoadGroup instanceof L.LayerGroup);


            const mapHeight = selectedMap.height;
            const mapWidth = selectedMap.width;
            if (isNaN(mapHeight) || isNaN(mapWidth) || !selectedMap.imageUrl) {
                console.error(`Invalid dimensions or missing imageUrl for map ID ${mapId}`);
                mapBlurbElement.classList.remove('visible');
                toggleMarkersBtn.style.display = 'none';
                measureToolBtn.style.display = 'none';
                toggleFiltersBtn.style.display = 'none';
                searchControlContainer.style.display = 'none';
                currentlyLoadedMapId = null;
                if (updateHash) {
                    // --- FIX: Update history with search params and new hash ---
                    const newHash = generateHash('', currentSidebarState);
                    const currentSearch = window.location.search;
                    history.pushState(null, '', `${currentSearch}${newHash}`);
                }

                if (loadingIndicator) {
                    if (loadingProgressInterval) clearInterval(loadingProgressInterval);
                    const loadingTextEl = loadingIndicator.querySelector('.loading-text');
                    const progressBarEl = loadingIndicator.querySelector('.progress-bar');
                    const spinnerEl = loadingIndicator.querySelector('.spinner');
                    if(loadingTextEl) loadingTextEl.textContent = "Error: Invalid map data.";
                    if(progressBarEl) progressBarEl.style.width = '0%';
                    if(spinnerEl) spinnerEl.style.display = 'none';
                    setTimeout(() => { loadingIndicator.style.display = 'none'; }, 3000);
                }
                return;
            }
            currentBounds = [[0, 0], [mapHeight, mapWidth]];

            currentImageLayer = L.imageOverlay(selectedMap.imageUrl, currentBounds);

            const preloadImg = new Image();
            let loadingComplete = false;
            let loadingTimeout = null;

            function finishLoading() {
                if (loadingComplete) return;
                loadingComplete = true;
                clearTimeout(loadingTimeout);

                console.log("Image overlay loaded (or timed out).");
                if (loadingIndicator) {
                    const progressBarEl = loadingIndicator.querySelector('.progress-bar');
                    if (progressBarEl) {
                        progressBarEl.style.width = '100%';
                        setTimeout(() => {
                            if (loadingProgressInterval) clearInterval(loadingProgressInterval);
                            loadingProgressInterval = null;
                            loadingIndicator.style.display = 'none';
                        }, 300);
                    } else {
                        if (loadingProgressInterval) clearInterval(loadingProgressInterval);
                        loadingProgressInterval = null;
                        loadingIndicator.style.display = 'none';
                    }
                }
                map.fitBounds(currentBounds);
            }

            preloadImg.onload = function() { finishLoading(); };
            currentImageLayer.on('load', function() { finishLoading(); });
            currentImageLayer.on('error', function() {
                 if (loadingComplete) return;
                 loadingComplete = true;
                 clearTimeout(loadingTimeout);
                 console.error("Image overlay failed to load:", selectedMap.imageUrl);
                 if (loadingIndicator) {
                     if (loadingProgressInterval) clearInterval(loadingProgressInterval);
                     loadingProgressInterval = null;
                     const progressBarEl = loadingIndicator.querySelector('.progress-bar');
                     const loadingTextEl = loadingIndicator.querySelector('.loading-text');
                     const spinnerEl = loadingIndicator.querySelector('.spinner');
                     if (progressBarEl) progressBarEl.style.width = '0%';
                     if (loadingTextEl) loadingTextEl.textContent = "Error loading map image.";
                     if (spinnerEl) spinnerEl.style.display = 'none';
                     setTimeout(() => { loadingIndicator.style.display = 'none'; }, 3000);
                 }
                 if (currentImageLayer) map.removeLayer(currentImageLayer);
                 currentImageLayer = null;
                 currentlyLoadedMapId = null;
                 toggleMarkersBtn.style.display = 'none';
                 measureToolBtn.style.display = 'none';
                 toggleFiltersBtn.style.display = 'none';
                 searchControlContainer.style.display = 'none';
            });

            loadingTimeout = setTimeout(() => {
                console.warn("Loading fallback timer triggered.");
                finishLoading();
            }, 8000);

            preloadImg.src = selectedMap.imageUrl;
            currentImageLayer.addTo(map);

            const points = selectedMap.pointsOfInterest || []; //
            populateFilters(points, mapId); //

            points.forEach(point => { //
                try { // START OF ADDED TRY BLOCK
                    if (point.coords && point.coords.length === 2 && !isNaN(point.coords[0]) && !isNaN(point.coords[1])) { //
                        // mapHeight and mapWidth are defined earlier in loadMap
                        if (point.coords[0] >= 0 && point.coords[0] <= mapHeight && point.coords[1] >= 0 && point.coords[1] <= mapWidth) { //
                             const marker = L.marker(point.coords); //
                            
                             // It's good practice to check if marker was created, though L.marker usually throws its own error if L is undefined.
                             // The ReferenceError for 'marker' is unusual here unless L.marker itself has an issue.
                             if (marker) {
                                 marker.poiData = point; //
                                 let popupContent = '';
                                 if (point.wikiLink) { //
                                     popupContent += `<h3><a href="${point.wikiLink}" target="_blank" rel="noopener noreferrer" title="Visit wiki page for ${point.name}">${point.name}</a></h3>`; //
                                 } else {
                                     popupContent += `<h3>${point.name}</h3>`; //
                                 }
                                 popupContent += `<p><em>Type: ${point.type || 'Unknown'}</em></p>`; //
                                 popupContent += `<p>${point.description || ''}</p>`; //
                                 marker.bindPopup(popupContent); //
                                 allMapMarkers.push(marker); //
                             } else {
                                 // This case is unlikely if L.marker is standard Leaflet, but good for robustness
                                 console.warn(`L.marker call returned undefined for POI: ${point.name || 'Unnamed POI'} at coords:`, point.coords);
                             }
                        } else { 
                            console.warn(`POI coordinates out of bounds for map ${selectedMap.name}: ${point.name}`, point.coords);  //
                        }
                    } else { 
                        console.warn(`Invalid coordinates for POI: ${point.name}`, point.coords);  //
                    }
                } catch (e) {
                    // Log the error and the POI that caused it
                    console.error(`Error processing POI: ${point ? (point.name || JSON.stringify(point)) : 'Unknown POI'}. Error: ${e.message}`, e);
                    // This will help identify if a specific POI's data is causing L.marker() to fail.
                    // The original ReferenceError might be a symptom of L.marker() failing internally due to bad data.
                } // END OF ADDED TRY BLOCK
            });

            currentMarkerGroup.addTo(map); // Add populated marker group to map //
            updateVisibleMarkersAndSearch(); //

            addRegionsToMap(mapId); // Populates currentRegionGroup //
            updateVisibleRegions(); //

            addRoadsToMap(mapId); // Populates currentRoadGroup //
            // updateVisibleLines(); // This was added in the previous step, ensure it's still here.
            // Check if updateVisibleLines is present; if not, re-add it from the previous response.
            // Based on the provided file, it seems you might be merging changes.
            // Ensure this line is present if you implemented line filtering:
            if (typeof updateVisibleLines === "function") {
                 updateVisibleLines();
            }
            updateVisibleRegions();

            addRoadsToMap(mapId); // Populates currentRoadGroup
            console.log("currentRoadGroup before bringToBack in loadMap:", currentRoadGroup, "Is L.LayerGroup:", currentRoadGroup instanceof L.LayerGroup);


            // Adjust layering order as desired
            if (currentRegionGroup && typeof currentRegionGroup.bringToBack === 'function') {
                currentRegionGroup.bringToBack(); // Regions furthest back
            } else {
                console.warn("currentRegionGroup not valid for bringToBack or method missing");
            }

            if (currentRoadGroup && typeof currentRoadGroup.bringToBack === 'function') {
                 currentRoadGroup.bringToBack(); // Roads will also go to back, potentially over regions if pane is same.
                                                 // To ensure roads are above regions, you might need separate panes or careful ordering.
                                                 // For now, let's assume default pane; this will place roads at the bottom, then regions above them (if also sent to back).
                                                 // If you want roads ON TOP of regions:
                                                 // currentRegionGroup.bringToBack();
                                                 // (roads are already added, they will be above regions unless also sent to back AFTER regions)
            } else {
                console.error("loadMap: currentRoadGroup.bringToBack is not a function!", currentRoadGroup);
            }
            
            // Markers are added to currentMarkerGroup which is then added to map. They usually appear on top by default.
            // If explicit control is needed:
            // if (currentMarkerGroup && typeof currentMarkerGroup.bringToFront === 'function') {
            //   currentMarkerGroup.bringToFront();
            // }


            const hasPOIs = allMapMarkers.length > 0;
            // Adjust control visibility based on whether POIs, Regions, or Roads exist
            const hasRegions = selectedMap.regions && selectedMap.regions.length > 0;
            const hasRoads = selectedMap.roads && selectedMap.roads.length > 0;

            toggleMarkersBtn.style.display = (hasPOIs || hasRegions) ? 'block' : 'none'; // Show if POIs or Regions exist
            searchControlContainer.style.display = hasPOIs ? 'block' : 'none'; // Search for POIs

            const hasValidScale = typeof selectedMap.scalePixels === 'number' && selectedMap.scalePixels > 0 &&
                                 typeof selectedMap.scaleKilometers === 'number' && selectedMap.scaleKilometers > 0;
            measureToolBtn.style.display = hasValidScale ? 'block' : 'none';


            toggleMarkersBtn.classList.toggle('markers-hidden', !markersVisible);
            toggleMarkersBtn.title = markersVisible ? "Hide Markers & Regions" : "Show Markers & Regions";

            // --- Blurb Handling ---
            if (selectedMap.blurb) {
                mapBlurbElement.innerHTML = selectedMap.blurb;
                toggleBlurbBtn.style.display = 'block'; // Show the button
                // Ensure blurb is hidden on map load
                mapBlurbElement.classList.remove('visible');
                toggleBlurbBtn.classList.remove('active');
            } else {
                mapBlurbElement.innerHTML = '';
                toggleBlurbBtn.style.display = 'none'; // Hide the button
                mapBlurbElement.classList.remove('visible');
                toggleBlurbBtn.classList.remove('active');
            }

            document.querySelectorAll('#map-list .map-item, #map-list .folder-header').forEach(item => item.classList.remove('active'));
            const activeMapItem = document.querySelector(`#map-list .map-item[data-map-id="${mapId}"]`);
            const activeFolderHeader = document.querySelector(`#map-list .folder-header[data-map-id="${mapId}"]`);
            if (activeMapItem) {
                activeMapItem.classList.add('active');
                let parent = activeMapItem.closest('.nested-list');
                while (parent) {
                    const folderLi = parent.closest('.folder');
                    if (folderLi && folderLi.classList.contains('closed')) { folderLi.classList.remove('closed'); }
                    parent = folderLi?.parentElement.closest('.nested-list');
                }
            } else if (activeFolderHeader) {
                activeFolderHeader.classList.add('active');
                 const folderLi = activeFolderHeader.closest('.folder');
                 if (folderLi && folderLi.classList.contains('closed')) { folderLi.classList.remove('closed'); }
            }

            currentlyLoadedMapId = mapId;
            if (updateHash) {
                // --- FIX: Update history with search params and new hash ---
                const newHash = generateHash(mapId, currentSidebarState);
                const currentSearch = window.location.search;
                history.pushState(
                    { mapId: mapId, sidebarState: currentSidebarState },
                    selectedMap.name,
                    `${currentSearch}${newHash}`
                );
            }
            console.log(`Finished setting up map load for: ${selectedMap.name}`);
        }

        // --- Function to add regions to map ---
        function addRegionsToMap(mapId) {
            if (!currentRegionGroup) {
                currentRegionGroup = L.layerGroup().addTo(map);
            } else {
                currentRegionGroup.clearLayers();
            }

            const selectedMap = findMapRecursive(mapData, mapId);
            if (!selectedMap || !selectedMap.regions || !Array.isArray(selectedMap.regions)) {
                console.log(`No regions found for map: ${mapId}`);
                return;
            }

            selectedMap.regions.forEach(region => {
                if (!region.coordinates || region.coordinates.length < 3) {
                    console.warn(`Invalid coordinates for region: ${region.name}`);
                    return;
                }

                const polygon = L.polygon(region.coordinates, {
                    color: region.color || '#3388ff',
                    fillColor: region.fillColor || '#3388ff',
                    fillOpacity: regionsVisible ? (region.fillOpacity || 0.2) : 0, // Initial opacity based on toggle
                    weight: 2,
                    opacity: regionsVisible ? 1 : 0, // Initial opacity based on toggle
                    interactive: true // Make regions clickable
                });

                let popupContent = '';
                if (region.wikiLink) {
                    popupContent += `<h3><a href="${region.wikiLink}" target="_blank" rel="noopener noreferrer" title="Visit wiki page for ${region.name}">${region.name}</a></h3>`;
                } else {
                    popupContent += `<h3>${region.name}</h3>`;
                }

                // NEW: Display type and value in popup
                if (region.type && region.value) {
                    popupContent += `<p><em>${region.type}: ${region.value}</em></p>`;
                } else if (region.type) {
                    popupContent += `<p><em>Type: ${region.type}</em></p>`;
                }

                if (region.description) {
                    popupContent += `<p>${region.description}</p>`;
                }
                polygon.bindPopup(popupContent);

                polygon.regionData = region; // Store data for filtering
                currentRegionGroup.addLayer(polygon);
                polygon.bringToBack(); // Ensure regions are behind markers
            });
        }

        // --- Update region visibility based on main toggle and filters ---
        function updateVisibleRegions() {
            if (!currentRegionGroup) return;

            // Get the currently checked region type filters (the individual values)
            const valueFilters = poiFilterContainer.querySelectorAll('.region-type-filter:checked');
            const valueFilterValues = new Set(Array.from(valueFilters).map(cb => cb.value));

            // Check the master toggle state
            const allTypesChecked = filterToggleAllCheckbox.checked && !filterToggleAllCheckbox.indeterminate;

            currentRegionGroup.eachLayer(layer => {
                const region = layer.regionData;
                if (!region || !region.type || !region.value) return;

                // A region is visible if the master toggle is checked OR its specific value is in the checked set.
                const typeMatch = allTypesChecked || valueFilterValues.has(region.value);

                // Apply visibility and interactivity based on *both* the overall toggle AND the type filter match
                if (regionsVisible && typeMatch) { // regionsVisible is synced with markersVisible
                    layer.setStyle({
                        stroke: true,
                        fill: true,
                        opacity: 1,
                        fillOpacity: region.fillOpacity || 0.2
                    });
                    layer.bringToBack();
                } else {
                    layer.setStyle({
                        stroke: false,
                        fill: false
                    });
                }
            });
        }

        // --- Populate Sidebar (Recursive Function) ---
        function populateSidebar(parentElement, items) {
    // Add this log at the start of the function
    console.log(`Populating sidebar for parent:`, parentElement, 'with items:', items);

    parentElement.innerHTML = '';
    items.forEach(item => {
        // Add this log inside the loop
        console.log(`Processing item:`, JSON.stringify(item)); // Stringify to see the whole object easily

        const listItem = document.createElement('li');

        if (item.type === 'folder') {
            // Add this log for folders
            console.log(`-- It's a Folder. Name: '${item.name}', Status: '${item.status}'`);

            listItem.classList.add('folder', 'closed');
            const header = document.createElement('div');
            header.classList.add('folder-header');
            // This line includes the fix from before
            header.innerHTML = `<span class="folder-toggle-icon"></span><span>${item.name || 'Unnamed Folder!'}</span>`; // Add fallback text
            const nestedList = document.createElement('ul');
            nestedList.classList.add('nested-list');

            if (item.children && item.children.length > 0) {
                // Log before recursion
                console.log(`---- Populating children for folder '${item.name}'`);
                populateSidebar(nestedList, item.children);
            } else {
                // Log if no children
                console.log(`---- Folder '${item.name}' has no children.`);
            }

            header.addEventListener('click', (e) => {
                e.stopPropagation();
                listItem.classList.toggle('closed');
            });

            if (item.id && item.status !== 'coming-soon') {
                header.dataset.mapId = item.id;
                header.title = `Click to toggle '${item.name}', double-click to load map.`;
                header.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    loadMap(item.id, true);
                });
            } else if (item.status === 'coming-soon') {
                 header.classList.add('coming-soon');
                 // Apply the (Soon) text suffix and title
                 header.innerHTML = `<span class="folder-toggle-icon"></span><span>${item.name || 'Unnamed Folder!'} (Soon)</span>`;
                 header.title = `${item.name || 'Coming Soon!'} - Coming Soon!`;
                 header.addEventListener('dblclick', (e) => {
                      e.stopPropagation();
                      alert(`The map "${item.name || 'this map'}" is coming soon!`);
                 });
            } else {
                 header.title = `Click to toggle '${item.name || 'Unnamed Folder!'}'.`;
            }
            listItem.appendChild(header);
            listItem.appendChild(nestedList);

        } else { // Map Item
            // Add this log for map items
            console.log(`-- It's a Map Item. Name: '${item.name}', Status: '${item.status}'`);

            listItem.classList.add('map-item');
            listItem.textContent = item.name || 'Unnamed Map!'; // Add fallback text
            listItem.dataset.mapId = item.id;

            if (item.status === 'coming-soon') {
                listItem.classList.add('coming-soon');
                listItem.textContent = `${item.name || 'Unnamed Map!'} (Soon)`;
                listItem.title = `${item.name || 'Coming Soon!'} - Coming Soon!`;
                listItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    alert(`The map "${item.name || 'this map'}" is coming soon!`);
                });
            } else {
                listItem.title = `Load map: ${item.name || 'Unnamed Map!'}`;
                listItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    loadMap(item.id, true);
                });
            }
        }
        parentElement.appendChild(listItem);
    });
}
        // populateSidebar is now called within initializeApp after data is loaded

        // --- Sidebar Toggle Button Logic ---
        toggleBtn.addEventListener('click', () => {
            const newState = container.classList.contains('sidebar-collapsed') ? 'o' : 'c';
            setSidebarState(newState, true);
        });

        // --- Theme Toggle Logic ---
        function applyTheme(theme) {
            if (theme === 'dark') { bodyElement.classList.add('dark-theme'); themeToggle.checked = true; }
            else { bodyElement.classList.remove('dark-theme'); themeToggle.checked = false; }
            // Update divider color in filter panel
            const divider = poiFilterContainer.querySelector('hr');
            if (divider) {
                divider.style.borderColor = theme === 'dark' ? 'var(--glass-border-dark)' : 'var(--glass-border-light)';
            }
        }

        // --- Sound Control Logic ---
        function fadeAudio(audioElement, targetVolume, duration = 1500) { // Shorter fade
            const startVolume = audioElement.volume;
            const volumeChange = targetVolume - startVolume;
            if (volumeChange === 0 && (targetVolume === 0 || !audioElement.paused)) return; // No change needed

            const startTime = Date.now();

            function updateVolume() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(1, elapsed / duration);
                audioElement.volume = Math.max(0, Math.min(1, startVolume + (volumeChange * progress))); // Clamp volume

                if (progress < 1) {
                    requestAnimationFrame(updateVolume);
                } else {
                    if (targetVolume === 0 && !audioElement.paused) {
                        audioElement.pause();
                        console.log("Paused:", audioElement.id);
                    }
                }
            }

            if (targetVolume > 0 && audioElement.paused) {
                audioElement.volume = 0; // Start from silent
                audioElement.play().then(() => {
                    console.log("Playing:", audioElement.id);
                    requestAnimationFrame(updateVolume);
                }).catch(e => console.log('Audio play prevented:', e));
            } else if (targetVolume > 0 && !audioElement.paused) {
                 requestAnimationFrame(updateVolume); // Already playing, just adjust volume
            } else if (targetVolume === 0) {
                 requestAnimationFrame(updateVolume); // Fading out
            }
        }

        // --- Function to add roads to map ---
        function addRoadsToMap(mapId) {
            if (!currentRoadGroup) {
                currentRoadGroup = L.layerGroup().addTo(map);
            } else {
                currentRoadGroup.clearLayers();
            }

            const selectedMap = findMapRecursive(mapData, mapId);
            if (!selectedMap || !selectedMap.roads || !Array.isArray(selectedMap.roads)) {
                console.log(`No roads found for map: ${mapId}`);
                return;
            }

            selectedMap.roads.forEach(road => {
                if (!road.coordinates || road.coordinates.length < 2) {
                    console.warn(`Invalid coordinates for road: ${road.name || road.id}`);
                    return;
                }
                
                const defaultOpacity = 0.8; // Define a default if not specified in JSON
                const roadOptions = {
                    color: road.color || '#808080', 
                    weight: road.weight || 3,
                    opacity: road.opacity === undefined ? defaultOpacity : road.opacity, // Use defined or default
                    smoothFactor: road.smoothFactor || 1.0 
                };

                if (road.dashArray && road.dashArray.trim() !== "") {
                    roadOptions.dashArray = road.dashArray;
                }

                const polyline = L.polyline(road.coordinates, roadOptions);

                // Store original opacity and road data for filtering
                polyline.originalOpacity = roadOptions.opacity; // Store the opacity used
                polyline.roadData = road; 

                let popupContent = '';
                if (road.name) {
                    if (road.wikiLink) {
                        popupContent += `<h3><a href="${road.wikiLink}" target="_blank" rel="noopener noreferrer" title="Visit wiki page for ${road.name}">${road.name}</a></h3>`;
                    } else {
                        popupContent += `<h3>${road.name}</h3>`;
                    }
                }
                 if (road.type) {
                    const typeString = road.type.charAt(0).toUpperCase() + road.type.slice(1);
                    popupContent += `<p><em>Type: ${typeString}</em></p>`;
                }
                if (road.description) {
                    popupContent += `<p>${road.description}</p>`;
                }

                if (popupContent.trim() !== "") {
                    polyline.bindPopup(popupContent);
                }

                // Store road data with the layer if needed for future interactions
                polyline.roadData = road;
                currentRoadGroup.addLayer(polyline);
            });
        }

        themeToggle.addEventListener('change', () => {
            const newTheme = themeToggle.checked ? 'dark' : 'light';
            localStorage.setItem('theme', newTheme);
            applyTheme(newTheme);

            if (soundEnabled) {
                if (newTheme === 'dark') {
                    fadeAudio(lightAmbient, 0);
                    fadeAudio(darkAmbient, 0.3); // Adjust target volume as needed
                } else {
                    fadeAudio(darkAmbient, 0);
                    fadeAudio(lightAmbient, 0.3); // Adjust target volume as needed
                }
            }
        });

        toggleSoundBtn.addEventListener('click', () => {
            soundEnabled = !soundEnabled;
            localStorage.setItem('soundEnabled', soundEnabled); // Save preference

            if (soundEnabled) {
                soundIcon.textContent = 'üîä';
                toggleSoundBtn.title = "Mute Sound";
                const currentTheme = bodyElement.classList.contains('dark-theme') ? 'dark' : 'light';
                if (currentTheme === 'dark') {
                    fadeAudio(darkAmbient, 0.3);
                } else {
                    fadeAudio(lightAmbient, 0.3);
                }
            } else {
                soundIcon.textContent = 'üîá';
                toggleSoundBtn.title = "Unmute Sound";
                fadeAudio(lightAmbient, 0);
                fadeAudio(darkAmbient, 0);
            }
        });

        // Function to initialize sound state from localStorage
        // Function to initialize sound state from localStorage
        function initializeSoundState() {
            // --- NEW: Check for embedded mode ---
            const urlParams = getUrlParameters(); // Need to get params here too
            if (urlParams.embed === 'true' || urlParams.hideUI === 'true') {
                console.log("Embedded mode: Sound initialization skipped.");
                soundEnabled = false; // Ensure state reflects no sound
                // Set icon/title to muted state (even though button is hidden)
                soundIcon.textContent = 'üîá';
                if(toggleSoundBtn) toggleSoundBtn.title = "Unmute Sound"; // Check if button exists before setting title
                return; // Exit early, do not proceed with sound logic
            }
            // --- END: Embedded mode check ---


            const savedSoundState = localStorage.getItem('soundEnabled');
            // Only proceed if not in embedded mode (checked above)
            soundEnabled = savedSoundState === 'true'; // Convert string to boolean

            // Set initial volume to 0 to prevent autoplay issues on load
            lightAmbient.volume = 0;
            darkAmbient.volume = 0;

            if (soundEnabled) {
                soundIcon.textContent = 'üîä';
                if(toggleSoundBtn) toggleSoundBtn.title = "Mute Sound";
                // Start playing the correct track based on the current theme
                const currentTheme = bodyElement.classList.contains('dark-theme') ? 'dark' : 'light';
                 if (currentTheme === 'dark') {
                     fadeAudio(darkAmbient, 0.3);
                } else {
                     fadeAudio(lightAmbient, 0.3);
                }
            } else {
                soundIcon.textContent = 'üîá';
                 if(toggleSoundBtn) toggleSoundBtn.title = "Unmute Sound";
            }
            // Make button visible now that state is set (only if not embedded)
            if(toggleSoundBtn) toggleSoundBtn.style.display = 'block';
        }


        // Apply initial theme from storage
        const savedTheme = localStorage.getItem('theme') || 'light';
        applyTheme(savedTheme);

        // --- Map Click Handler ---
        map.on('click', function(e) {
            if (!isMeasuring && currentBounds) {
                console.log(`Map clicked at: [${Math.round(e.latlng.lat)}, ${Math.round(e.latlng.lng)}] (Y, X from bottom-left)`);
            }
            // Hide filter panel if clicking outside
            if (filtersPanelVisible && !poiFilterContainer.contains(e.originalEvent.target) && e.originalEvent.target !== toggleFiltersBtn && !toggleFiltersBtn.contains(e.originalEvent.target)) {
                 toggleFilterPanel();
            }
            // Hide search results if clicking outside
            if (searchResultsContainer.style.display === 'block' && !searchResultsContainer.contains(e.originalEvent.target) && e.originalEvent.target !== poiSearchInput) {
                searchResultsContainer.style.display = 'none';
            }
            // Measurement logic handled separately
            // --- Hide Blurb on Map Click ---
            if (mapBlurbElement.classList.contains('visible')) {
                mapBlurbElement.classList.remove('visible');
                toggleBlurbBtn.classList.remove('active');
            }
        });

        // --- Blurb Element Click Stop ---
        mapBlurbElement.addEventListener('click', (e) => e.stopPropagation());


        // --- Handle Hash Changes / Back/Forward Navigation ---
        window.addEventListener('popstate', (event) => {
            console.log("Popstate event:", event.state);
            const { mapId: hashMpId, sidebarState: hashSidebarState } = parseHash(); // Re-parse hash
            const targetMapId = event.state?.mapId || hashMpId;
            const targetSidebarState = event.state?.sidebarState || hashSidebarState;

            console.log("Navigating via history - Target Map:", targetMapId, "Target Sidebar:", targetSidebarState);

            if (targetMapId && targetMapId !== currentlyLoadedMapId) {
                loadMap(targetMapId, false); // Load map without pushing new state
            }
            if (targetSidebarState && targetSidebarState !== currentSidebarState) {
                 setSidebarState(targetSidebarState, false); // Set sidebar without updating hash
            }
        });
        window.addEventListener('beforeunload', () => {
            if (loadingProgressInterval) clearInterval(loadingProgressInterval);
        });


        // --- Marker Toggle Button Logic ---
        toggleMarkersBtn.addEventListener('click', () => {
            markersVisible = !markersVisible;
            regionsVisible = markersVisible; // Sync regions with markers

            toggleMarkersBtn.title = markersVisible ? "Hide Markers & Regions" : "Show Markers & Regions";
            toggleMarkersBtn.classList.toggle('markers-hidden', !markersVisible);

            updateVisibleRegions(); // Update regions visibility
            updateVisibleMarkersAndSearch(); // Update marker visibility

            console.log(`Markers and regions toggled. Visible: ${markersVisible}`);
        });
        // --- Blurb Toggle Button Logic ---
        toggleBlurbBtn.addEventListener('click', (e) => {
            e.stopPropagation(); // Prevent map click event
            mapBlurbElement.classList.toggle('visible');
            toggleBlurbBtn.classList.toggle('active');
        });

        // --- Filter Panel Toggle Logic ---
        function toggleFilterPanel() {
            filtersPanelVisible = !filtersPanelVisible;
            poiFilterContainer.classList.toggle('visible', filtersPanelVisible);
            toggleFiltersBtn.classList.toggle('active', filtersPanelVisible);
            toggleFiltersBtn.title = filtersPanelVisible ? "Hide Filters" : "Show Filters";
        }
        toggleFiltersBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleFilterPanel();
        });

        // --- Search Input Logic ---
        poiSearchInput.addEventListener('input', updateVisibleMarkersAndSearch);
        poiSearchInput.addEventListener('click', (e) => e.stopPropagation());
        searchResultsContainer.addEventListener('click', (e) => e.stopPropagation());

        // --- Update line visibility based on filters ---
        function updateVisibleLines() {
            if (!currentRoadGroup) return;

            const typeFilters = poiFilterContainer.querySelectorAll('.line-type-filter:checked');
            const typeFilterValues = Array.from(typeFilters).map(cb => cb.value);
            const allTypesChecked = filterToggleAllCheckbox.checked && !filterToggleAllCheckbox.indeterminate;

            currentRoadGroup.eachLayer(layer => {
                const road = layer.roadData;
                if (!road) return;

                const roadType = road.type || "Unnamed Road Type"; // Match the logic in populateFilters
                const typeMatch = allTypesChecked || typeFilterValues.includes(roadType);

                // Lines are always "visible" in terms of the master toggle (markersVisible)
                // Their appearance is solely based on type filters.
                if (typeMatch) {
                    layer.setStyle({
                        opacity: layer.originalOpacity === undefined ? 0.8 : layer.originalOpacity // Restore original or default
                    });
                } else {
                    layer.setStyle({
                        opacity: 0 // Hide
                    });
                }
            });
        }

        // --- Combined Filter Panel Logic ---
        poiFilterContainer.addEventListener('change', (e) => {
            const target = e.target;
            if (target.type !== 'checkbox') return;

            // Handle parent group checkbox for regions
            if (target.classList.contains('region-group-filter')) {
                const isChecked = target.checked;
                const groupName = target.value;
                const nestedCheckboxes = target.closest('.filter-group-container').querySelectorAll('.region-type-filter');
                nestedCheckboxes.forEach(checkbox => {
                    if (checkbox.dataset.group === groupName) {
                        checkbox.checked = isChecked;
                    }
                });
            }

            // Handle master "Show All / Hide All" checkbox
            if (target.id === 'filter-toggle-all') {
                const isChecked = target.checked;
                poiFilterContainer.querySelectorAll('.poi-filter-checkbox, .region-group-filter, .region-type-filter, .line-type-filter').forEach(checkbox => {
                    if (checkbox.id !== 'filter-toggle-all') {
                        checkbox.checked = isChecked;
                    }
                });
                filterToggleAllCheckbox.indeterminate = false;
            }

            // Update parent and master toggles' indeterminate states
            updateToggleAllCheckboxState();

            // Trigger visibility updates
            if (target.classList.contains('poi-filter-checkbox') || target.id === 'filter-toggle-all') {
                updateVisibleMarkersAndSearch();
            }
            if (target.classList.contains('region-type-filter') || target.classList.contains('region-group-filter') || target.id === 'filter-toggle-all') {
                updateVisibleRegions();
            }
            if (target.classList.contains('line-type-filter') || target.id === 'filter-toggle-all') {
                updateVisibleLines();
            }
        });
        // Prevent map click when clicking inside filter panel
        poiFilterContainer.addEventListener('click', (e) => e.stopPropagation());


        // --- Measurement Tool Logic ---
        function handleMeasurementClick(e) {
            if (!isMeasuring || !currentlyLoadedMapId) return;
            if (e.originalEvent.target.closest('.leaflet-control')) return; // Ignore clicks on controls

            const clickPoint = e.latlng;
            const currentMapInfo = findMapRecursive(mapData, currentlyLoadedMapId);
            const scalePx = currentMapInfo?.scalePixels;
            const scaleKm = currentMapInfo?.scaleKilometers;
            const hasValidScale = typeof scalePx === 'number' && scalePx > 0 &&
                                  typeof scaleKm === 'number' && scaleKm > 0;

            measurementLayerGroup.eachLayer(layer => {
                if (layer instanceof L.Polyline || (layer.options && layer.options.isEndPoint)) {
                    measurementLayerGroup.removeLayer(layer);
                }
            });

            if (!measurementStartPoint) {
                measurementStartPoint = clickPoint;
                L.circleMarker(measurementStartPoint, {
                    radius: 5, color: 'red', fillColor: '#f03', fillOpacity: 0.8, interactive: false
                }).addTo(measurementLayerGroup)
                  .bindTooltip("Start point. Click second point.", { permanent: false, direction: 'top', className: 'measure-tooltip', offset: L.point(0, -5) })
                  .openTooltip();
            } else {
                const endPoint = clickPoint;
                const pixelDistance = map.distance(measurementStartPoint, endPoint);
                let distanceString = ""; // Will be constructed based on scale availability
                let kmDistance = null;   // Will store distance in the map's defined units (e.g., km)
                let tooltipContent = '';

                // These lines should already be present just before this 'else' block,
                // but ensure they are correctly fetching scale info for the current map.
                // const currentMapInfo = findMapRecursive(mapData, currentlyLoadedMapId);
                // const scalePx = currentMapInfo?.scalePixels;
                // const scaleKm = currentMapInfo?.scaleKilometers; // Represents the unit value for scale, e.g., km, miles
                // const hasValidScale = typeof scalePx === 'number' && scalePx > 0 &&
                //                         typeof scaleKm === 'number' && scaleKm > 0;

                if (hasValidScale) {
                    kmDistance = (pixelDistance / scalePx) * scaleKm;
                    // The unit (e.g., "km") is assumed from your JSON's "scaleKilometers" field.
                    // If your "scaleKilometers" field actually represents miles, you can change "km" to "miles" here.
                    distanceString = `${kmDistance.toFixed(2)} ${currentMapInfo.scaleUnitName || 'units'}`; // Assuming you might add a 'scaleUnitName' to your map JSON, otherwise defaults to 'units'

                    // --- ADJUST THESE PACE VALUES FOR YOUR GAME ---
                    const normalPaceUnitsPerDay = 25; // e.g., 25 km per day or 25 miles per day
                    const fastPaceUnitsPerDay = 40;   // e.g., 40 km per day or 40 miles per day
                    // ---

                    let daysNormalPace = (kmDistance / normalPaceUnitsPerDay).toFixed(1);
                    let daysFastPace = (kmDistance / fastPaceUnitsPerDay).toFixed(1);

                    tooltipContent = `Distance: ${distanceString}<br>Normal Pace: ${daysNormalPace} Day(s)<br>Fast Pace: ${daysFastPace}Day(s)`;
                } else {
                    // If no valid scale, distance is in pixels.
                    distanceString = `${pixelDistance.toFixed(0)} pixels (Scale unknown)`;
                    tooltipContent = `Distance: ${distanceString}<br>Days at Normal Pace: N/A (scale unknown)<br>Days at Fast Pace: N/A (scale unknown)`;
                }

                L.circleMarker(endPoint, {
                    radius: 5, color: 'blue', fillColor: '#30f', fillOpacity: 0.8, interactive: false, isEndPoint: true
                }).addTo(measurementLayerGroup);

                L.polyline([measurementStartPoint, endPoint], {
                    color: 'yellow', weight: 2, dashArray: '5, 5', interactive: false
                }).addTo(measurementLayerGroup)
                  .bindTooltip(tooltipContent, { permanent: true, direction: 'center', className: 'measure-tooltip' })
                  .openTooltip();

                measurementStartPoint = null; // Reset
            }
        }

        function toggleMeasurementTool() {
            isMeasuringMultiPoint = !isMeasuringMultiPoint; // Use the new state variable
            measureToolBtn.classList.toggle('active', isMeasuringMultiPoint);
            mapElement.classList.toggle('measuring-cursor', isMeasuringMultiPoint);

            if (isMeasuringMultiPoint) {
                measureToolBtn.title = "Measuring Path... Click to add points. Double-click or Esc to finish.";
                map.on('click', handleMultiPointMeasureClick);
                map.on('mousemove', handleMultiPointMouseMove);
                map.on('dblclick', finalizeMultiPointMeasure); // Add dblclick listener
                document.addEventListener('keydown', handleMeasureKeyDown); // For Esc key

                // Clear previous measurement layers (if any)
                measurementLayerGroup.clearLayers();
                multiPointPath = [];
                multiPointVertexMarkers = [];
                if (multiPointPolyline) map.removeLayer(multiPointPolyline);
                multiPointPolyline = null;
                if (multiPointTotalTooltip) map.removeLayer(multiPointTotalTooltip);
                multiPointTotalTooltip = null;
                // Clear other related layers/tooltips if you add them

                if (filtersPanelVisible) toggleFilterPanel();
            } else {
                measureToolBtn.title = "Measure Distance";
                finalizeMultiPointMeasure(false); // Clean up without making permanent
            }
        }

        function handleMultiPointMeasureClick(e) {
            if (!isMeasuringMultiPoint || !currentlyLoadedMapId) return;
            if (e.originalEvent.target.closest('.leaflet-control')) return;

            const clickPoint = e.latlng;
            multiPointPath.push(clickPoint);

            // Add a vertex marker
            const vertexMarker = L.circleMarker(clickPoint, {
                radius: 5,
                color: 'cyan', // Or your preferred color
                fillColor: '#0ff',
                fillOpacity: 0.7,
                interactive: false
            }).addTo(measurementLayerGroup);
            multiPointVertexMarkers.push(vertexMarker);

            // Update the polyline
            if (multiPointPolyline) {
                multiPointPolyline.setLatLngs(multiPointPath);
            } else if (multiPointPath.length >= 2) {
                multiPointPolyline = L.polyline(multiPointPath, {
                    color: 'yellow',
                    weight: 3,
                    dashArray: '5, 5',
                    interactive: false
                }).addTo(measurementLayerGroup);
            }

            updateMeasurementTooltips(); // New function to handle tooltips
        }

        function handleMultiPointMouseMove(e) {
            if (!isMeasuringMultiPoint || multiPointPath.length === 0 || !currentlyLoadedMapId) return;

            const currentMapInfo = findMapRecursive(mapData, currentlyLoadedMapId);
            const scalePx = currentMapInfo?.scalePixels;
            const scaleKm = currentMapInfo?.scaleKilometers;

            const lastFixedPoint = multiPointPath[multiPointPath.length - 1];
            const currentMousePos = e.latlng;

            if (temporaryMouseMoveLine) {
                measurementLayerGroup.removeLayer(temporaryMouseMoveLine);
            }
            temporaryMouseMoveLine = L.polyline([lastFixedPoint, currentMousePos], {
                color: 'lime',
                weight: 2,
                dashArray: '3, 3',
                interactive: false
            }).addTo(measurementLayerGroup);

            if (temporaryMouseMoveTooltip) {
                map.removeLayer(temporaryMouseMoveTooltip); // Or measurementLayerGroup.removeLayer
            }

            const pixelDistance = map.distance(lastFixedPoint, currentMousePos);
            let segmentDistanceString = `${pixelDistance.toFixed(0)} px`;
            if (scalePx && scaleKm) {
                const kmDistance = (pixelDistance / scalePx) * scaleKm;
                segmentDistanceString = `${kmDistance.toFixed(2)} km`;
            }

            temporaryMouseMoveTooltip = L.tooltip({
                permanent: true,
                direction: 'top',
                className: 'measure-tooltip',
                offset: L.point(0, -10)
            })
            .setLatLng(currentMousePos)
            .setContent(`Segment: ${segmentDistanceString}`)
            .addTo(map); // Add to map to follow mouse, or to measurementLayerGroup
        }

        function updateMeasurementTooltips() {
                         // Ensure the function doesn't run if not measuring or no path exists
                         if (!currentlyLoadedMapId || multiPointPath.length < 1) {
                             // Clean up any leftover tooltip if the path becomes empty
                             if (multiPointTotalTooltip) {
                                 map.removeLayer(multiPointTotalTooltip);
                                 multiPointTotalTooltip = null;
                             }
                             return;
                         }

                         // Get map scale information
                         const currentMapInfo = findMapRecursive(mapData, currentlyLoadedMapId);
                         const scalePx = currentMapInfo?.scalePixels;
                         // Assuming scaleKilometers in JSON truly represents kilometers for this calculation
                         const scaleKmValue = currentMapInfo?.scaleKilometers;
                         // Use 'km' as the unit name if scaleUnitName is not set or is generic,
                         // but prefer scaleUnitName if it's specific (e.g. "miles" and you adjusted paces accordingly)
                         const scaleUnitName = (currentMapInfo?.scaleUnitName && currentMapInfo.scaleUnitName !== 'units') ? currentMapInfo.scaleUnitName : 'km';

                         const hasValidScale = typeof scalePx === 'number' && scalePx > 0 &&
                                              typeof scaleKmValue === 'number' && scaleKmValue > 0;

                         // Calculate total pixel distance
                         let totalPixelDistance = 0;
                         if (multiPointPath.length >= 2) {
                             for (let i = 0; i < multiPointPath.length - 1; i++) {
                                 totalPixelDistance += map.distance(multiPointPath[i], multiPointPath[i + 1]);
                             }
                         }

                         // --- Build the Tooltip Content String ---
                         let tooltipContent = '';
                         let displayDistanceString = '';

                         if (hasValidScale) {
                             // Calculate distance in kilometers (or the unit defined by scaleKmValue)
                             const totalDistanceInKm = (totalPixelDistance / scalePx) * scaleKmValue;
                             displayDistanceString = `${totalDistanceInKm.toFixed(2)} ${scaleUnitName}`;

                             // --- Updated Pace Values in Kilometers per Day ---
                             const fastPaceKmPerDay = 48.28;
                             const normalPaceKmPerDay = 38.62;
                             const slowPaceKmPerDay = 28.97;
                             // ---

                             // Calculate days for each pace
                             const daysFastPace = (totalDistanceInKm / fastPaceKmPerDay).toFixed(1);
                             const daysNormalPace = (totalDistanceInKm / normalPaceKmPerDay).toFixed(1);
                             const daysSlowPace = (totalDistanceInKm / slowPaceKmPerDay).toFixed(1);

                             // Construct the multi-line tooltip content
                             tooltipContent = `Total ‚âà ${displayDistanceString}<br>Fast ‚âà ${daysFastPace} Day(s)<br>Normal ‚âà ${daysNormalPace} Day(s)<br>Slow ‚âà ${daysSlowPace} Day(s)`;

                         } else {
                             // Scale is unknown or distance is zero
                             if (totalPixelDistance > 0) {
                                 displayDistanceString = `${totalPixelDistance.toFixed(0)} pixels (Scale unknown)`;
                                 tooltipContent = `Total: ${displayDistanceString}<br>Days at Fast Pace: N/A<br>Days at Normal Pace: N/A<br>Days at Slow Pace: N/A`;
                             } else if (multiPointPath.length === 1) {
                                 displayDistanceString = "Start point";
                                 tooltipContent = displayDistanceString; // Only show "Start point"
                             } else {
                                 displayDistanceString = "0 pixels";
                                 tooltipContent = `Total: ${displayDistanceString}<br>Days at Fast Pace: N/A<br>Days at Normal Pace: N/A<br>Days at Slow Pace: N/A`;
                             }
                         }
                         // --- Tooltip Content String is now built ---

                         // Remove the previous total tooltip (if it exists)
                         if (multiPointTotalTooltip) {
                             map.removeLayer(multiPointTotalTooltip);
                         }

                         // Create and add the new total tooltip using the constructed content
                         if (multiPointPath.length > 0) {
                             multiPointTotalTooltip = L.tooltip({
                                 permanent: true,
                                 direction: 'right',
                                 className: 'measure-tooltip',
                                 offset: L.point(10, 0) // Position offset from the point
                             })
                             .setLatLng(multiPointPath[multiPointPath.length - 1]) // Position at the last point
                             .setContent(tooltipContent) // Use the full tooltipContent string
                             .addTo(map);
                         } else {
                             multiPointTotalTooltip = null; // Ensure it's null if path is empty
                         }
                     }

        function finalizeMultiPointMeasure(makePermanent = true) {
            if (!isMeasuringMultiPoint && !makePermanent) { // If called to just clean up
                measurementLayerGroup.clearLayers();
                if (multiPointPolyline) map.removeLayer(multiPointPolyline);
                if (multiPointTotalTooltip) map.removeLayer(multiPointTotalTooltip);
                if (temporaryMouseMoveLine) measurementLayerGroup.removeLayer(temporaryMouseMoveLine);
                if (temporaryMouseMoveTooltip) map.removeLayer(temporaryMouseMoveTooltip);
                multiPointPath = [];
                multiPointVertexMarkers = [];
                multiPointPolyline = null;
                multiPointTotalTooltip = null;
                temporaryMouseMoveLine = null;
                temporaryMouseMoveTooltip = null;
            }

            isMeasuringMultiPoint = false;
            map.off('click', handleMultiPointMeasureClick);
            map.off('mousemove', handleMultiPointMouseMove);
            map.off('dblclick', finalizeMultiPointMeasure);
            document.removeEventListener('keydown', handleMeasureKeyDown);
            mapElement.classList.remove('measuring-cursor');
            measureToolBtn.classList.remove('active');
            measureToolBtn.title = "Measure Distance";


            if (temporaryMouseMoveLine) {
                measurementLayerGroup.removeLayer(temporaryMouseMoveLine);
                temporaryMouseMoveLine = null;
            }
            if (temporaryMouseMoveTooltip) {
                map.removeLayer(temporaryMouseMoveTooltip);
                temporaryMouseMoveTooltip = null;
            }

            if (!makePermanent || multiPointPath.length < 2) {
                measurementLayerGroup.clearLayers();
                if (multiPointPolyline) map.removeLayer(multiPointPolyline);
                multiPointPolyline = null;
                if (multiPointTotalTooltip) map.removeLayer(multiPointTotalTooltip);
                multiPointTotalTooltip = null;
                multiPointPath = [];
                multiPointVertexMarkers = [];
            } else {
                // Path and markers are already on measurementLayerGroup.
                // Make the total tooltip permanent on the polyline itself.
                if (multiPointPolyline && multiPointTotalTooltip) {
                    // The multiPointTotalTooltip already has the full content
                    // from the last call to updateMeasurementTooltips.
                    // We just need to re-bind it or ensure it stays.
                    // For simplicity, let's ensure it uses the latest content if it was removed and re-added.
                    const finalContent = multiPointTotalTooltip.getContent(); // Get the already formatted content
                    map.removeLayer(multiPointTotalTooltip); // Remove the one that was following the mouse

                    multiPointPolyline.bindTooltip(finalContent, { // Use the captured finalContent
                        permanent: true,
                        direction: 'center',
                        className: 'measure-tooltip',
                        sticky: true // Make it sticky to the line
                    }).openTooltip();
                    // Ensure the individual vertex markers are cleared if they are not desired permanently
                    multiPointVertexMarkers.forEach(marker => measurementLayerGroup.removeLayer(marker));
                    multiPointVertexMarkers = [];
                }
            }
        }

        function handleMeasureKeyDown(e) {
            if (e.key === 'Escape' && isMeasuringMultiPoint) {
                e.preventDefault();
                finalizeMultiPointMeasure(false); // Cancel measurement
            }
        }

        measureToolBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleMeasurementTool(); // This should now call the multi-point version
        });

        // --- Inject Map Icon CSS ---
        function updateStyleWithMapIcon() {
            const style = document.createElement('style');
            style.textContent = `
                #toggle-filters-btn::before {
                    content: ''; display: inline-block; width: 16px; height: 16px;
                    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='currentColor'%3E%3Cpath d='M15,19L9,16.89V5L15,7.11V19M20.5,3C20.44,3 20.39,3 20.34,3L15,5.1L9,3L3.36,4.9C3.15,4.97 3,5.15 3,5.38V20.5A0.5,0.5 0 0,0 3.5,21C3.55,21 3.61,21 3.66,20.97L9,18.9L15,21L20.64,19.1C20.85,19 21,18.85 21,18.62V3.5A0.5,0.5 0 0,0 20.5,3Z'/%3E%3C/svg%3E");
                    background-repeat: no-repeat; background-position: center;
                    margin-top: 7px; opacity: 0.6;
                }
                #toggle-filters-btn.active::before { opacity: 1; }
            `;
            document.head.appendChild(style);
        }
        updateStyleWithMapIcon(); // Inject CSS immediately

        // --- NEW: Data Loading Functions ---
        async function loadMapData() {
            try {
                // Show loading indicator for data fetch
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'flex';
                    const progressBar = loadingIndicator.querySelector('.progress-bar');
                    const loadingText = loadingIndicator.querySelector('.loading-text');
                    if (progressBar) progressBar.style.width = '10%'; // Initial progress
                    if (loadingText) loadingText.textContent = "Loading Map Index...";
                }

                const response = await fetch('maps/maps.json');
                if (!response.ok) throw new Error(`Failed to load maps.json: ${response.statusText}`);
                const maps = await response.json();

                if (loadingIndicator && loadingIndicator.querySelector('.progress-bar')) {
                    loadingIndicator.querySelector('.progress-bar').style.width = '30%';
                    loadingIndicator.querySelector('.loading-text').textContent = "Processing Map Data...";
                }

                // Process map data (fetch children, etc.)
                mapData = await processMapData(maps);

                if (loadingIndicator && loadingIndicator.querySelector('.progress-bar')) {
                    loadingIndicator.querySelector('.progress-bar').style.width = '100%';
                }

                // Hide loading indicator *before* initializing the rest of the app
                if (loadingIndicator) {
                     setTimeout(() => { loadingIndicator.style.display = 'none'; }, 200); // Short delay
                }

                // --- Keyboard Shortcut Logic ---
                const keyboardHelpModal = document.getElementById('keyboard-help-modal');
                const closeKeyboardHelpBtn = document.getElementById('close-keyboard-help-btn');

                if (closeKeyboardHelpBtn) { // Check if modal exists
                    closeKeyboardHelpBtn.addEventListener('click', () => {
                        if (keyboardHelpModal) keyboardHelpModal.style.display = 'none';
                    });
                }

                function isInputFocused() {
                    const activeElement = document.activeElement;
                    return activeElement && (activeElement.tagName === 'INPUT' ||
                           activeElement.tagName === 'TEXTAREA' ||
                           activeElement.isContentEditable);
                }

                document.addEventListener('keydown', function(e) {
                    // Handle modal display first
                    if (e.key === '?') {
                        if (!isInputFocused()) { // Don't trigger if typing '?' in search
                            e.preventDefault();
                            if (keyboardHelpModal) {
                                keyboardHelpModal.style.display = keyboardHelpModal.style.display === 'none' ? 'flex' : 'none';
                            }
                            return;
                        }
                    }

                    // If help modal is open, Esc should close it
                    if (keyboardHelpModal && keyboardHelpModal.style.display !== 'none' && e.key === 'Escape') {
                        e.preventDefault();
                        keyboardHelpModal.style.display = 'none';
                        return;
                    }

                    // Handle Escape for other UI elements
                    if (e.key === 'Escape') {
                        if (map.getPanes().popupPane.firstChild) { // Check if a Leaflet popup is open
                            map.closePopup();
                            e.preventDefault();
                        } else if (filtersPanelVisible) {
                            toggleFilterPanel(); // Your existing function
                            e.preventDefault();
                        } else if (searchResultsContainer.style.display === 'block') {
                            searchResultsContainer.style.display = 'none';
                            if (poiSearchInput) poiSearchInput.blur();
                            e.preventDefault();
                        } else if (isMeasuringMultiPoint) { // For the new measurement tool
                            finalizeMultiPointMeasure(false); // Cancel measurement
                            e.preventDefault();
                        }
                        // Add other Escape handlers here if needed
                        return; // Processed Escape, no further checks for this key press
                    }

                    // For other shortcuts, don't act if an input is focused or help modal is open
                    if (isInputFocused() || (keyboardHelpModal && keyboardHelpModal.style.display !== 'none')) {
                        return;
                    }

                    // Non-input-focused shortcuts
                    switch (e.key.toLowerCase()) {
                        case '+':
                        case '=':
                            if (map) map.zoomIn();
                            e.preventDefault();
                            break;
                        case '-':
                            if (map) map.zoomOut();
                            e.preventDefault();
                            break;
                        case 's':
                            if (toggleBtn) toggleBtn.click(); // Toggle Sidebar
                            e.preventDefault();
                            break;
                        case 't':
                            if (themeToggle) themeToggle.click(); // Toggle Theme
                            e.preventDefault();
                            break;
                        case 'm':
                            if (measureToolBtn && measureToolBtn.style.display !== 'none') {
                                measureToolBtn.click();
                                e.preventDefault();
                            }
                            break;
                        case 'h': // Toggle Markers/Regions
                            if (toggleMarkersBtn && toggleMarkersBtn.style.display !== 'none') {
                                toggleMarkersBtn.click();
                                e.preventDefault();
                            }
                            break;
                        case 'f': // Toggle Filters Panel
                            if (toggleFiltersBtn && toggleFiltersBtn.style.display !== 'none') {
                                toggleFiltersBtn.click();
                                e.preventDefault();
                            }
                            break;
                        case '/':
                            if (searchControlContainer && searchControlContainer.style.display !== 'none' && poiSearchInput) {
                                poiSearchInput.focus();
                                e.preventDefault();
                            }
                            break;
                    }

                    // Example for Ctrl/Cmd + F (if you want to override browser find for your search)
                    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
                        if (searchControlContainer && searchControlContainer.style.display !== 'none' && poiSearchInput) {
                            poiSearchInput.focus();
                            e.preventDefault(); // Prevent browser's default find
                        }
                    }
                });


                    // Now that data is loaded, initialize the application
                    initializeApp();

            } catch (error) {
                console.error('Error loading map data:', error);
                if (loadingIndicator) {
                    const loadingText = loadingIndicator.querySelector('.loading-text');
                    const spinner = loadingIndicator.querySelector('.spinner');
                    const progressContainer = loadingIndicator.querySelector('.progress-container');
                    if (loadingText) loadingText.textContent = "Error loading map data. Please check console.";
                    if (spinner) spinner.style.display = 'none';
                    if (progressContainer) progressContainer.style.display = 'none';
                    // Keep indicator visible for a bit longer on error
                    // setTimeout(() => { loadingIndicator.style.display = 'none'; }, 5000);
                }
                // Optionally display an error message to the user in the UI
                sidebar.innerHTML = '<h2>Error</h2><p>Could not load map data. Please try refreshing the page or check the console for details.</p>';
            }
        }

        // --- NEW Recursive Helper Function ---
async function processChild(childId, level = 0) {
    // Base case for recursion depth limit or invalid ID
    if (level > 5 || !childId || typeof childId !== 'string') {
        console.warn(`Skipping child processing for: ${childId} at level ${level}`);
        // Return a placeholder that populateSidebar can handle as coming soon/error
        return { id: childId, name: String(childId || 'Invalid Child'), status: 'coming-soon', error: true };
    }

    console.log(`${'-'.repeat(level * 2)} Processing child: ${childId} at level ${level}`);
    try {
        // Optional: Handle known 'coming-soon' IDs directly if needed
        // if (childId === 'some-known-coming-soon-id') {
        //     return { id: childId, name: 'Known Coming Soon Item', status: 'coming-soon' };
        // }

        // Fetch the child map data
        const response = await fetch(`maps/${childId}.json`);

        if (response.ok) {
            let childData = await response.json();
            console.log(`${'-'.repeat(level * 2)} --> Fetched data for ${childId}:`, childData);

            // *** RECURSIVE STEP ***
            // Check if the fetched child ALSO has children that are string IDs
            if (childData.children && Array.isArray(childData.children) && childData.children.length > 0 && typeof childData.children[0] === 'string') {
                console.log(`${'-'.repeat(level * 2)} --> Child ${childId} has children to process recursively:`, childData.children);
                const subChildIds = childData.children;
                childData.children = []; // Prepare for processed sub-children
                const subChildPromises = subChildIds.map(subId => processChild(subId, level + 1)); // Recursive call
                childData.children = await Promise.all(subChildPromises);
            }
            // *** END RECURSIVE STEP ***

            // Ensure basic properties exist if fetched data is incomplete
            childData.id = childData.id || childId;
            childData.name = childData.name || childId; // Use ID as fallback name

            return childData; // Return the processed child data

        } else if (response.status === 404) {
             console.warn(`Child map file not found: maps/${childId}.json - Marking as 'coming-soon'`);
             // File not found, treat as coming soon
             return { id: childId, name: childId, status: 'coming-soon', error: 'not found' };
        } else {
            console.warn(`Failed to load child map: ${childId} (${response.statusText}) - Marking as 'coming-soon'`);
            // Other fetch error, treat as coming soon
            return { id: childId, name: childId, status: 'coming-soon', error: `Workspace failed (${response.status})` };
        }
    } catch (error) {
        console.error(`Error processing child ${childId}:`, error);
        // Error during fetch/parse, treat as coming soon
        return { id: childId, name: childId, status: 'coming-soon', error: error.message };
    }
}
            async function processMapData(maps) {
                const processedMaps = [];
                console.log("Starting processMapData with:", maps);

                for (let map of maps) {
                    if (map.children && Array.isArray(map.children) && map.children.length > 0 && typeof map.children[0] === 'string') {
                        const childIds = map.children;
                        console.log(`Processing top-level children for ${map.id || map.name}:`, childIds);
                        map.children = [];
                        const childPromises = childIds.map(childId => processChild(childId, 1));
                        map.children = await Promise.all(childPromises);
                    }
                    processedMaps.push(map);
                }
                console.log("Finished processing map data. Result:", processedMaps);
                return processedMaps;
            }

            function initializeApp() {
            const urlParams = getUrlParameters();

            // Handle embedded view - hide UI elements
            if (urlParams.embed === 'true' || urlParams.hideUI === 'true') {
                console.log("Embedded view detected, hiding UI elements.");
                const wipPopup = document.getElementById('wip-popup');
                if (wipPopup) wipPopup.style.display = 'none';

                const bottomLinkBar = document.getElementById('bottom-link-bar');
                if (bottomLinkBar) bottomLinkBar.style.display = 'none';

                if (toggleBlurbBtn) toggleBlurbBtn.style.display = 'none';
                if (mapBlurbElement) mapBlurbElement.classList.remove('visible');

                // Hide the sidebar toggle button
                const toggleSidebarBtn = document.getElementById('toggle-sidebar-btn');
                if (toggleSidebarBtn) toggleSidebarBtn.style.display = 'none';

                // --- ADD THIS LINE ---
                // Hide the sound toggle button
                const toggleSoundBtn = document.getElementById('toggle-sound-btn');
                if (toggleSoundBtn) toggleSoundBtn.style.display = 'none';
                // --- END ADDED LINE ---

                // Force sidebar to be collapsed initially
                setSidebarState('c', false);

                // Optional: Add a class to the body for additional styling
                document.body.classList.add('embedded-view');

                if (window.innerWidth <= 600) { // Or your preferred mobile breakpoint
                    const wipPopup = document.getElementById('wip-popup');
                    if (wipPopup) {
                        setTimeout(() => {
                            wipPopup.classList.add('fade-out');
                        }, 7000); // 7 seconds delay
                    }
                }
            }
            // --- END: Embedding Check ---

            console.log("Initializing App with loaded mapData:", mapData);

            // Populate sidebar now that mapData is ready
            populateSidebar(mapListElement, mapData);

            // Determine initial map and sidebar state
            const { mapId: initialMapIdFromHash, sidebarState: initialSidebarState } = parseHash();
            let mapIdToLoad = initialMapIdFromHash;
            let mapToLoadData = null;

            // If hash points to a valid map, try to load it
            if (mapIdToLoad) {
                mapToLoadData = findMapRecursive(mapData, mapIdToLoad);
            }

            // If hash map is invalid/missing/coming-soon, or no hash map, find the default
            if (!mapToLoadData || mapToLoadData.status === 'coming-soon') {
                console.log("Initial hash map not loadable or not specified, finding default.");
                mapIdToLoad = findFirstLoadableIdRecursive(mapData);
                mapToLoadData = findMapRecursive(mapData, mapIdToLoad);
            }

            console.log("Final Map to Load:", mapIdToLoad, "Initial Sidebar State:", initialSidebarState);

            setSidebarState(initialSidebarState, false); // Set sidebar state without updating hash yet

            // Hide controls initially (loadMap will show them if needed)
            toggleMarkersBtn.style.display = 'none';
            toggleFiltersBtn.style.display = 'none';
            measureToolBtn.style.display = 'none';
            // toggleSoundBtn is handled above for embed mode, otherwise shown by initializeSoundState
            searchControlContainer.style.display = 'none';
            searchResultsContainer.style.display = 'none';
            poiFilterContainer.classList.remove('visible');

            // Load the determined map
            if (mapIdToLoad && mapToLoadData && mapToLoadData.status !== 'coming-soon') {
                 markersVisible = true; // Default to visible
                 regionsVisible = true;  // <--- ADD THIS LINE TO ENSURE REGIONS ARE ALSO VISIBLE BY DEFAULT
                 loadMap(mapIdToLoad, false); // Load map, don't update hash yet
            } else {
                console.error("No loadable map data found for initialization.");
                sidebar.innerHTML = '<h2>Select Map</h2><p>No maps available.</p>';
                mapBlurbElement.classList.remove('visible');
                // Ensure loading indicator is hidden if it somehow wasn't
                if (loadingIndicator) loadingIndicator.style.display = 'none';
                // Set a clean hash state
                history.replaceState(null, '', generateHash('', initialSidebarState));
                return; // Stop initialization
            }

            // Initialize sound state (after theme is applied)
            // This will now check for embed mode internally
            initializeSoundState();

            // Set the correct initial history state *after* loading the map
            const correctInitialHash = generateHash(currentlyLoadedMapId, currentSidebarState);
            const currentSearch = window.location.search; // Get current search params like ?embed=true
            const finalUrl = `${currentSearch}${correctInitialHash}`;
            console.log("Replacing initial history state with:", finalUrl);
            history.replaceState({ mapId: currentlyLoadedMapId, sidebarState: currentSidebarState }, mapToLoadData?.name || '', finalUrl);
        }

        // --- Start the application by loading data ---
        loadMapData();

    </script>

    <div id="wip-popup">
        <p>This site is a Work in Progress</p>
        <p>Markers, Names, and Map May Not Be Acurate</p>
    </div>
    <div id="keyboard-help-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); z-index: 2000; align-items: center; justify-content: center;">
        <div style="background-color: var(--bg-secondary); color: var(--text-primary); padding: 25px; border-radius: 8px; width: 90%; max-width: 500px; box-shadow: 0 5px 20px var(--shadow-color); position: relative;">
            <button id="close-keyboard-help-btn" style="position: absolute; top: 10px; right: 10px; background: none; border: none; font-size: 1.5rem; color: var(--text-primary); cursor: pointer;">&times;</button>
            <h2 style="margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 10px;">Keyboard Shortcuts</h2>
            <ul style="list-style: none; padding: 0;">
                <li style="margin-bottom: 8px;"><kbd>+</kbd> / <kbd>=</kbd> : Zoom In</li>
                <li style="margin-bottom: 8px;"><kbd>-</kbd> : Zoom Out</li>
                <li style="margin-bottom: 8px;"><kbd>s</kbd> : Toggle Sidebar</li>
                <li style="margin-bottom: 8px;"><kbd>t</kbd> : Toggle Theme</li>
                <li style="margin-bottom: 8px;"><kbd>m</kbd> : Toggle Measurement Tool</li>
                <li style="margin-bottom: 8px;"><kbd>h</kbd> : Toggle Markers/Regions</li>
                <li style="margin-bottom: 8px;"><kbd>f</kbd> : Toggle Filters Panel</li>
                <li style="margin-bottom: 8px;"><kbd>/</kbd> : Focus Search Bar</li>
                <li style="margin-bottom: 8px;"><kbd>Esc</kbd> : Close Popup / Panel / Cancel Measurement</li>
                <li style="margin-bottom: 8px;"><kbd>?</kbd> : Show/Hide this Help</li>
                </ul>
        </div>
    </div>

</body>
</html>