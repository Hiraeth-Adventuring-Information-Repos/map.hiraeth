<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Editor Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
    <style>
        /* --- Oldschool Style --- */
        body {
            font-family: "MS Sans Serif", "Tahoma", "Verdana", sans-serif;
            margin: 0; padding: 0; display: flex; flex-direction: column;
            height: 100vh; background-color: #c0c0c0; color: #000000;
            font-size: 12px;
        }
        .controls {
            padding: 8px 10px; background-color: #c0c0c0;
            border-bottom: 2px solid #808080; display: flex; flex-wrap: wrap;
            gap: 8px; align-items: flex-start;
        }
        .mode-selector {
            display: flex; margin-bottom: 8px;
        }
        .mode-tab {
            padding: 4px 10px; cursor: pointer; background-color: #c0c0c0;
            border: 1px solid #808080; border-left-color: #ffffff;
            border-top-color: #ffffff; font-weight: bold;
            box-shadow: inset -1px -1px 0px #404040, inset 1px 1px 0px #dfdfdf;
        }
        .mode-tab.active {
            background-color: #a0a0a0;
            border: 1px solid #808080; border-right-color: #ffffff;
            border-bottom-color: #ffffff;
            box-shadow: inset 1px 1px 0px #404040, inset -1px -1px 0px #dfdfdf;
        }
        .control-group {
            display: flex; flex-direction: column; gap: 4px; padding: 6px;
            border: 1px solid #808080; border-right-color: #ffffff;
            border-bottom-color: #ffffff; background-color: #c0c0c0;
            box-shadow: inset 1px 1px 0px #404040, inset -1px -1px 0px #dfdfdf;
        }
        .control-row { display: flex; align-items: center; gap: 5px; width: 100%; }
        .controls label {
            font-weight: normal; white-space: nowrap; font-size: 1em;
            min-width: 75px; text-align: right; padding-right: 5px;
        }
        .controls input[type="text"], .controls select, .controls textarea, .controls input[type="number"], .controls input[type="color"], .controls input[type="file"] {
            padding: 3px 5px; border: 1px solid #808080; background-color: #ffffff;
            color: #000000; font-family: inherit; font-size: 1em; flex-grow: 1;
            box-shadow: inset 1px 1px 1px #404040; box-sizing: border-box;
        }
        .controls input[type="file"] {
            padding: 2px;
        }
        .controls input[type="checkbox"] {
            appearance: none; -webkit-appearance: none;
            width: 13px; height: 13px;
            background-color: #ffffff;
            border: 1px solid #808080;
            box-shadow: inset 1px 1px 1px #404040;
            margin: 0;
            position: relative;
            cursor: pointer;
            flex-shrink: 0;
        }
        .controls input[type="checkbox"]:checked::after {
            content: 'âœ”';
            position: absolute;
            top: -2px; left: 1px;
            font-size: 12px;
            color: #000000;
        }
        .controls input[type="color"] {
            width: 40px; height: 24px; padding: 0; cursor: pointer;
        }
        .controls input[type="number"] {
            width: 60px;
        }
        .controls select {
             appearance: none;
             background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
             background-repeat: no-repeat; background-position: right 5px top 50%;
             background-size: .65em auto; padding-right: 1.5em;
        }
        #fileLoader { min-width: 200px; }
        #pointDescription, #regionDescription, #mapBlurb, #lineDescription { height: 4.5em; resize: vertical; }
        .controls button, .output-buttons button, .summary-actions button, .json-modal-copy, .json-modal-close {
            padding: 4px 10px; cursor: pointer; color: #000000;
            border: 1px solid #808080; border-left-color: #ffffff;
            border-top-color: #ffffff; background-color: #c0c0c0;
            font-size: 1em;
            box-shadow: inset -1px -1px 0px #404040, inset 1px 1px 0px #dfdfdf;
            text-align: center;
        }
        .controls button:active, .output-buttons button:active, .summary-actions button:active, .json-modal-copy:active, .json-modal-close:active {
             border: 1px solid #808080; border-right-color: #ffffff;
             border-bottom-color: #ffffff;
             box-shadow: inset 1px 1px 0px #404040, inset -1px -1px 0px #dfdfdf;
             background-color: #b0b0b0;
        }
        .controls button:disabled, .output-buttons button:disabled, .summary-actions button:disabled {
            color: #808080; background-color: #c0c0c0; cursor: default;
            box-shadow: none; border: 1px solid #a0a0a0;
        }
        .hidden { display: none !important; }
        #map {
            flex-grow: 1; width: 100%; background-color: #a0a0a0;
            border-top: 2px solid #808080; border-bottom: 2px solid #808080;
        }
        #map.region-creation-mode, #map.vertex-adding-mode, #map.vertex-editing-mode, 
        #map.line-creation-mode, #map.line-vertex-editing-mode { cursor: crosshair !important; } 

        .bottom-section {
             display: flex; flex-direction: column;
             border-top: 2px solid #808080; background-color: #c0c0c0;
        }
        .info-area { display: flex; padding: 8px 10px; gap: 10px; align-items: flex-start; }
        .left-info { display: flex; flex-direction: column; gap: 6px; align-items: flex-start; min-width: 180px; }
        .coords-section { display: flex; align-items: center; gap: 8px; }
        #coords-display {
            font-weight: normal; font-family: "Courier New", monospace; background-color: #ffffff;
            padding: 3px 6px; border: 1px solid #808080; box-shadow: inset 1px 1px 1px #404040;
            min-width: 90px; text-align: center;
        }
        .instructions { font-size: 0.9em; color: #404040; }
        #status { font-style: normal; color: #000000; font-size: 0.9em; margin-top: 4px; padding: 3px; border: 1px solid transparent; }
        #status.error { color: #ff0000; font-weight: bold; border: 1px dotted #ff0000; }
        #status.success { color: #008000; font-weight: bold; border: 1px dotted #008000; }
        .edit-selection { margin-top: 8px; }
        .edit-selection label { font-weight: normal; font-size: 1em; margin-bottom: 3px; display: block; text-align: left; }
        #editPointSelect, #editRegionSelect, #editLineSelect { width: 100%; } 
        .map-summary {
            flex-grow: 1; display: flex; flex-direction: column; gap: 6px;
            padding: 6px; border: 1px solid #808080; border-right-color: #ffffff;
            border-bottom-color: #ffffff; background-color: #c0c0c0;
            box-shadow: inset 1px 1px 0px #404040, inset -1px -1px 0px #dfdfdf;
        }
        .map-summary h3 { margin: 0 0 5px 0; font-size: 1.1em; }
        .summary-stats p { margin: 2px 0; font-size: 1em; }
        .summary-stats span { font-weight: bold; }
        .summary-actions { display: flex; gap: 8px; margin-top: 8px; }
        .summary-actions button { font-size: 0.9em; }

        .leaflet-popup-content-wrapper { background: #f0f0f0; color: #000000; border: 1px solid #808080; border-radius: 0; box-shadow: 2px 2px 3px rgba(0,0,0,0.3); }
        .leaflet-popup-content { font-family: inherit; font-size: 1em; margin: 8px 10px; }
        .leaflet-popup-tip-container { width: 20px; height: 10px; }
        .leaflet-popup-tip { background: #f0f0f0; border: 1px solid #808080; border-left: none; border-top: none; box-shadow: none; }
        .leaflet-marker-icon { filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.5)); }
        
        .vertex-marker, .line-vertex-marker { 
            background-color: rgba(255, 0, 0, 0.7);
            border: 1px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            cursor: grab;
        }
        .vertex-marker:active, .line-vertex-marker:active { cursor: grabbing; }
        .new-vertex-marker, .new-line-vertex-marker { 
            background-color: rgba(0, 255, 0, 0.7);
            border: 1px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
        }
        .vertex-marker.active, .line-vertex-marker.active {
            background-color: #00ffff; /* Cyan */
            border: 2px solid #0000ff; /* Blue */
            box-sizing: border-box;
        }


        .json-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6); display: flex;
            justify-content: center; align-items: center; z-index: 1000;
            padding: 20px; box-sizing: border-box;
        }
        .json-modal-content {
            background-color: #c0c0c0; border: 1px solid #808080;
            border-left-color: #ffffff; border-top-color: #ffffff;
            box-shadow: inset -1px -1px 0px #404040, inset 1px 1px 0px #dfdfdf, 3px 3px 5px rgba(0,0,0,0.3);
            width: 90%; max-width: 800px; max-height: 90vh;
            display: flex; flex-direction: column; padding: 10px;
        }
        .json-modal-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #808080;
        }
        .json-modal-header h3 { margin: 0; font-size: 1.1em; font-weight: bold; }
        .json-modal-close { font-size: 1.4em; font-weight: bold; line-height: 1; padding: 0px 6px 2px 6px; }
        .json-modal-textarea {
            width: 100%; flex-grow: 1; min-height: 200px;
            font-family: "Courier New", monospace; font-size: 0.95em;
            border: 1px solid #808080; background-color: #ffffff; color: #000000;
            padding: 10px; box-sizing: border-box; margin-bottom: 10px;
            resize: none; box-shadow: inset 1px 1px 1px #404040;
            white-space: pre; overflow: auto;
        }
        .json-modal-copy { align-self: flex-end; }

        /* --- Custom Properties Styling --- */
        .control-group-properties {
            padding: 6px;
            margin: 4px 0;
            border: 1px solid #808080;
            background-color: #dfdfdf;
            box-shadow: inset 1px 1px 1px #404040;
            max-height: 120px; /* Limit height and make scrollable */
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .property-row {
            display: flex;
            gap: 5px;
            align-items: center;
        }
        .property-row input[type="text"] {
            flex-grow: 1;
            width: 40%; /* Give them a basis to grow from */
        }
        .property-row .remove-property-btn {
            padding: 2px 6px;
            font-size: 1em;
            line-height: 1;
            flex-shrink: 0;
            font-weight: bold;
        }
        .control-group-properties > label {
            font-weight: bold;
            margin-bottom: 4px;
            display: block;
            text-align: left;
        }
        /* --- End Custom Properties Styling --- */
    </style>
</head>
<body>

    <div class="controls">
        <div class="control-group">
            <div class="mode-selector">
                <div class="mode-tab active" data-mode="points">Points</div>
                <div class="mode-tab" data-mode="regions">Regions</div>
                <div class="mode-tab" data-mode="lines">Lines</div>
            </div>
            <div class="control-row">
                 <label for="jsonFileInput">Load JSON File:</label>
                 <input type="file" id="jsonFileInput" accept=".json">
            </div>
            <div class="control-row">
                <label for="subMapSelect">Select Map:</label>
                <select id="subMapSelect" disabled>
                    <option value="">-- Load a file first --</option>
                </select>
            </div>
            <div class="control-row">
                <button id="loadSubMapBtn" disabled>Load Selected Map</button>
            </div>
             <div class="control-row">
                <label for="mapBlurb">Map Blurb:</label>
                <textarea id="mapBlurb" placeholder="Brief description (HTML allowed)"></textarea>
            </div>
             <div class="control-row">
                <label for="scalePixels">Scale (Pixels):</label>
                <input type="number" id="scalePixels" value="3" min="1">
            </div>
            <div class="control-row">
                <label for="scaleUnits">Scale (Units):</label>
                <input type="number" id="scaleUnits" value="1" min="0.1" step="0.1">
            </div>
            <div class="control-row">
                 <button id="exportMapDataBtn" disabled>View/Export All Data (JSON)</button>
            </div>
        </div>

        <div class="control-group point-controls">
            <div class="control-row">
                <label for="pointName">Point Name:</label>
                <input type="text" id="pointName" placeholder="Click map or select point">
            </div>
            <div class="control-row">
                <label for="pointPronunciation">Pronunciation:</label>
                <input type="text" id="pointPronunciation" placeholder="e.g., (heer-AHTH) (Optional)">
            </div>
            <div class="control-row">
                <label for="poiTypeSelect">Type:</label>
                <select id="poiTypeSelect">
                    <option value="">--Select Type--</option>
                </select>
            </div>
            <div class="control-row">
                <label for="pointDescription">Description:</label>
                <textarea id="pointDescription"></textarea>
            </div>
            <div class="control-row">
                <label for="pointWikiLink">Wiki Link:</label>
                <input type="text" id="pointWikiLink" placeholder="Optional URL">
            </div>
            <div class="control-group-properties" id="point-properties-container">
                <label>Custom Properties:</label>
                <!-- Dynamic property rows will be inserted here -->
            </div>
            <div class="control-row">
                <button id="addPointPropertyBtn">Add Property</button>
            </div>
            <div class="control-row">
                <button id="addPointBtn" disabled>Add New Point</button>
                <button id="savePointChangesBtn" class="hidden">Save Changes</button>
                <button id="cancelPointEditBtn" class="hidden">Cancel Edit</button>
                <button id="clearPointsBtn" disabled>Clear All Points</button>
            </div>
        </div>

        <div class="control-group region-controls hidden">
            <div class="control-row">
                <label for="regionName">Region Name:</label>
                <input type="text" id="regionName" placeholder="Enter region name">
            </div>
            <div class="control-row">
                <label for="regionPronunciation">Pronunciation:</label>
                <input type="text" id="regionPronunciation" placeholder="e.g., (heer-AHTH) (Optional)">
            </div>
            <div class="control-row">
                <label for="regionTypeSelect">Category (Type):</label>
                <select id="regionTypeSelect">
                    <option value="">--Select Type--</option>
                </select>
            </div>
            <div class="control-row">
                <label for="regionValueInput">Sub-Category (Value):</label>
                <input type="text" id="regionValueInput" list="regionValueOptions" placeholder="Type or select..." disabled>
                <datalist id="regionValueOptions"></datalist>
            </div>
            <div class="control-row">
                <label for="regionColor">Border Color:</label>
                <input type="color" id="regionColor" value="#3388ff">
            </div>
            <div class="control-row">
                <label for="regionFillColor">Fill Color:</label>
                <input type="color" id="regionFillColor" value="#3388ff">
            </div>
            <div class="control-row">
                <label for="regionOpacity">Fill Opacity:</label>
                <input type="number" id="regionOpacity" min="0.0" max="1.0" step="0.05" value="0.2">
            </div>
            <div class="control-row">
                <label for="regionDescription">Description:</label>
                <textarea id="regionDescription"></textarea>
            </div>
            <div class="control-row">
                <label for="regionWikiLink">Wiki Link:</label>
                <input type="text" id="regionWikiLink" placeholder="Optional URL">
            </div>
            <div class="control-group-properties" id="region-properties-container">
                <label>Custom Properties:</label>
                <!-- Dynamic property rows will be inserted here -->
            </div>
            <div class="control-row">
                <button id="addRegionPropertyBtn">Add Property</button>
            </div>
            <div class="control-row">
                <button id="startRegionBtn" disabled>Start Region</button>
                <button id="finishRegionBtn" class="hidden">Finish Region</button>
                <button id="cancelRegionBtn" class="hidden">Cancel</button>
                <button id="clearRegionsBtn" disabled>Clear All Regions</button>
            </div>
            <div class="control-row">
                <button id="saveRegionChangesBtn" class="hidden">Save Changes</button>
                <button id="addVerticesBtn" class="hidden">Add Vertices</button>
                <button id="editVerticesBtn" class="hidden">Edit Vertices</button>
                <button id="cancelRegionEditBtn" class="hidden">Cancel Edit</button>
            </div>
            <div class="control-row">
                 <label for="showAllRegionsToggle">Show Others:</label>
                 <input type="checkbox" id="showAllRegionsToggle">
                 <span style="font-size: 0.9em; flex-grow: 1; text-align: left;">Show other regions while editing</span>
            </div>
        </div>

        <div class="control-group line-controls hidden">
            <div class="control-row">
                <label for="lineName">Line Name:</label>
                <input type="text" id="lineName" placeholder="Enter line name (optional)">
            </div>
            <div class="control-row">
                <label for="linePronunciation">Pronunciation:</label>
                <input type="text" id="linePronunciation" placeholder="e.g., (heer-AHTH) (Optional)">
            </div>
            <div class="control-row">
                <label for="lineTypeSelect">Type:</label>
                <select id="lineTypeSelect">
                    <option value="">--Select Type--</option>
                    <option value="highway">Highway</option>
                    <option value="main_road">Main Road</option>
                    <option value="street">Street</option>
                    <option value="path">Path</option>
                    <option value="track">Track</option>
                    <option value="river">River</option>
                    <option value="stream">Stream</option>
                    <option value="cliff">Cliff Edge</option>
                    <option value="border">Border</option>
                    <option value="other">Other</option>
                </select>
            </div>
            <div class="control-row">
                <label for="lineColor">Line Color:</label>
                <input type="color" id="lineColor" value="#808080">
            </div>
            <div class="control-row">
                <label for="lineWeight">Line Weight:</label>
                <input type="number" id="lineWeight" min="1" max="20" step="1" value="3">
            </div>
            <div class="control-row">
                <label for="lineDashArray">Dash Array:</label>
                <input type="text" id="lineDashArray" placeholder="e.g., 5, 5 (optional)">
            </div>
            <div class="control-row">
                <label for="lineDescription">Description:</label>
                <textarea id="lineDescription"></textarea>
            </div>
            <div class="control-row">
                <label for="lineWikiLink">Wiki Link:</label>
                <input type="text" id="lineWikiLink" placeholder="Optional URL">
            </div>
            <div class="control-group-properties" id="line-properties-container">
                <label>Custom Properties:</label>
                <!-- Dynamic property rows will be inserted here -->
            </div>
            <div class="control-row">
                <button id="addLinePropertyBtn">Add Property</button>
            </div>
            <div class="control-row">
                <button id="startLineBtn" disabled>Start Line</button>
                <button id="finishLineBtn" class="hidden">Finish Line</button>
                <button id="cancelLineBtn" class="hidden">Cancel</button>
                <button id="clearLinesBtn" disabled>Clear All Lines</button>
            </div>
            <div class="control-row">
                <button id="saveLineChangesBtn" class="hidden">Save Changes</button>
                <button id="addLineVerticesBtn" class="hidden">Add Vertices</button>
                <button id="editLineVerticesBtn" class="hidden">Edit Vertices</button>
                <button id="cancelLineEditBtn" class="hidden">Cancel Edit</button>
            </div>
        </div>
        <span id="status">Load a JSON file to begin.</span>
    </div>

    <div id="map"></div>

    <div class="bottom-section">
        <div class="info-area">
            <div class="left-info">
                <div class="point-info">
                    <span class="instructions">Click map for new coords or drag existing:</span>
                    <div class="coords-section">
                        <span id="coords-display">[Y, X]</span>
                    </div>
                    <div class="edit-selection">
                        <label for="editPointSelect">Edit Existing Point:</label>
                        <select id="editPointSelect">
                            <option value="">--Select Point to Edit--</option>
                        </select>
                    </div>
                </div>
                <div class="region-info hidden">
                    <span class="instructions">Click map to place vertices:</span>
                    <div class="coords-section">
                        <span id="region-vertices-count">0 vertices</span>
                    </div>
                    <div class="edit-selection">
                        <label for="editRegionSelect">Edit Existing Region:</label>
                        <select id="editRegionSelect">
                            <option value="">--Select Region to Edit--</option>
                        </select>
                    </div>
                </div>
                <div class="line-info hidden">
                    <span class="instructions">Click map to place line vertices:</span>
                    <div class="coords-section">
                        <span id="line-vertices-count">0 vertices</span>
                    </div>
                    <div class="edit-selection">
                        <label for="editLineSelect">Edit Existing Line:</label>
                        <select id="editLineSelect">
                            <option value="">--Select Line to Edit--</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="map-summary">
                <h3>Map Data Summary</h3>
                <div class="summary-stats">
                    <p>Points: <span id="points-count">0</span></p>
                    <p>Regions: <span id="regions-count">0</span></p>
                    <p>Lines: <span id="lines-count">0</span></p>
                </div>
                <div class="summary-actions">
                    <button id="viewJsonBtn" disabled>View Complete JSON</button>
                    <button id="copyJsonBtn" disabled>Copy Complete JSON</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-geometryutil"></script>


    <script>
        // --- DOM Element References ---
        const mapElement = document.getElementById('map');
        const jsonFileInput = document.getElementById('jsonFileInput');
        const subMapSelect = document.getElementById('subMapSelect');
        const loadSubMapBtn = document.getElementById('loadSubMapBtn');
        const exportMapDataBtn = document.getElementById('exportMapDataBtn');
        const statusDisplay = document.getElementById('status');
        const modeTabs = document.querySelectorAll('.mode-tab');

        const scalePixelsInput = document.getElementById('scalePixels');
        const scaleUnitsInput = document.getElementById('scaleUnits');
        const mapBlurbInput = document.getElementById('mapBlurb');

        const pointNameInput = document.getElementById('pointName');
        const pointPronunciationInput = document.getElementById('pointPronunciation');
        const poiTypeSelect = document.getElementById('poiTypeSelect');
        const pointDescriptionInput = document.getElementById('pointDescription');
        const pointWikiLinkInput = document.getElementById('pointWikiLink');
        const pointPropertiesContainer = document.getElementById('point-properties-container');
        const addPointPropertyBtn = document.getElementById('addPointPropertyBtn');
        const addPointBtn = document.getElementById('addPointBtn');
        const savePointChangesBtn = document.getElementById('savePointChangesBtn');
        const cancelPointEditBtn = document.getElementById('cancelPointEditBtn');
        const coordsDisplay = document.getElementById('coords-display');
        const editPointSelect = document.getElementById('editPointSelect');
        const clearPointsBtn = document.getElementById('clearPointsBtn');

        const regionNameInput = document.getElementById('regionName');
        const regionPronunciationInput = document.getElementById('regionPronunciation');
        const regionTypeSelect = document.getElementById('regionTypeSelect');
        const regionValueInput = document.getElementById('regionValueInput');
        const regionValueOptions = document.getElementById('regionValueOptions');
        const regionColorInput = document.getElementById('regionColor');
        const regionFillColorInput = document.getElementById('regionFillColor');
        const regionOpacityInput = document.getElementById('regionOpacity');
        const regionDescriptionInput = document.getElementById('regionDescription');
        const regionWikiLinkInput = document.getElementById('regionWikiLink');
        const regionPropertiesContainer = document.getElementById('region-properties-container');
        const addRegionPropertyBtn = document.getElementById('addRegionPropertyBtn');
        const startRegionBtn = document.getElementById('startRegionBtn');
        const finishRegionBtn = document.getElementById('finishRegionBtn');
        const cancelRegionBtn = document.getElementById('cancelRegionBtn');
        const saveRegionChangesBtn = document.getElementById('saveRegionChangesBtn');
        const addVerticesBtn = document.getElementById('addVerticesBtn');
        const editVerticesBtn = document.getElementById('editVerticesBtn');
        const cancelRegionEditBtn = document.getElementById('cancelRegionEditBtn');
        const editRegionSelect = document.getElementById('editRegionSelect');
        const regionVerticesCount = document.getElementById('region-vertices-count');
        const clearRegionsBtn = document.getElementById('clearRegionsBtn');
        const showAllRegionsToggle = document.getElementById('showAllRegionsToggle');

        // Line Elements
        const lineNameInput = document.getElementById('lineName');
        const linePronunciationInput = document.getElementById('linePronunciation');
        const lineTypeSelect = document.getElementById('lineTypeSelect');
        const lineColorInput = document.getElementById('lineColor');
        const lineWeightInput = document.getElementById('lineWeight');
        const lineDashArrayInput = document.getElementById('lineDashArray');
        const lineDescriptionInput = document.getElementById('lineDescription');
        const lineWikiLinkInput = document.getElementById('lineWikiLink');
        const linePropertiesContainer = document.getElementById('line-properties-container');
        const addLinePropertyBtn = document.getElementById('addLinePropertyBtn');
        const startLineBtn = document.getElementById('startLineBtn');
        const finishLineBtn = document.getElementById('finishLineBtn');
        const cancelLineBtn = document.getElementById('cancelLineBtn');
        const clearLinesBtn = document.getElementById('clearLinesBtn');
        const saveLineChangesBtn = document.getElementById('saveLineChangesBtn');
        const addLineVerticesBtn = document.getElementById('addLineVerticesBtn');
        const editLineVerticesBtn = document.getElementById('editLineVerticesBtn');
        const cancelLineEditBtn = document.getElementById('cancelLineEditBtn');
        const editLineSelect = document.getElementById('editLineSelect');
        const lineVerticesCountDisplay = document.getElementById('line-vertices-count');


        const pointControls = document.querySelector('.point-controls');
        const regionControls = document.querySelector('.region-controls');
        const lineControls = document.querySelector('.line-controls'); 
        const pointInfo = document.querySelector('.point-info');
        const regionInfo = document.querySelector('.region-info');
        const lineInfo = document.querySelector('.line-info'); 

        const pointsCountDisplay = document.getElementById('points-count');
        const regionsCountDisplay = document.getElementById('regions-count');
        const linesCountDisplay = document.getElementById('lines-count'); 
        const viewJsonBtn = document.getElementById('viewJsonBtn');
        const copyJsonBtn = document.getElementById('copyJsonBtn');

        // --- State Variables ---
        let map = null;
        let imageLayer = null;
        let masterMapData = []; // Will hold the entire maps.json content
        let currentMapObject = null; // The specific map object being edited
        let currentBounds = null;
        let lastClickedCoordsArray = null;
        let collectedPoints = [];
        let collectedRegions = [];
        let collectedLines = []; 
        let isEditingPoint = false;
        let editingPointMarker = null;
        let isEditingRegion = false;
        let isEditingLine = false; 
        let currentlyEditingPointIndex = -1;
        let currentlyEditingRegionIndex = -1;
        let currentlyEditingLineIndex = -1; 
        let currentMode = 'points';

        let isCreatingRegion = false;
        let tempRegionVertices = [];
        let tempRegionLayer = null;

        let isAddingVerticesToRegion = false;
        let isEditingVertices = false; // For regions
        let addingVerticesData = { index: -1, newPoints: [] };
        let editingVisualsLayerGroup = null;
        let editingPolygonLayer = null;

        let isCreatingLine = false; 
        let tempLineVertices = [];  
        let tempLineLayer = null;    
        let isEditingLineVertices = false; 
        let editingLineVisualsLayerGroup = null; 
        let editingLinePolylineLayer = null; 
        let activeVertexMarker = null; 
        
        let showAllRegionsWhileEditing = false;
        let otherRegionsLayerGroup = null;


        const poiTypeGroups = {
            "Settlements": ["City", "Town", "Village", "Hamlet", "Settlement", "Capital"],
            "Structures": ["Castle", "Fortress", "Fort", "Tower", "Ruin", "Temple", "Shrine", "Mine", "Lighthouse", "Bridge", "Dungeon", "Lair", "Camp", "Asylum", "Landmark"],
            "Natural Features": ["Mountain", "Peak", "Forest", "Wood", "River", "Lake", "Cave", "Cavern", "Coast", "Bay", "Cove", "Swamp", "Marsh", "Desert", "Natural Landmark"],
            "Other": ["Point of Interest", "Region", "Portal"],
            "Unknown": ["Unknown"]
        };
        const regionTypeColors = {
            "political": { color: "#3388ff", fillColor: "#3388ff" }, 
            "geographic": { color: "#33aa33", fillColor: "#33aa33" },
            "climate": { color: "#aa33aa", fillColor: "#aa33aa" }, 
            "cultural": { color: "#aaaa33", fillColor: "#aaaa33" },
            "other": { color: "#aa3333", fillColor: "#aa3333" }
        };

        // --- Helper Functions ---
        function populateRegionTypeDropdowns() {
            regionTypeSelect.innerHTML = '<option value="">--Select Type--</option>';
            regionValueInput.value = '';
            regionValueOptions.innerHTML = '';
            regionValueInput.disabled = true;

            if (currentMapObject && currentMapObject.filterGroups && currentMapObject.filterGroups.Regions) {
                const regionTypes = Object.keys(currentMapObject.filterGroups.Regions);
                regionTypes.sort().forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    regionTypeSelect.appendChild(option);
                });
            }
        }

        function toggleOtherRegionsVisibility(show, exceptIndex = -1) {
            if (otherRegionsLayerGroup) {
                map.removeLayer(otherRegionsLayerGroup);
                otherRegionsLayerGroup = null;
            }

            if (show) {
                otherRegionsLayerGroup = L.layerGroup();
                collectedRegions.forEach((region, index) => {
                    if (index === exceptIndex) return; // Skip the one being edited

                    const style = {
                        color: region.color || '#3388ff',
                        fillColor: region.fillColor || '#3388ff',
                        fillOpacity: 0.05, // Very low opacity for background regions
                        weight: 1,
                        dashArray: '3, 5',
                        interactive: false // Make them not clickable
                    };
                    L.polygon(region.coordinates, style).addTo(otherRegionsLayerGroup);
                });
                otherRegionsLayerGroup.addTo(map);
            }
        }
        function setMode(mode) {
            currentMode = mode;
            modeTabs.forEach(tab => tab.classList.toggle('active', tab.dataset.mode === mode));

            pointControls.classList.toggle('hidden', mode !== 'points');
            regionControls.classList.toggle('hidden', mode !== 'regions');
            lineControls.classList.toggle('hidden', mode !== 'lines'); 
            pointInfo.classList.toggle('hidden', mode !== 'points');
            regionInfo.classList.toggle('hidden', mode !== 'regions');
            lineInfo.classList.toggle('hidden', mode !== 'lines'); 

            if (mode !== 'points' && isEditingPoint) cancelPointEditing();
            if (mode !== 'regions' && (isCreatingRegion || isEditingRegion)) {
                cancelRegionCreation(); cancelRegionEditing();
            }
            if (mode !== 'lines' && (isCreatingLine || isEditingLine)) { 
                cancelLineCreation(); cancelLineEdit();
            }
            updateStatus();
        }
        
        function populateSubMapSelector(mapData) {
            subMapSelect.innerHTML = '<option value="">-- Choose a map --</option>';
            const foundMaps = [];

            function findMapsRecursive(items) {
                if (!items || !Array.isArray(items)) return;
                items.forEach(item => {
                    if (item && typeof item === 'object') {
                        if (item.imageUrl && item.id && item.name) {
                            foundMaps.push({ id: item.id, name: item.name });
                        }
                        if (item.children && Array.isArray(item.children)) {
                           findMapsRecursive(item.children);
                        }
                    }
                });
            }

            findMapsRecursive(mapData);

            foundMaps.sort((a,b) => a.name.localeCompare(b.name)).forEach(mapInfo => {
               const option = document.createElement('option');
               option.value = mapInfo.id;
               option.textContent = mapInfo.name;
               subMapSelect.appendChild(option);
            });
            
            subMapSelect.disabled = foundMaps.length === 0;
            loadSubMapBtn.disabled = foundMaps.length === 0;
        }

        function populateTypeDropdown() {
            poiTypeSelect.innerHTML = '<option value="">--Select Type--</option>';
            for (const groupName in poiTypeGroups) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = groupName;
                poiTypeGroups[groupName].forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    optgroup.appendChild(option);
                });
                poiTypeSelect.appendChild(optgroup);
            }
        }
        function populatePointEditDropdown() {
            const previouslySelectedName = (currentlyEditingPointIndex >= 0 && currentlyEditingPointIndex < collectedPoints.length)
                                          ? collectedPoints[currentlyEditingPointIndex].name : null;
            editPointSelect.innerHTML = '<option value="">--Select Point to Edit--</option>';
            const sortedPoints = [...collectedPoints].sort((a, b) => a.name.localeCompare(b.name));
            sortedPoints.forEach(point => {
                const option = document.createElement('option');
                option.value = point.name; option.textContent = point.name;
                editPointSelect.appendChild(option);
            });
            editPointSelect.value = previouslySelectedName || "";
            editPointSelect.disabled = collectedPoints.length === 0;
        }
        function populateRegionEditDropdown() {
             const previouslySelectedName = (currentlyEditingRegionIndex >= 0 && currentlyEditingRegionIndex < collectedRegions.length)
                                          ? collectedRegions[currentlyEditingRegionIndex].name : null;
            editRegionSelect.innerHTML = '<option value="">--Select Region to Edit--</option>';
            const sortedRegions = [...collectedRegions].sort((a, b) => a.name.localeCompare(b.name));
            sortedRegions.forEach(region => {
                const option = document.createElement('option');
                option.value = region.name; option.textContent = region.name;
                editRegionSelect.appendChild(option);
            });
            editRegionSelect.value = previouslySelectedName || "";
            editRegionSelect.disabled = collectedRegions.length === 0;
        }
        function populateLineEditDropdown() { 
            const previouslySelectedValue = (currentlyEditingLineIndex >= 0 && currentlyEditingLineIndex < collectedLines.length)
                                          ? (collectedLines[currentlyEditingLineIndex].name || collectedLines[currentlyEditingLineIndex].id)
                                          : null;
            editLineSelect.innerHTML = '<option value="">--Select Line to Edit--</option>';
            const sortedLines = [...collectedLines].sort((a, b) => (a.name || "Unnamed Line").localeCompare(b.name || "Unnamed Line"));
            sortedLines.forEach(line => {
                const option = document.createElement('option');
                option.value = line.name || line.id;
                option.textContent = line.name || `Line ID: ${line.id.substring(0,10)}...`;
                editLineSelect.appendChild(option);
            });
            editLineSelect.value = previouslySelectedValue || "";
            editLineSelect.disabled = collectedLines.length === 0;
        }


        function updatePointsOutput() {
            pointsCountDisplay.textContent = collectedPoints.length;
            clearPointsBtn.disabled = collectedPoints.length === 0;
            populatePointEditDropdown();
            const mapLoaded = !!imageLayer;
            exportMapDataBtn.disabled = !mapLoaded; viewJsonBtn.disabled = !mapLoaded; copyJsonBtn.disabled = !mapLoaded;
        }
        function updateRegionsOutput() {
            regionsCountDisplay.textContent = collectedRegions.length;
            clearRegionsBtn.disabled = collectedRegions.length === 0;
            populateRegionEditDropdown();
            const mapLoaded = !!imageLayer;
            exportMapDataBtn.disabled = !mapLoaded; viewJsonBtn.disabled = !mapLoaded; copyJsonBtn.disabled = !mapLoaded;
        }
        function updateLinesOutput() { 
            linesCountDisplay.textContent = collectedLines.length;
            clearLinesBtn.disabled = collectedLines.length === 0;
            populateLineEditDropdown();
            const mapLoaded = !!imageLayer;
            exportMapDataBtn.disabled = !mapLoaded; viewJsonBtn.disabled = !mapLoaded; copyJsonBtn.disabled = !mapLoaded;
        }

        function setStatus(message, type = 'info') { statusDisplay.textContent = message; statusDisplay.className = type; }

        function updateStatus() {
            if (!currentMapObject) { setStatus('Load a JSON file to begin.'); return; }
            if (currentMode === 'points') {
                setStatus(isEditingPoint ? 'Editing point. Drag marker or click map to move. Modify details and Save or Cancel.' : 'Click map for new point or select existing point to edit.');
            } else if (currentMode === 'regions') {
                if (isCreatingRegion) setStatus('Creating region. Click map to add vertices. Click Finish when done.');
                else if (isAddingVerticesToRegion) setStatus(`Adding vertices to region '${collectedRegions[addingVerticesData.index].name}'. Click map to add, or click Stop.`);
                else if (isEditingVertices) {
                    if (activeVertexMarker) setStatus(`Vertex selected. Drag to move, or press Delete/Backspace to remove.`);
                    else setStatus(`Editing vertices for region '${collectedRegions[currentlyEditingRegionIndex].name}'. Drag vertices, click one to select for deletion, or click Stop.`);
                }
                else if (isEditingRegion) setStatus('Editing region. Modify details, Save Changes, Add Vertices, Edit Vertices, or Cancel.');
                else setStatus('Fill in region details and click Start Region, or select existing region to edit.');
            } else if (currentMode === 'lines') { 
                if (isCreatingLine) setStatus('Creating line. Click map to add vertices. Click Finish Line when done.');
                else if (isEditingLineVertices) {
                    if (activeVertexMarker) setStatus(`Vertex selected. Drag to move, or press Delete/Backspace to remove.`);
                    else setStatus(`Editing line vertices for '${collectedLines[currentlyEditingLineIndex].name || collectedLines[currentlyEditingLineIndex].id}'. Drag vertices, click one to select for deletion, or click Stop.`);
                }
                else if (isEditingLine) setStatus('Editing line. Modify details, Save Changes, Edit Vertices, or Cancel.');
                else setStatus('Fill in line details and click Start Line, or select existing line to edit.');
            }
        }

        function setPointEditingState(editing, pointNameOrIndex = null) {
            isEditingPoint = editing;
            currentlyEditingPointIndex = -1;

            if (editingPointMarker) {
                map.removeLayer(editingPointMarker);
                editingPointMarker = null;
            }

            if (editing && pointNameOrIndex !== null) {
                const nameToFind = (typeof pointNameOrIndex === 'number') ? collectedPoints[pointNameOrIndex]?.name : pointNameOrIndex;
                if (nameToFind) currentlyEditingPointIndex = collectedPoints.findIndex(p => p.name === nameToFind);

                if (currentlyEditingPointIndex !== -1) {
                    const point = collectedPoints[currentlyEditingPointIndex];
                    editingPointMarker = L.circleMarker(point.coords, { 
                        draggable: true, 
                        color: 'magenta',
                        fillColor: '#ff00ff',
                        fillOpacity: 0.5,
                        radius: 10
                    }).addTo(map);
                    
                    editingPointMarker.on('dragend', function(event) {
                        const marker = event.target;
                        const position = marker.getLatLng();
                        lastClickedCoordsArray = [Math.round(position.lat), Math.round(position.lng)];
                        coordsDisplay.textContent = `[${lastClickedCoordsArray[0]}, ${lastClickedCoordsArray[1]}]`;
                        setStatus('Point position updated by drag. Modify details and Save or Cancel.');
                    });
                    map.panTo(point.coords);
                } else {
                    editing = false; 
                    isEditingPoint = false; 
                }
            }

            addPointBtn.classList.toggle('hidden', editing);
            savePointChangesBtn.classList.toggle('hidden', !editing);
            cancelPointEditBtn.classList.toggle('hidden', !editing);
            clearPointsBtn.classList.toggle('hidden', editing);

            if (!editing) {
                pointNameInput.value = ''; pointPronunciationInput.value = ''; poiTypeSelect.value = ''; pointDescriptionInput.value = ''; pointWikiLinkInput.value = '';
                coordsDisplay.textContent = '[Y, X]';
                lastClickedCoordsArray = null;
                addPointBtn.disabled = !currentMapObject; 
                editPointSelect.value = "";
                displayProperties(pointPropertiesContainer, {});
                addPointPropertyBtn.disabled = true;
            } else {
                addPointBtn.disabled = true; 
                addPointPropertyBtn.disabled = false;
            }
            updateStatus();
        }

        function setRegionEditingState(editing, regionNameOrIndex = null) {
            isEditingRegion = editing; currentlyEditingRegionIndex = -1;
            if (isAddingVerticesToRegion) stopAddingVertices(false); if (isEditingVertices) stopEditingVertices(false);
            if (editing && regionNameOrIndex !== null) {
                const nameToFind = (typeof regionNameOrIndex === 'number') ? collectedRegions[regionNameOrIndex]?.name : regionNameOrIndex;
                if (nameToFind) currentlyEditingRegionIndex = collectedRegions.findIndex(r => r.name === nameToFind);
                else editing = false;
            }
            startRegionBtn.classList.toggle('hidden', editing); saveRegionChangesBtn.classList.toggle('hidden', !editing);
            addVerticesBtn.classList.toggle('hidden', !editing); editVerticesBtn.classList.toggle('hidden', !editing);
            cancelRegionEditBtn.classList.toggle('hidden', !editing); clearRegionsBtn.classList.toggle('hidden', editing);

            if (!editing) {
                if (!isCreatingRegion) {
                    regionNameInput.value = ''; 
                    regionPronunciationInput.value = '';
                    regionTypeSelect.value = '';
                    regionValueInput.value = '';
                    regionValueOptions.innerHTML = '';
                    regionValueInput.disabled = true;
                    regionDescriptionInput.value = ''; 
                    regionWikiLinkInput.value = '';
                    regionColorInput.value = '#3388ff'; regionFillColorInput.value = '#3388ff'; regionOpacityInput.value = '0.2';
                    displayProperties(regionPropertiesContainer, {});
                }
                startRegionBtn.disabled = !currentMapObject; editRegionSelect.value = ""; clearEditingVisuals();
                toggleOtherRegionsVisibility(false);
                addRegionPropertyBtn.disabled = true;
            } else {
                startRegionBtn.disabled = true;
                addRegionPropertyBtn.disabled = false;
            }
            updateStatus();
        }

        function setLineEditState(editing, lineIdOrName = null) { 
            isEditingLine = editing;
            currentlyEditingLineIndex = -1;

            if (!editing && isEditingLineVertices) stopEditingLineVertices(false);

            if (editing && lineIdOrName !== null) {
                let foundIndex = collectedLines.findIndex(l => l.name === lineIdOrName && l.name);
                if (foundIndex === -1) foundIndex = collectedLines.findIndex(l => l.id === lineIdOrName);
                if (foundIndex !== -1) currentlyEditingLineIndex = foundIndex;
                else editing = false;
            }

            startLineBtn.classList.toggle('hidden', editing);
            saveLineChangesBtn.classList.toggle('hidden', !editing);
            addLineVerticesBtn.classList.toggle('hidden', !editing || isEditingLineVertices);
            editLineVerticesBtn.classList.toggle('hidden', !editing || isEditingLineVertices);
            cancelLineEditBtn.classList.toggle('hidden', !editing);
            clearLinesBtn.classList.toggle('hidden', editing);

            if (!editing) {
                lineNameInput.value = ''; linePronunciationInput.value = ''; lineTypeSelect.value = ''; lineColorInput.value = '#808080';
                lineWeightInput.value = '3'; lineDashArrayInput.value = ''; lineDescriptionInput.value = '';
                lineWikiLinkInput.value = ''; startLineBtn.disabled = !currentMapObject; editLineSelect.value = "";
                if (tempLineLayer) { map.removeLayer(tempLineLayer); tempLineLayer = null; }
                clearLineEditingVisuals();
                displayProperties(linePropertiesContainer, {});
                addLinePropertyBtn.disabled = true;
            } else {
                startLineBtn.disabled = true;
                addLineVerticesBtn.classList.toggle('hidden', !editing || isEditingLineVertices);
                editLineVerticesBtn.classList.toggle('hidden', !editing || isEditingLineVertices);
                if (isEditingLineVertices) {
                     saveLineChangesBtn.classList.add('hidden');
                     cancelLineEditBtn.classList.add('hidden');
                }
                addLinePropertyBtn.disabled = false;
            }
            updateStatus();
        }


        function setRegionCreationState(creating) {
            isCreatingRegion = creating; tempRegionVertices = [];
            startRegionBtn.classList.toggle('hidden', creating); finishRegionBtn.classList.toggle('hidden', !creating);
            cancelRegionBtn.classList.toggle('hidden', !creating); clearRegionsBtn.classList.toggle('hidden', creating);
            mapElement.classList.toggle('region-creation-mode', creating);
            if (!creating && tempRegionLayer) { map.removeLayer(tempRegionLayer); tempRegionLayer = null; }
            if (creating) {
                displayProperties(regionPropertiesContainer, {});
                addRegionPropertyBtn.disabled = false;
            } else {
                addRegionPropertyBtn.disabled = true;
            }
            updateRegionVerticesCount(); updateStatus();
        }
        function setLineCreationState(creating) { 
            isCreatingLine = creating;
            if (creating) tempLineVertices = [];
            startLineBtn.classList.toggle('hidden', creating);
            finishLineBtn.classList.toggle('hidden', !creating);
            cancelLineBtn.classList.toggle('hidden', !creating);
            clearLinesBtn.classList.toggle('hidden', creating);
            mapElement.classList.toggle('line-creation-mode', creating); 

            if (!creating && tempLineLayer) { map.removeLayer(tempLineLayer); tempLineLayer = null; }
            if (creating) {
                displayProperties(linePropertiesContainer, {});
                addLinePropertyBtn.disabled = false;
            } else {
                addLinePropertyBtn.disabled = true;
            }
            updateLineVerticesCount(); updateStatus();
        }


        function updateRegionVerticesCount() {
            const count = tempRegionVertices.length;
            regionVerticesCount.textContent = `${count} ${count === 1 ? 'vertex' : 'vertices'}`;
        }
        function updateLineVerticesCount() { 
            const count = tempLineVertices.length;
            lineVerticesCountDisplay.textContent = `${count} ${count === 1 ? 'vertex' : 'vertices'}`;
        }


        function resetUIForNewMap() {
            setStatus('Select a map and click Load.');
            coordsDisplay.textContent = '[Y, X]';
            pointNameInput.value = ''; pointPronunciationInput.value = ''; poiTypeSelect.value = ''; pointDescriptionInput.value = ''; pointWikiLinkInput.value = '';
            displayProperties(pointPropertiesContainer, {});
            regionNameInput.value = '';
            regionPronunciationInput.value = '';
            regionTypeSelect.value = '';
            regionValueInput.value = '';
            regionValueOptions.innerHTML = '';
            regionValueInput.disabled = true;
            regionDescriptionInput.value = '';
            regionWikiLinkInput.value = '';
            displayProperties(regionPropertiesContainer, {});
            lineNameInput.value = ''; linePronunciationInput.value = ''; lineTypeSelect.value = ''; lineDescriptionInput.value = ''; lineWikiLinkInput.value = '';
            displayProperties(linePropertiesContainer, {});
            scalePixelsInput.value = '3'; scaleUnitsInput.value = '1'; mapBlurbInput.value = '';
            
            addPointBtn.disabled = true; startRegionBtn.disabled = true; startLineBtn.disabled = true;
            addPointPropertyBtn.disabled = true; addRegionPropertyBtn.disabled = true; addLinePropertyBtn.disabled = true;
            clearPointsBtn.disabled = true; clearRegionsBtn.disabled = true; clearLinesBtn.disabled = true;
            exportMapDataBtn.disabled = true; viewJsonBtn.disabled = true; copyJsonBtn.disabled = true;
            
            pointsCountDisplay.textContent = '0'; regionsCountDisplay.textContent = '0'; linesCountDisplay.textContent = '0';
            
            lastClickedCoordsArray = null;
            collectedPoints = []; collectedRegions = []; collectedLines = [];
            
            if (map) {
                 map.eachLayer(layer => {
                    // Do not remove the map container itself, just overlays and features
                    if (layer._url === undefined) { 
                        map.removeLayer(layer);
                    }
                });
                if (imageLayer) {
                     map.removeLayer(imageLayer);
                }
            }
            imageLayer = null;
            currentMapObject = null; currentBounds = null; 
            
            setPointEditingState(false); setRegionEditingState(false); setRegionCreationState(false);
            setLineEditState(false); setLineCreationState(false);
            
            populatePointEditDropdown(); populateRegionEditDropdown(); populateLineEditDropdown();
            updateRegionVerticesCount(); updateLineVerticesCount();
        }

        function handleJsonFileLoad(event) {
            const file = event.target.files[0];
            if (!file) {
                return;
            }
            setStatus(`Loading ${file.name}...`, 'info');
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    const jsonObject = JSON.parse(e.target.result);
                    
                    if (Array.isArray(jsonObject)) {
                        masterMapData = jsonObject;
                        populateSubMapSelector(masterMapData);
                        setStatus("Manifest file loaded. Select a map from the dropdown.", "success");
                        resetUIForNewMap();
                        subMapSelect.disabled = false;
                        loadSubMapBtn.disabled = false;
                    } else if (typeof jsonObject === 'object' && jsonObject !== null && jsonObject.imageUrl) {
                        masterMapData = [jsonObject];
                        subMapSelect.innerHTML = `<option value="${jsonObject.id || ''}" selected>${jsonObject.name || 'Single Map'}</option>`;
                        subMapSelect.disabled = true;
                        loadSubMapBtn.disabled = true;
                        await loadMap(jsonObject);
                    } else {
                        throw new Error("Invalid JSON format. Must be an array of map objects or a single map object with an 'imageUrl' property.");
                    }

                } catch(error) {
                    setStatus(`Error loading map file '${file.name}': ${error.message}`, 'error');
                    console.error(error);
                    masterMapData = [];
                    subMapSelect.innerHTML = '<option value="">-- Load failed --</option>';
                    subMapSelect.disabled = true;
                    loadSubMapBtn.disabled = true;
                    resetUIForNewMap();
                }
            };
            reader.onerror = () => {
                 setStatus(`Error reading file: ${file.name}`, 'error');
            }
            reader.readAsText(file);
        }

        async function loadMapFromSelector() {
            const selectedMapId = subMapSelect.value;
            if (!selectedMapId) { alert("Please select a map from the dropdown."); return; }
            
            let mapData = null;
            function findMapById(items, id) {
                for (const item of items) {
                    if (item.id === id) return item;
                     if (item.children && Array.isArray(item.children)) {
                         const found = findMapById(item.children, id);
                         if(found) return found;
                     }
                }
                return null;
            }
            mapData = findMapById(masterMapData, selectedMapId);

            if (mapData) {
                await loadMap(mapData);
            } else {
                alert(`Could not find map data in the manifest for ID: ${selectedMapId}`);
            }
        }

        async function loadMap(mapData) {
            if (!mapData || !mapData.imageUrl) {
                alert(`Cannot load map: the provided data is missing an 'imageUrl'.`);
                return;
            }
            
            resetUIForNewMap();
            currentMapObject = mapData;

            loadSubMapBtn.disabled = true; setStatus('Loading image and map data...');
            
            try {
                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve; 
                    img.onerror = () => reject(new Error(`Could not load image file: ${mapData.imageUrl}. Ensure the URL is correct and accessible.`));
                    img.src = mapData.imageUrl;
                });

                const mapWidth = mapData.width || img.naturalWidth;
                const mapHeight = mapData.height || img.naturalHeight;
                if (mapWidth === 0 || mapHeight === 0) throw new Error('Image has zero dimensions.');
                
                currentBounds = [[0, 0], [mapHeight, mapWidth]];
                if (!map) throw new Error("Map object not initialized.");
                
                imageLayer = L.imageOverlay(mapData.imageUrl, currentBounds).addTo(map);
                map.fitBounds(currentBounds);
                
                scalePixelsInput.value = currentMapObject.scalePixels || 3;
                scaleUnitsInput.value = currentMapObject.scaleKilometers || currentMapObject.scaleUnits || 1; 
                mapBlurbInput.value = currentMapObject.blurb || "";
                
                populateRegionTypeDropdowns();

                let pointsImported = 0, regionsImported = 0, linesImported = 0; 
                if (currentMapObject.pointsOfInterest) { importPoints(currentMapObject.pointsOfInterest, true); pointsImported = currentMapObject.pointsOfInterest.length; }
                if (currentMapObject.regions) { importRegions(currentMapObject.regions, true); regionsImported = currentMapObject.regions.length; }
                const lineData = currentMapObject.lines || currentMapObject.roads;
                if (lineData) { importLines(lineData, true); linesImported = lineData.length; } 

                let finalStatus = `Loaded: ${currentMapObject.name}. `;
                finalStatus += `Imported ${pointsImported} points, ${regionsImported} regions, ${linesImported} lines. `; 
                finalStatus += `${currentMode === 'points' ? 'Click map for new point' : (currentMode === 'regions' ? 'Fill in region details' : 'Fill in line details')}.`; 
                setStatus(finalStatus, 'success');
                
                addPointBtn.disabled = false; startRegionBtn.disabled = false; startLineBtn.disabled = false; 
                exportMapDataBtn.disabled = false; viewJsonBtn.disabled = false; copyJsonBtn.disabled = false;

            } catch (error) { 
                setStatus(`Error loading map: ${error.message}`, 'error'); 
                console.error("Map Loading Error:", error); 
                resetUIForNewMap();
                if (masterMapData.length > 1) {
                    subMapSelect.disabled = false;
                    loadSubMapBtn.disabled = false;
                }
            } finally { 
                if (masterMapData.length > 1) {
                    loadSubMapBtn.disabled = false;
                }
            }
        }

        function importPoints(dataToImport, suppressStatus = false) { 
            let addedCount = 0, skippedCount = 0; const existingNames = new Set(collectedPoints.map(p => p.name));
            dataToImport.forEach(item => {
                if (item && typeof item === 'object' && Array.isArray(item.coords) && item.coords.length === 2 && typeof item.name === 'string' && item.name.trim() !== "") {
                    const pointName = item.name.trim();
                    if (existingNames.has(pointName)) skippedCount++;
                    else {
                        const lat = Number(item.coords[0]), lng = Number(item.coords[1]);
                        if (!isNaN(lat) && !isNaN(lng)) {
                            collectedPoints.push({ coords: [Math.round(lat), Math.round(lng)], name: pointName, pronunciation: item.pronunciation || "", type: item.type || "Unknown", description: item.description || "", wikiLink: item.wikiLink || "", properties: item.properties || {} });
                            existingNames.add(pointName); addedCount++;
                        } else { console.warn("Skipping point with invalid coordinates:", item); skippedCount++; }
                    }
                } else { console.warn("Skipping invalid/incomplete point during import:", item); skippedCount++;}
            });
            updatePointsOutput(); if (!suppressStatus) setStatus(`Import complete: Added ${addedCount} points, skipped ${skippedCount}.`, 'success');
            setPointEditingState(false);
        }
        function importRegions(dataToImport, suppressStatus = false) { 
            let addedCount = 0, skippedCount = 0; const existingNames = new Set(collectedRegions.map(r => r.name));
            dataToImport.forEach(item => {
                if (item && typeof item === 'object' && Array.isArray(item.coordinates) && item.coordinates.length >= 3 && typeof item.name === 'string' && item.name.trim() !== "") {
                    const regionName = item.name.trim();
                    if (existingNames.has(regionName)) skippedCount++;
                    else {
                        const validCoords = item.coordinates.every(coord => Array.isArray(coord) && coord.length === 2 && !isNaN(Number(coord[0])) && !isNaN(Number(coord[1])));
                        if (validCoords) {
                            collectedRegions.push({ id: item.id || `region-${regionName.toLowerCase().replace(/\s+/g, '-')}`, name: regionName, pronunciation: item.pronunciation || "", type: item.type || "", value: item.value || "", description: item.description || "", wikiLink: item.wikiLink || "", color: item.color || "#3388ff", fillColor: item.fillColor || "#3388ff", fillOpacity: item.fillOpacity ?? 0.2, coordinates: item.coordinates.map(coord => [Math.round(Number(coord[0])), Math.round(Number(coord[1]))]), properties: item.properties || {} });
                            existingNames.add(regionName); addedCount++;
                        } else { console.warn("Skipping region with invalid coordinates:", item); skippedCount++; }
                    }
                } else { console.warn("Skipping invalid/incomplete region during import:", item); skippedCount++; }
            });
            updateRegionsOutput(); if (!suppressStatus) setStatus(`Import complete: Added ${addedCount} regions, skipped ${skippedCount}.`, 'success');
            setRegionEditingState(false);
        }
        function importLines(dataToImport, suppressStatus = false) { 
            let addedCount = 0, skippedCount = 0;
            const existingIds = new Set(collectedLines.map(l => l.id)); 
            dataToImport.forEach(item => {
                if (item && typeof item === 'object' && Array.isArray(item.coordinates) && item.coordinates.length >= 2 && typeof item.id === 'string' && item.id.trim() !== "") {
                    const lineId = item.id.trim();
                    if (existingIds.has(lineId)) skippedCount++;
                    else {
                        const validCoords = item.coordinates.every(coord => Array.isArray(coord) && coord.length === 2 && !isNaN(Number(coord[0])) && !isNaN(Number(coord[1])));
                        if (validCoords) {
                            collectedLines.push({ 
                                id: lineId, name: item.name || "", pronunciation: item.pronunciation || "", type: item.type || "",
                                description: item.description || "", wikiLink: item.wikiLink || "",
                                color: item.color || "#808080", weight: item.weight || 3,
                                dashArray: item.dashArray || "",
                                coordinates: item.coordinates.map(coord => [Math.round(Number(coord[0])), Math.round(Number(coord[1]))]),
                                properties: item.properties || {}
                            });
                            existingIds.add(lineId); addedCount++;
                        } else { console.warn("Skipping line with invalid coordinates:", item); skippedCount++; }
                    }
                } else { console.warn("Skipping invalid/incomplete line during import:", item); skippedCount++; }
            });
            updateLinesOutput(); 
            if (!suppressStatus) setStatus(`Line import: Added ${addedCount}, skipped ${skippedCount}.`, 'success'); 
            setLineEditState(false); 
        }


        function loadPointForEditing(pointName) {
            const index = collectedPoints.findIndex(p => p.name === pointName);
            if (index === -1) { setPointEditingState(false); return; }
            const point = collectedPoints[index];
            pointNameInput.value = point.name;
            pointPronunciationInput.value = point.pronunciation || "";
            poiTypeSelect.value = point.type || "";
            pointDescriptionInput.value = point.description || ""; pointWikiLinkInput.value = point.wikiLink || "";
            coordsDisplay.textContent = `[${point.coords[0]}, ${point.coords[1]}]`;
            lastClickedCoordsArray = [...point.coords];
            displayProperties(pointPropertiesContainer, point.properties);
            setPointEditingState(true, point.name);
        }
        function loadRegionForEditing(regionName) { 
            const index = collectedRegions.findIndex(r => r.name === regionName);
            if (index === -1) { setRegionEditingState(false); return; }
            const region = collectedRegions[index];
            regionNameInput.value = region.name;
            regionPronunciationInput.value = region.pronunciation || "";
            regionTypeSelect.value = region.type || "";
            regionTypeSelect.dispatchEvent(new Event('change'));
            regionValueInput.value = region.value || "";
            regionDescriptionInput.value = region.description || "";
            regionWikiLinkInput.value = region.wikiLink || "";
            regionColorInput.value = region.color || "#3388ff";
            regionFillColorInput.value = region.fillColor || "#3388ff";
            regionOpacityInput.value = region.fillOpacity ?? 0.2;
            displayProperties(regionPropertiesContainer, region.properties);
            clearEditingVisuals();
            editingVisualsLayerGroup = L.layerGroup().addTo(map);
            editingPolygonLayer = L.polygon(region.coordinates, { color: region.color || "#3388ff", fillColor: region.fillColor || "#3388ff", fillOpacity: region.fillOpacity ?? 0.2, weight: 3, dashArray: "5, 5" });
            editingVisualsLayerGroup.addLayer(editingPolygonLayer);
            map.fitBounds(editingPolygonLayer.getBounds().pad(0.1));
            if (showAllRegionsWhileEditing) {
                toggleOtherRegionsVisibility(true, index);
            }
            setRegionEditingState(true, region.name);
        }
        function loadLineEdit(lineIdOrName) { 
            let index = collectedLines.findIndex(l => l.name === lineIdOrName && l.name);
            if (index === -1) index = collectedLines.findIndex(l => l.id === lineIdOrName);

            if (index === -1) { setLineEditState(false); return; }
            const line = collectedLines[index];
            lineNameInput.value = line.name || "";
            linePronunciationInput.value = line.pronunciation || "";
            lineTypeSelect.value = line.type || "";
            lineColorInput.value = line.color || "#808080"; lineWeightInput.value = line.weight || 3;
            lineDashArrayInput.value = line.dashArray || ""; lineDescriptionInput.value = line.description || "";
            lineWikiLinkInput.value = line.wikiLink || "";
            displayProperties(linePropertiesContainer, line.properties);

            if (tempLineLayer) map.removeLayer(tempLineLayer);
            tempLineLayer = L.polyline(line.coordinates, {
                color: line.color || "#FFD700", weight: (parseInt(line.weight) || 3) + 2,
                opacity: 0.8, dashArray: '10, 5'
            }).addTo(map);
            if (line.coordinates && line.coordinates.length > 0) map.fitBounds(L.polyline(line.coordinates).getBounds().pad(0.1));
            setLineEditState(true, line.id);
        }


        function savePointChanges() {
            if (!isEditingPoint || currentlyEditingPointIndex < 0 || currentlyEditingPointIndex >= collectedPoints.length) return;
            const originalPoint = collectedPoints[currentlyEditingPointIndex];
            const newName = pointNameInput.value.trim(), newPronunciation = pointPronunciationInput.value.trim(), newType = poiTypeSelect.value;
            const newDescription = pointDescriptionInput.value.trim(), newWikiLink = pointWikiLinkInput.value.trim();
            if (!newName) { alert("Point Name cannot be empty."); pointNameInput.focus(); return; }
            if (!newType) { alert("Please select a Point Type."); poiTypeSelect.focus(); return; }
            if (newName !== originalPoint.name && collectedPoints.some((p, i) => i !== currentlyEditingPointIndex && p.name === newName)) {
                alert(`Another point named "${newName}" already exists.`); pointNameInput.focus(); return;
            }
            originalPoint.name = newName;
            originalPoint.pronunciation = newPronunciation;
            originalPoint.type = newType;
            originalPoint.description = newDescription; originalPoint.wikiLink = newWikiLink;
            originalPoint.properties = collectProperties(pointPropertiesContainer);
            if (lastClickedCoordsArray) originalPoint.coords = [...lastClickedCoordsArray];
            updatePointsOutput(); setStatus(`Point "${newName}" updated.`, 'success');
            setPointEditingState(false);
        }
        function cancelPointEditing() {
            if (editingPointMarker) { map.removeLayer(editingPointMarker); editingPointMarker = null; }
            setPointEditingState(false); setStatus('Point editing cancelled.');
        }
        function saveRegionChanges() { 
            if (!isEditingRegion || currentlyEditingRegionIndex < 0 || currentlyEditingRegionIndex >= collectedRegions.length) return;
            const originalRegion = collectedRegions[currentlyEditingRegionIndex];
            const newName = regionNameInput.value.trim(), newPronunciation = regionPronunciationInput.value.trim(), newType = regionTypeSelect.value, newValue = regionValueInput.value.trim();
            const newDescription = regionDescriptionInput.value.trim(), newWikiLink = regionWikiLinkInput.value.trim();
            const newColor = regionColorInput.value, newFillColor = regionFillColorInput.value;
            const newOpacity = parseFloat(regionOpacityInput.value);
            if (!newName) { alert("Region Name cannot be empty."); regionNameInput.focus(); return; }
            if (isNaN(newOpacity) || newOpacity < 0 || newOpacity > 1) { alert("Invalid Opacity (0.0-1.0)."); regionOpacityInput.focus(); return; }
            if (newName !== originalRegion.name && collectedRegions.some((r, i) => i !== currentlyEditingRegionIndex && r.name === newName)) {
                alert(`Another region named "${newName}" already exists.`); regionNameInput.focus(); return;
            }
            originalRegion.name = newName;
            originalRegion.pronunciation = newPronunciation;
            originalRegion.type = newType;
            originalRegion.value = newValue;
            originalRegion.description = newDescription;
            originalRegion.wikiLink = newWikiLink; originalRegion.color = newColor; originalRegion.fillColor = newFillColor;
            originalRegion.fillOpacity = newOpacity; originalRegion.id = `region-${newName.toLowerCase().replace(/\s+/g, '-')}`;
            originalRegion.properties = collectProperties(regionPropertiesContainer);
            updateRegionsOutput(); setStatus(`Region "${newName}" updated.`, 'success'); setRegionEditingState(false);
        }
        function cancelRegionEditing() { 
            setRegionEditingState(false); setStatus('Region editing cancelled.');
        }
        function saveLineChanges() { 
            if (!isEditingLine || currentlyEditingLineIndex < 0 || currentlyEditingLineIndex >= collectedLines.length) return;
            const originalLine = collectedLines[currentlyEditingLineIndex];
            const newName = lineNameInput.value.trim(), newPronunciation = linePronunciationInput.value.trim(), newType = lineTypeSelect.value;
            const newColor = lineColorInput.value, newWeight = parseInt(lineWeightInput.value);
            const newDashArray = lineDashArrayInput.value.trim();
            const newDescription = lineDescriptionInput.value.trim(), newWikiLink = lineWikiLinkInput.value.trim();
            if (isNaN(newWeight) || newWeight < 1) { alert("Invalid Line Weight."); lineWeightInput.focus(); return; }

            originalLine.name = newName;
            originalLine.pronunciation = newPronunciation;
            originalLine.type = newType; originalLine.color = newColor;
            originalLine.weight = newWeight; originalLine.dashArray = newDashArray;
            originalLine.description = newDescription; originalLine.wikiLink = newWikiLink;
            originalLine.properties = collectProperties(linePropertiesContainer);
            updateLinesOutput(); setStatus(`Line "${newName || originalLine.id}" updated.`, 'success');
            setLineEditState(false);
        }
        function cancelLineEdit() { 
            if (tempLineLayer) { map.removeLayer(tempLineLayer); tempLineLayer = null; }
            setLineEditState(false); setStatus('Line editing cancelled.');
        }


        function startRegionCreation() { 
             if (!currentMapObject) { alert("Load a map first!"); return; }
            if (isEditingRegion) { alert("Finish editing the current region first."); return; }
            setRegionCreationState(true);
        }
        function startLineCreation() { 
            if (!currentMapObject) { alert("Load a map first!"); return; }
            if (isEditingLine) { alert("Finish editing current line first."); return; }
            setLineCreationState(true);
        }


        function handleMapClickForRegion(e) { 
            if (!isCreatingRegion && !isAddingVerticesToRegion) return;
            const coords = [Math.round(e.latlng.lat), Math.round(e.latlng.lng)];
            if (isCreatingRegion) {
                tempRegionVertices.push(coords); updateRegionVerticesCount();
                if (tempRegionLayer) map.removeLayer(tempRegionLayer);
                if (tempRegionVertices.length >= 2) {
                    const options = { color: regionColorInput.value || '#3388ff', fillColor: regionFillColorInput.value || '#3388ff', fillOpacity: parseFloat(regionOpacityInput.value) || 0.2, weight: 2, dashArray: '5, 5' };
                    tempRegionLayer = (tempRegionVertices.length === 2) ? L.polyline(tempRegionVertices, options) : L.polygon(tempRegionVertices, options);
                    tempRegionLayer.addTo(map);
                }
                setStatus(`Added vertex ${tempRegionVertices.length}. Click map for next, or Finish.`);
            } else if (isAddingVerticesToRegion) handleMapClickForVertexAdd(coords);
        }
        function handleMapClickForLineCreation(e) { 
            if (!isCreatingLine) return;
            const coords = [Math.round(e.latlng.lat), Math.round(e.latlng.lng)];
            tempLineVertices.push(coords); updateLineVerticesCount();
            if (tempLineLayer) map.removeLayer(tempLineLayer);
            if (tempLineVertices.length >= 1) {
                const lineOpts = { color: lineColorInput.value || '#808080', weight: parseInt(lineWeightInput.value) || 3, dashArray: lineDashArrayInput.value.trim() || null, opacity: 0.7 };
                tempLineLayer = (tempLineVertices.length === 1) ? L.circleMarker(tempLineVertices[0], {...lineOpts, radius: lineOpts.weight + 2, fillOpacity: 0.5 }) : L.polyline(tempLineVertices, lineOpts);
                tempLineLayer.addTo(map);
            }
            setStatus(`Added line vertex ${tempLineVertices.length}. Click map for next, or Finish Line.`);
        }


        function finishRegionCreation() { 
            if (!isCreatingRegion || tempRegionVertices.length < 3) { alert("A region needs at least 3 vertices."); return; }
            const regionName = regionNameInput.value.trim(), regionPronunciation = regionPronunciationInput.value.trim(), regionType = regionTypeSelect.value, regionValue = regionValueInput.value.trim();
            const regionColor = regionColorInput.value, regionFillColor = regionFillColorInput.value;
            const regionOpacity = parseFloat(regionOpacityInput.value);
            const regionDescription = regionDescriptionInput.value.trim(), regionWikiLink = regionWikiLinkInput.value.trim();
            if (!regionName) { alert("Region Name cannot be empty."); regionNameInput.focus(); return; }
            if (!regionType) { alert("Please select a region category."); regionTypeSelect.focus(); return; }
            if (!regionValue) { alert("Please enter a region sub-category."); regionValueInput.focus(); return; }
            if (isNaN(regionOpacity) || regionOpacity < 0 || regionOpacity > 1) { alert("Invalid Opacity (0.0-1.0)."); regionOpacityInput.focus(); return; }
            if (collectedRegions.some(r => r.name === regionName)) { alert(`A region named "${regionName}" already exists.`); regionNameInput.focus(); return; }
            const properties = collectProperties(regionPropertiesContainer);
            collectedRegions.push({ id: `region-${regionName.toLowerCase().replace(/\s+/g, '-')}`, name: regionName, pronunciation: regionPronunciation, type: regionType, value: regionValue, description: regionDescription, wikiLink: regionWikiLink, color: regionColor, fillColor: regionFillColor, fillOpacity: regionOpacity, coordinates: [...tempRegionVertices], properties: properties });
            updateRegionsOutput(); setStatus(`Region "${regionName}" created.`, 'success'); setRegionCreationState(false);
            regionNameInput.value = ''; regionPronunciationInput.value = ''; regionTypeSelect.value = ''; regionValueInput.value = ''; regionDescriptionInput.value = ''; regionWikiLinkInput.value = '';
            regionValueOptions.innerHTML = '';
            regionValueInput.disabled = true;
        }
        function cancelRegionCreation() { 
             if (!isCreatingRegion) return; setRegionCreationState(false); setStatus('Region creation cancelled.');
        }
        function finishLineCreation() { 
            if (!isCreatingLine || tempLineVertices.length < 2) { alert("A line needs at least 2 vertices."); return; }
            const lineName = lineNameInput.value.trim(), linePronunciation = linePronunciationInput.value.trim(), lineType = lineTypeSelect.value;
            const lineColor = lineColorInput.value, lineWeight = parseInt(lineWeightInput.value);
            const lineDashArray = lineDashArrayInput.value.trim();
            const lineDescription = lineDescriptionInput.value.trim(), lineWikiLink = lineWikiLinkInput.value.trim();
            if (isNaN(lineWeight) || lineWeight < 1) { alert("Invalid Line Weight."); lineWeightInput.focus(); return; }
            const lineId = `line-${currentMapObject.id || 'map'}-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`; 
            const properties = collectProperties(linePropertiesContainer);
            collectedLines.push({ id: lineId, name: lineName, pronunciation: linePronunciation, type: lineType, description: lineDescription, wikiLink: lineWikiLink, color: lineColor, weight: lineWeight, dashArray: lineDashArray, coordinates: [...tempLineVertices], properties: properties });
            updateLinesOutput(); setStatus(`Line "${lineName || lineId}" created.`, 'success'); 
            setLineCreationState(false);
            lineNameInput.value = ''; linePronunciationInput.value = ''; lineTypeSelect.value = ''; lineDescriptionInput.value = ''; lineWikiLinkInput.value = '';
            lineColorInput.value = '#808080'; lineWeightInput.value = '3'; lineDashArrayInput.value = '';
        }
        function cancelLineCreation() { 
            if (!isCreatingLine) return;
            setLineCreationState(false); setStatus('Line creation cancelled.');
        }

        // --- Region Vertex Editing Logic ---
        function startAddingVertices() { 
            if (!isEditingRegion || currentlyEditingRegionIndex < 0) return;
            if (isEditingVertices) { alert("Stop editing vertices first."); return; }
            if (isAddingVerticesToRegion) stopAddingVertices(true);
            else {
                addingVerticesData.index = currentlyEditingRegionIndex; addingVerticesData.newPoints = [];
                setVertexAddingState(true);
                if (editingPolygonLayer) editingPolygonLayer.setStyle({ dashArray: null, weight: 5 });
            }
        }
        function stopAddingVertices(userInitiated = false) { 
            if (!isAddingVerticesToRegion) return;
            const region = collectedRegions[addingVerticesData.index];
            if (addingVerticesData.newPoints.length > 0) {
                let closestSegmentIndex = -1, minDistanceSq = Infinity;
                const firstNewPoint = L.latLng(addingVerticesData.newPoints[0]);
                for (let i = 0; i < region.coordinates.length; i++) {
                    const p1 = L.latLng(region.coordinates[i]), p2 = L.latLng(region.coordinates[(i + 1) % region.coordinates.length]);
                    const closestPointOnSegment = L.GeometryUtil.closest(map, L.polyline([p1, p2]), firstNewPoint);
                    const distanceSq = firstNewPoint.distanceTo(closestPointOnSegment) ** 2;
                    if (distanceSq < minDistanceSq) { minDistanceSq = distanceSq; closestSegmentIndex = i; }
                }
                region.coordinates.splice(closestSegmentIndex + 1, 0, ...addingVerticesData.newPoints);
                updateRegionsOutput(); loadRegionForEditing(region.name);
                setStatus(`Added ${addingVerticesData.newPoints.length} vertices to '${region.name}'.`, 'success');
            } else if (userInitiated) setStatus(`Stopped adding vertices to '${region.name}'. No points added.`, 'info');
            addingVerticesData.index = -1; addingVerticesData.newPoints = []; setVertexAddingState(false);
            if (editingPolygonLayer) editingPolygonLayer.setStyle({ dashArray: "5, 5", weight: 3 });
        }
        function handleMapClickForVertexAdd(coords) { 
            if (!isAddingVerticesToRegion) return;
            addingVerticesData.newPoints.push(coords);
            if (editingVisualsLayerGroup) L.circleMarker(coords, { radius: 5, color: 'lime', fillColor: 'lime', fillOpacity: 0.8, pane: 'markerPane' }).addTo(editingVisualsLayerGroup);
            setStatus(`Added new vertex ${addingVerticesData.newPoints.length}. Click map for next, or Stop Adding.`);
        }
        function startEditingVertices() { 
            if (!isEditingRegion || currentlyEditingRegionIndex < 0) return;
            if (isAddingVerticesToRegion) { alert("Stop editing vertices first."); return; }
            if (isEditingVertices) stopEditingVertices(true);
            else { setVertexEditingState(true); createVertexMarkers(); }
        }
        function stopEditingVertices(userInitiated = false) { 
            if (!isEditingVertices) return;
            let changed = false;
            if (editingVisualsLayerGroup) {
                const region = collectedRegions[currentlyEditingRegionIndex]; const newCoords = [];
                const vertexMarkers = [];
                editingVisualsLayerGroup.eachLayer(layer => { if (layer.options.isVertexMarker) vertexMarkers.push(layer); });
                vertexMarkers.sort((a, b) => a.options.vertexIndex - b.options.vertexIndex);
                vertexMarkers.forEach((marker, index) => {
                    const newLatLng = marker.getLatLng(), newCoord = [Math.round(newLatLng.lat), Math.round(newLatLng.lng)];
                    newCoords.push(newCoord);
                    if (index < region.coordinates.length && (region.coordinates[index][0] !== newCoord[0] || region.coordinates[index][1] !== newCoord[1])) changed = true;
                });
                if (newCoords.length !== region.coordinates.length) changed = true;
                if (changed) {
                    region.coordinates = newCoords; updateRegionsOutput(); loadRegionForEditing(region.name);
                    setStatus(`Vertices updated for region '${region.name}'.`, 'success');
                } else if (userInitiated) setStatus(`Stopped editing vertices for '${region.name}'. No changes made.`, 'info');
            }
            clearEditingVisuals(); setVertexEditingState(false);
        }
        function createVertexMarkers() { 
            if (!isEditingRegion || currentlyEditingRegionIndex < 0 || !editingPolygonLayer) return;
            clearEditingVisuals(); editingVisualsLayerGroup = L.layerGroup().addTo(map);
            const region = collectedRegions[currentlyEditingRegionIndex]; const latLngs = region.coordinates;
            editingPolygonLayer = L.polygon(latLngs, { color: region.color || "#3388ff", fillColor: region.fillColor || "#3388ff", fillOpacity: region.fillOpacity ?? 0.2, weight: 3, dashArray: "5, 5" }).addTo(editingVisualsLayerGroup);
            latLngs.forEach((latLng, index) => addVertexMarker(latLng, index));
            addMidpointMarkers();
        }
        function addVertexMarker(latLng, index) { 
             const marker = L.marker(latLng, { draggable: true, icon: L.divIcon({ className: 'vertex-marker', iconSize: [12, 12], iconAnchor: [6, 6] }), isVertexMarker: true, vertexIndex: index }).addTo(editingVisualsLayerGroup);
             marker.on('drag', updatePolygonFromMarkers);
             marker.on('dragend', () => { const newLatLng = marker.getLatLng(); marker.setLatLng([Math.round(newLatLng.lat), Math.round(newLatLng.lng)]); updatePolygonFromMarkers(); });
             marker.on('click', (e) => {
                 L.DomEvent.stopPropagation(e); 
                 if (activeVertexMarker && activeVertexMarker._icon) activeVertexMarker._icon.classList.remove('active');
                 activeVertexMarker = marker;
                 if (marker._icon) marker._icon.classList.add('active');
                 updateStatus();
             });
             return marker;
        }
        function addMidpointMarkers() { 
            if (!editingVisualsLayerGroup || !editingPolygonLayer) return;
            const latLngs = editingPolygonLayer.getLatLngs()[0];
            editingVisualsLayerGroup.eachLayer(layer => { if (layer.options.isMidpointMarker) editingVisualsLayerGroup.removeLayer(layer); });
            for (let i = 0; i < latLngs.length; i++) {
                const p1 = latLngs[i], p2 = latLngs[(i + 1) % latLngs.length];
                const midPoint = L.latLng((p1.lat + p2.lat) / 2, (p1.lng + p2.lng) / 2);
                const midMarker = L.marker(midPoint, { draggable: true, icon: L.divIcon({ className: 'new-vertex-marker', iconSize: [8, 8], iconAnchor: [4, 4] }), isMidpointMarker: true, segmentStartIndex: i }).addTo(editingVisualsLayerGroup);
                midMarker.on('dragstart', (e) => {
                    const marker = e.target, segmentStartIndex = marker.options.segmentStartIndex;
                    const newLatLng = marker.getLatLng(), newCoord = [Math.round(newLatLng.lat), Math.round(newLatLng.lng)];
                    editingVisualsLayerGroup.removeLayer(marker);
                    const currentLatLngs = editingPolygonLayer.getLatLngs()[0];
                    currentLatLngs.splice(segmentStartIndex + 1, 0, L.latLng(newCoord));
                    editingPolygonLayer.setLatLngs(currentLatLngs);
                    recreateAllVertexMarkers();
                    setStatus('Added new vertex. Continue dragging or Stop Editing.', 'info');
                });
            }
        }
        function recreateAllVertexMarkers() { 
            if (!editingVisualsLayerGroup || !editingPolygonLayer) return;
            const currentLatLngs = editingPolygonLayer.getLatLngs()[0];
            editingVisualsLayerGroup.eachLayer(layer => { if (layer.options.isVertexMarker || layer.options.isMidpointMarker) editingVisualsLayerGroup.removeLayer(layer); });
            currentLatLngs.forEach((latLng, index) => addVertexMarker(latLng, index));
            addMidpointMarkers();
        }
        function updatePolygonFromMarkers() { 
            if (!isEditingVertices || !editingVisualsLayerGroup || !editingPolygonLayer) return;
            const newLatLngs = [], vertexMarkers = [];
            editingVisualsLayerGroup.eachLayer(layer => { if (layer.options.isVertexMarker) vertexMarkers.push(layer); });
            vertexMarkers.sort((a, b) => a.options.vertexIndex - b.options.vertexIndex);
            vertexMarkers.forEach(marker => newLatLngs.push(marker.getLatLng()));
            if (newLatLngs.length >= 3) { editingPolygonLayer.setLatLngs(newLatLngs); addMidpointMarkers(); }
        }
        function clearEditingVisuals() { 
            if (editingVisualsLayerGroup) { map.removeLayer(editingVisualsLayerGroup); editingVisualsLayerGroup = null; editingPolygonLayer = null; }
            activeVertexMarker = null;
        }

        // --- Line Vertex Editing Logic ---
        function setVertexEditingState(editing) {
            isEditingVertices = editing;
            editVerticesBtn.textContent = editing ? 'Stop Editing Vertices' : 'Edit Vertices';
            addVerticesBtn.textContent = isAddingVerticesToRegion ? 'Stop Adding Vertices' : 'Add Vertices';
            mapElement.classList.toggle('vertex-editing-mode', editing);
            
            saveRegionChangesBtn.disabled = editing || isAddingVerticesToRegion;
            cancelRegionEditBtn.disabled = editing || isAddingVerticesToRegion;
            regionNameInput.disabled = editing || isAddingVerticesToRegion;
            regionTypeSelect.disabled = editing || isAddingVerticesToRegion;
            regionValueInput.disabled = editing || isAddingVerticesToRegion;
            editRegionSelect.disabled = editing || isAddingVerticesToRegion;
            startRegionBtn.disabled = true;

            if (editingVisualsLayerGroup) {
                editingVisualsLayerGroup.eachLayer(layer => {
                    if (layer.options.isVertexMarker && layer.dragging) {
                        if (editing) layer.dragging.enable();
                        else layer.dragging.disable();
                    }
                });
            }
            if(!editing) activeVertexMarker = null;
            updateStatus();
        }
        function setVertexAddingState(adding) {
            isAddingVerticesToRegion = adding;
            addVerticesBtn.textContent = adding ? 'Stop Adding Vertices' : 'Add Vertices';
            mapElement.classList.toggle('vertex-adding-mode', adding);
            
            saveRegionChangesBtn.disabled = adding || isEditingVertices;
            cancelRegionEditBtn.disabled = adding || isEditingVertices;
            editVerticesBtn.disabled = adding;
            regionNameInput.disabled = adding || isEditingVertices;
            regionTypeSelect.disabled = adding || isEditingVertices;
            regionValueInput.disabled = adding || isEditingVertices;
            editRegionSelect.disabled = adding || isEditingVertices;
            startRegionBtn.disabled = true;

            updateStatus();
        }
        function setLineVertexEditingState(editing) {
            isEditingLineVertices = editing;
            editLineVerticesBtn.textContent = editing ? 'Stop Editing Vertices' : 'Edit Vertices';
            mapElement.classList.toggle('line-vertex-editing-mode', editing);

            saveLineChangesBtn.disabled = editing;
            addLineVerticesBtn.disabled = editing;
            cancelLineEditBtn.disabled = editing;
            lineNameInput.disabled = editing; lineTypeSelect.disabled = editing;
            lineColorInput.disabled = editing; lineWeightInput.disabled = editing;
            lineDashArrayInput.disabled = editing; lineDescriptionInput.disabled = editing;
            lineWikiLinkInput.disabled = editing; editLineSelect.disabled = editing;
            startLineBtn.disabled = true;

            if (editingLineVisualsLayerGroup) {
                editingLineVisualsLayerGroup.eachLayer(layer => {
                    if (layer.options.isLineVertexMarker && layer.dragging) {
                        if (editing) layer.dragging.enable();
                        else layer.dragging.disable();
                    }
                });
            }
            if(!editing) activeVertexMarker = null;
            updateStatus();
        }

        function startEditingLineVertices() {
            if (!isEditingLine || currentlyEditingLineIndex < 0) return;
            if (isEditingLineVertices) {
                stopEditingLineVertices(true);
            } else {
                setLineVertexEditingState(true);
                createLineVertexMarkersAndPolyline();
                saveLineChangesBtn.classList.add('hidden');
                cancelLineEditBtn.classList.add('hidden');
                addLineVerticesBtn.classList.add('hidden');
                editLineVerticesBtn.textContent = 'Stop Editing Vertices';
            }
        }

        function stopEditingLineVertices(userInitiated = false) {
            if (!isEditingLineVertices) return;
            let changed = false;
            const line = collectedLines[currentlyEditingLineIndex];
            if (editingLineVisualsLayerGroup && line) {
                const newCoords = [];
                const vertexMarkers = [];
                editingLineVisualsLayerGroup.eachLayer(layer => { if (layer.options.isLineVertexMarker) vertexMarkers.push(layer); });
                vertexMarkers.sort((a, b) => a.options.vertexIndex - b.options.vertexIndex);
                vertexMarkers.forEach((marker, index) => {
                    const newLatLng = marker.getLatLng();
                    const newCoord = [Math.round(newLatLng.lat), Math.round(newLatLng.lng)];
                    newCoords.push(newCoord);
                    if (index < line.coordinates.length && (line.coordinates[index][0] !== newCoord[0] || line.coordinates[index][1] !== newCoord[1])) changed = true;
                });
                if (newCoords.length !== line.coordinates.length) changed = true;

                if (changed) {
                    line.coordinates = newCoords;
                    updateLinesOutput();
                    setStatus(`Line vertices updated for '${line.name || line.id}'. Save changes to persist.`, 'success');
                } else if (userInitiated) {
                    setStatus(`Stopped editing line vertices. No changes to vertices.`, 'info');
                }
            }
            clearLineEditingVisuals();
            setLineVertexEditingState(false);
            loadLineEdit(line.name || line.id);
            saveLineChangesBtn.classList.remove('hidden');
            cancelLineEditBtn.classList.remove('hidden');
            addLineVerticesBtn.classList.remove('hidden');
            editLineVerticesBtn.textContent = 'Edit Vertices';
            editLineVerticesBtn.classList.remove('hidden');
        }

        function createLineVertexMarkersAndPolyline() {
            if (!isEditingLine || currentlyEditingLineIndex < 0) return;
            clearLineEditingVisuals();
            editingLineVisualsLayerGroup = L.layerGroup().addTo(map);
            const line = collectedLines[currentlyEditingLineIndex];
            const latLngs = line.coordinates.map(c => L.latLng(c[0], c[1]));
            editingLinePolylineLayer = L.polyline(latLngs, {
                color: line.color || "#808080", weight: line.weight || 3,
                dashArray: line.dashArray || null, opacity: 0.9
            }).addTo(editingLineVisualsLayerGroup);
            latLngs.forEach((latLng, index) => addLineVertexMarker(latLng, index));
            addLineMidpointMarkers();
            if (tempLineLayer) map.removeLayer(tempLineLayer);
        }

        function addLineVertexMarker(latLng, index) {
            const marker = L.marker(latLng, {
                draggable: true,
                icon: L.divIcon({ className: 'line-vertex-marker', iconSize: [12, 12], iconAnchor: [6, 6] }),
                isLineVertexMarker: true, vertexIndex: index
            }).addTo(editingLineVisualsLayerGroup);
            marker.on('drag', updateLinePolylineFromMarkers);
            marker.on('dragend', () => {
                const newLatLng = marker.getLatLng();
                marker.setLatLng([Math.round(newLatLng.lat), Math.round(newLatLng.lng)]);
                updateLinePolylineFromMarkers();
            });
            marker.on('click', (e) => {
                L.DomEvent.stopPropagation(e);
                if (activeVertexMarker && activeVertexMarker._icon) activeVertexMarker._icon.classList.remove('active');
                activeVertexMarker = marker;
                if (marker._icon) marker._icon.classList.add('active');
                updateStatus();
            });
            return marker;
        }
        
        function addLineMidpointMarkers() {
            if (!editingLineVisualsLayerGroup || !editingLinePolylineLayer) return;
            const latLngs = editingLinePolylineLayer.getLatLngs();
            editingLineVisualsLayerGroup.eachLayer(layer => { if (layer.options.isLineMidpointMarker) editingLineVisualsLayerGroup.removeLayer(layer); });
            for (let i = 0; i < latLngs.length - 1; i++) {
                const p1 = latLngs[i], p2 = latLngs[i + 1];
                const midPoint = L.latLng((p1.lat + p2.lat) / 2, (p1.lng + p2.lng) / 2);
                const midMarker = L.marker(midPoint, {
                    draggable: true,
                    icon: L.divIcon({ className: 'new-line-vertex-marker', iconSize: [8, 8], iconAnchor: [4, 4] }),
                    isLineMidpointMarker: true, segmentStartIndex: i 
                }).addTo(editingLineVisualsLayerGroup);
                midMarker.on('dragstart', (e) => {
                    const draggedMidMarker = e.target;
                    const segmentStartIndex = draggedMidMarker.options.segmentStartIndex;
                    const newLatLng = draggedMidMarker.getLatLng();
                    const newCoord = [Math.round(newLatLng.lat), Math.round(newLatLng.lng)];
                    editingLineVisualsLayerGroup.removeLayer(draggedMidMarker);
                    const currentPolylineLatLngs = editingLinePolylineLayer.getLatLngs();
                    currentPolylineLatLngs.splice(segmentStartIndex + 1, 0, L.latLng(newCoord));
                    editingLinePolylineLayer.setLatLngs(currentPolylineLatLngs);
                    recreateAllLineVertexMarkers();
                    setStatus('Added new line vertex. Continue dragging or Stop Editing.', 'info');
                });
            }
        }

        function recreateAllLineVertexMarkers() {
            if (!editingLineVisualsLayerGroup || !editingLinePolylineLayer) return;
            const currentLatLngs = editingLinePolylineLayer.getLatLngs();
            editingLineVisualsLayerGroup.eachLayer(layer => {
                if (layer.options.isLineVertexMarker || layer.options.isLineMidpointMarker) {
                    editingLineVisualsLayerGroup.removeLayer(layer);
                }
            });
            currentLatLngs.forEach((latLng, index) => addLineVertexMarker(latLng, index));
            addLineMidpointMarkers();
        }

        function updateLinePolylineFromMarkers() {
            if (!isEditingLineVertices || !editingLineVisualsLayerGroup || !editingLinePolylineLayer) return;
            const newLatLngs = [];
            const vertexMarkers = [];
            editingLineVisualsLayerGroup.eachLayer(layer => { if (layer.options.isLineVertexMarker) vertexMarkers.push(layer); });
            vertexMarkers.sort((a, b) => a.options.vertexIndex - b.options.vertexIndex);
            vertexMarkers.forEach(marker => newLatLngs.push(marker.getLatLng()));
            if (newLatLngs.length >= 2) {
                editingLinePolylineLayer.setLatLngs(newLatLngs);
                addLineMidpointMarkers();
            }
        }

        function clearLineEditingVisuals() {
            if (editingLineVisualsLayerGroup) {
                map.removeLayer(editingLineVisualsLayerGroup);
                editingLineVisualsLayerGroup = null;
                editingLinePolylineLayer = null;
            }
            activeVertexMarker = null;
        }


        function generateCompleteMapData() {
             if (!currentMapObject) {
                 alert("No map is currently loaded for saving.");
                 return null;
             }
            const updatedMasterData = JSON.parse(JSON.stringify(masterMapData));
            let mapToUpdate = null;
            function findMapByIdRecursive(items, id) {
                 for (const item of items) {
                     if (item.id === id) return item;
                     if (item.children && Array.isArray(item.children)) {
                         const found = findMapByIdRecursive(item.children, id);
                         if(found) return found;
                     }
                 }
                 return null;
            }
            mapToUpdate = findMapByIdRecursive(updatedMasterData, currentMapObject.id);

            if (!mapToUpdate) {
                if (updatedMasterData.length === 1 && updatedMasterData[0].id === currentMapObject.id) {
                     mapToUpdate = updatedMasterData[0];
                } else {
                     alert("Could not find the edited map in the master data structure. This is an unexpected error.");
                     return null;
                }
            }
            
            const sortedPoints = [...collectedPoints].sort((a, b) => a.name.localeCompare(b.name));
            const sortedRegions = [...collectedRegions].sort((a, b) => a.name.localeCompare(b.name));
            const sortedLines = [...collectedLines].sort((a, b) => (a.name || a.id).localeCompare(b.name || b.id));

            mapToUpdate.scalePixels = parseInt(scalePixelsInput.value) || 3;
            mapToUpdate.scaleUnits = parseFloat(scaleUnitsInput.value) || 1;
            delete mapToUpdate.scaleKilometers; // Remove old key if it exists
            mapToUpdate.blurb = mapBlurbInput.value || "";

            mapToUpdate.pointsOfInterest = sortedPoints.map(p => ({
                coords: p.coords, name: p.name || "", pronunciation: p.pronunciation || "", type: p.type || "Unknown",
                description: p.description || "", wikiLink: p.wikiLink || "",
                properties: p.properties || {}
            }));

            mapToUpdate.regions = sortedRegions.map(r => ({
                id: r.id || `region-${(r.name || "untitled").toLowerCase().replace(/\s+/g, '-')}`, name: r.name || "",
                pronunciation: r.pronunciation || "", description: r.description || "", type: r.type || "", value: r.value || "", color: r.color || "#3388ff",
                fillColor: r.fillColor || "#3388ff", fillOpacity: r.fillOpacity ?? 0.2,
                wikiLink: r.wikiLink || "", coordinates: r.coordinates || [],
                properties: r.properties || {}
            }));

            const filterGroups = { Regions: {} };
            sortedRegions.forEach(region => {
                if (region.type && region.value) {
                    if (!filterGroups.Regions[region.type]) {
                        filterGroups.Regions[region.type] = [];
                    }
                    if (!filterGroups.Regions[region.type].includes(region.value)) {
                        filterGroups.Regions[region.type].push(region.value);
                    }
                }
            });
            mapToUpdate.filterGroups = filterGroups;
            
            mapToUpdate.lines = sortedLines.map(l => ({
                id: l.id, name: l.name || "", pronunciation: l.pronunciation || "", type: l.type || "", color: l.color || "#808080",
                weight: l.weight || 3, dashArray: l.dashArray || "",
                description: l.description || "", wikiLink: l.wikiLink || "",
                coordinates: l.coordinates || [],
                properties: l.properties || {}
            }));
            delete mapToUpdate.roads;
            
            if (masterMapData.length === 1 && updatedMasterData.length === 1 && masterMapData[0].id === mapToUpdate.id) {
                return mapToUpdate;
            }

            return updatedMasterData;
        }

        function exportMapData() { 
            const finalData = generateCompleteMapData();
            if (!finalData) { 
                setStatus('Export failed.', 'error'); return; 
            }
            const jsonString = JSON.stringify(finalData, null, 2);
            showJsonModal(jsonString, 'maps.json');
            setStatus('Complete map data ready to copy from the modal.', 'success');
        }
        function showJsonModal(jsonContent, filename) { 
            const existingModal = document.querySelector('.json-modal');
            if (existingModal) document.body.removeChild(existingModal);
            const modal = document.createElement('div'); modal.className = 'json-modal';
            modal.onclick = (e) => { if (e.target === modal) document.body.removeChild(modal); };
            const modalContent = document.createElement('div'); modalContent.className = 'json-modal-content';
            const header = document.createElement('div'); header.className = 'json-modal-header';
            const title = document.createElement('h3'); title.textContent = filename;
            const closeBtn = document.createElement('button'); closeBtn.textContent = 'Ã—'; closeBtn.className = 'json-modal-close';
            closeBtn.onclick = () => document.body.removeChild(modal);
            header.appendChild(title); header.appendChild(closeBtn);
            const textarea = document.createElement('textarea'); textarea.className = 'json-modal-textarea';
            textarea.value = jsonContent; textarea.readOnly = true;
            const copyBtn = document.createElement('button'); copyBtn.textContent = 'Copy to Clipboard'; copyBtn.className = 'json-modal-copy';
            copyBtn.onclick = () => {
                navigator.clipboard.writeText(textarea.value)
                    .then(() => { copyBtn.textContent = 'Copied!'; setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000); })
                    .catch(err => { console.error("Copy failed: ", err); copyBtn.textContent = 'Copy Failed!'; setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000); });
            };
            modalContent.appendChild(header); modalContent.appendChild(textarea); modalContent.appendChild(copyBtn);
            modal.appendChild(modalContent); document.body.appendChild(modal); textarea.focus(); textarea.select();
        }
        function copyCompleteJson() { 
            const finalData = generateCompleteMapData();
            if (!finalData) { setStatus('Copy failed.', 'error'); return; }
            const jsonString = JSON.stringify(finalData, null, 2);
            navigator.clipboard.writeText(jsonString)
                .then(() => setStatus('Complete map JSON copied!', 'success'))
                .catch(err => { setStatus('Failed to copy JSON.', 'error'); console.error("Copy JSON error:", err); });
        }

        function initMap() {
            if (map) return;
            map = L.map('map', { crs: L.CRS.Simple, minZoom: -5, maxZoom: 5, center: [0, 0], zoom: 0, doubleClickZoom: false });
            
            map.on('click', (e) => {
                if (activeVertexMarker) {
                    if (activeVertexMarker._icon) activeVertexMarker._icon.classList.remove('active');
                    activeVertexMarker = null;
                    updateStatus();
                }

                if (!currentMapObject) return;

                if (isEditingPoint || 
                    (currentMode === 'regions' && (isCreatingRegion || isAddingVerticesToRegion || isEditingVertices)) ||
                    (currentMode === 'lines' && (isCreatingLine || isEditingLineVertices))) {
                    
                    if (currentMode === 'points' && isEditingPoint && editingPointMarker) {
                        const newCoords = [Math.round(e.latlng.lat), Math.round(e.latlng.lng)];
                        lastClickedCoordsArray = newCoords;
                        coordsDisplay.textContent = `[${newCoords[0]}, ${newCoords[1]}]`;
                        editingPointMarker.setLatLng(e.latlng); 
                        setStatus('Point position updated by click. Modify details and Save or Cancel.');
                    } 
                    else if (currentMode === 'regions' && (isCreatingRegion || isAddingVerticesToRegion)) {
                        handleMapClickForRegion(e);
                    } 
                    else if (currentMode === 'lines' && isCreatingLine) { 
                        handleMapClickForLineCreation(e);
                    }
                    return; 
                }

                if (currentMode === 'points') {
                    lastClickedCoordsArray = [Math.round(e.latlng.lat), Math.round(e.latlng.lng)];
                    coordsDisplay.textContent = `[${lastClickedCoordsArray[0]}, ${lastClickedCoordsArray[1]}]`;
                    pointNameInput.value = ''; pointPronunciationInput.value = ''; poiTypeSelect.value = ''; pointDescriptionInput.value = ''; pointWikiLinkInput.value = '';
                    addPointBtn.disabled = !currentMapObject;
                    addPointPropertyBtn.disabled = false;
                    setStatus('Coordinates captured. Enter point details and Add.'); pointNameInput.focus();
                }
            });

            map.on('mousemove', (e) => {
                 if (!isEditingPoint && 
                     !(currentMode === 'regions' && (isCreatingRegion || isAddingVerticesToRegion || isEditingVertices)) && 
                     !(currentMode === 'lines' && (isCreatingLine || isEditingLineVertices)) 
                 ) {
                    coordsDisplay.textContent = `[${Math.round(e.latlng.lat)}, ${Math.round(e.latlng.lng)}]`;
                }
            });
        }
        
        function handleVertexDelete() {
            if (!activeVertexMarker) return;

            if (currentMode === 'regions' && isEditingVertices && editingPolygonLayer) {
                const latLngs = editingPolygonLayer.getLatLngs()[0];
                if (latLngs.length <= 3) {
                    alert("A region must have at least 3 vertices.");
                    return;
                }
                latLngs.splice(activeVertexMarker.options.vertexIndex, 1);
                editingPolygonLayer.setLatLngs(latLngs);
                activeVertexMarker = null;
                recreateAllVertexMarkers();
                setStatus('Vertex deleted.', 'info');
            } else if (currentMode === 'lines' && isEditingLineVertices && editingLinePolylineLayer) {
                const latLngs = editingLinePolylineLayer.getLatLngs();
                if (latLngs.length <= 2) {
                    alert("A line must have at least 2 vertices.");
                    return;
                }
                latLngs.splice(activeVertexMarker.options.vertexIndex, 1);
                editingLinePolylineLayer.setLatLngs(latLngs);
                activeVertexMarker = null;
                recreateAllLineVertexMarkers();
                setStatus('Vertex deleted.', 'info');
            }
        }

        // --- Custom Properties Logic ---
        function addPropertyRow(container, key = "", value = "") {
            const row = document.createElement('div');
            row.className = 'property-row';

            const keyInput = document.createElement('input');
            keyInput.type = 'text';
            keyInput.className = 'property-key';
            keyInput.placeholder = 'Property Name';
            keyInput.value = key;

            const valueInput = document.createElement('input');
            valueInput.type = 'text';
            valueInput.className = 'property-value';
            valueInput.placeholder = 'Value';
            valueInput.value = value;

            const removeBtn = document.createElement('button');
            removeBtn.textContent = 'X';
            removeBtn.className = 'remove-property-btn';
            removeBtn.title = 'Remove this property';
            removeBtn.onclick = () => row.remove();

            row.appendChild(keyInput);
            row.appendChild(valueInput);
            row.appendChild(removeBtn);
            container.appendChild(row);
        }

        function displayProperties(container, properties) {
            // Find the label and clear everything after it
            const label = container.querySelector('label');
            while (label && label.nextSibling) {
                container.removeChild(label.nextSibling);
            }

            if (properties && typeof properties === 'object') {
                for (const key in properties) {
                    if (Object.hasOwnProperty.call(properties, key)) {
                        addPropertyRow(container, key, properties[key]);
                    }
                }
            }
        }

        function collectProperties(container) {
            const properties = {};
            const rows = container.querySelectorAll('.property-row');
            rows.forEach(row => {
                const keyInput = row.querySelector('.property-key');
                const valueInput = row.querySelector('.property-value');
                const key = keyInput.value.trim();
                const value = valueInput.value.trim();
                if (key) { // Only save if a key is present
                    properties[key] = value;
                }
            });
            return properties;
        }


        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap(); 
            populateTypeDropdown();
            setMode('points');
            resetUIForNewMap(); 
            setStatus('Load a JSON file to begin.');

            document.addEventListener('keydown', (e) => {
                if ((e.key === 'Delete' || e.key === 'Backspace') && activeVertexMarker) {
                    e.preventDefault();
                    handleVertexDelete();
                }
            });

            jsonFileInput.addEventListener('change', handleJsonFileLoad);
            loadSubMapBtn.addEventListener('click', loadMapFromSelector);
            exportMapDataBtn.addEventListener('click', exportMapData);

            modeTabs.forEach(tab => tab.addEventListener('click', () => setMode(tab.dataset.mode)));

            addPointPropertyBtn.addEventListener('click', () => addPropertyRow(pointPropertiesContainer));
            addRegionPropertyBtn.addEventListener('click', () => addPropertyRow(regionPropertiesContainer));
            addLinePropertyBtn.addEventListener('click', () => addPropertyRow(linePropertiesContainer));


            addPointBtn.addEventListener('click', () => {
                if (!lastClickedCoordsArray) { 
                    alert("Click on the map to set coordinates for the new point."); 
                    return; 
                }
                const name = pointNameInput.value.trim(), pronunciation = pointPronunciationInput.value.trim(), type = poiTypeSelect.value;
                if (!name) { alert("Point Name cannot be empty."); pointNameInput.focus(); return; }
                if (!type) { alert("Please select a Point Type."); poiTypeSelect.focus(); return; }
                if (collectedPoints.some(p => p.name === name)) { alert(`Point "${name}" already exists.`); pointNameInput.focus(); return; }
                
                const properties = collectProperties(pointPropertiesContainer);
                const coordsToUse = lastClickedCoordsArray;
                collectedPoints.push({ coords: coordsToUse, name: name, pronunciation: pronunciation, type: type, description: pointDescriptionInput.value.trim(), wikiLink: pointWikiLinkInput.value.trim(), properties: properties });
                updatePointsOutput(); setStatus(`Point "${name}" added.`, 'success');
                pointNameInput.value = ''; pointPronunciationInput.value = ''; poiTypeSelect.value = ''; pointDescriptionInput.value = ''; pointWikiLinkInput.value = '';
                displayProperties(pointPropertiesContainer, {});
                coordsDisplay.textContent = '[Y, X]'; lastClickedCoordsArray = null; addPointBtn.disabled = true;
            });
            editPointSelect.addEventListener('change', (e) => e.target.value ? loadPointForEditing(e.target.value) : cancelPointEditing());
            savePointChangesBtn.addEventListener('click', savePointChanges);
            cancelPointEditBtn.addEventListener('click', cancelPointEditing);
            clearPointsBtn.addEventListener('click', () => {
                if (confirm('Clear all points for this map?')) { collectedPoints = []; updatePointsOutput(); setPointEditingState(false); setStatus('All points cleared.'); }
            });

            regionTypeSelect.addEventListener('change', () => {
                const selectedType = regionTypeSelect.value;
                regionValueOptions.innerHTML = '';
                regionValueInput.value = '';

                if (selectedType && currentMapObject && currentMapObject.filterGroups && currentMapObject.filterGroups.Regions && currentMapObject.filterGroups.Regions[selectedType]) {
                    const values = currentMapObject.filterGroups.Regions[selectedType];
                    values.sort().forEach(value => {
                        const option = document.createElement('option');
                        option.value = value;
                        regionValueOptions.appendChild(option);
                    });
                    regionValueInput.disabled = false;
                } else {
                    regionValueInput.disabled = true;
                }
                const lowerCaseType = selectedType.toLowerCase();
                if (regionTypeColors[lowerCaseType]) {
                    regionColorInput.value = regionTypeColors[lowerCaseType].color;
                    regionFillColorInput.value = regionTypeColors[lowerCaseType].fillColor;
                }
            });

            startRegionBtn.addEventListener('click', startRegionCreation);
            finishRegionBtn.addEventListener('click', finishRegionCreation);
            cancelRegionBtn.addEventListener('click', cancelRegionCreation);
            editRegionSelect.addEventListener('change', (e) => e.target.value ? loadRegionForEditing(e.target.value) : cancelRegionEditing());
            saveRegionChangesBtn.addEventListener('click', saveRegionChanges);
            cancelRegionEditBtn.addEventListener('click', cancelRegionEditing);
            addVerticesBtn.addEventListener('click', startAddingVertices);
            editVerticesBtn.addEventListener('click', startEditingVertices);
            clearRegionsBtn.addEventListener('click', () => {
                if (confirm('Clear all regions for this map?')) { collectedRegions = []; updateRegionsOutput(); setRegionEditingState(false); setRegionCreationState(false); setStatus('All regions cleared.'); }
            });
            regionColorInput.addEventListener('input', () => { const c = regionColorInput.value; if (tempRegionLayer && isCreatingRegion) tempRegionLayer.setStyle({ color: c }); if (editingPolygonLayer && (isEditingRegion || isEditingVertices)) editingPolygonLayer.setStyle({ color: c }); });
            regionFillColorInput.addEventListener('input', () => { const c = regionFillColorInput.value; if (tempRegionLayer && isCreatingRegion) tempRegionLayer.setStyle({ fillColor: c }); if (editingPolygonLayer && (isEditingRegion || isEditingVertices)) editingPolygonLayer.setStyle({ fillColor: c }); });
            regionOpacityInput.addEventListener('input', () => { const o = parseFloat(regionOpacityInput.value); if (!isNaN(o)) { if (tempRegionLayer && isCreatingRegion) tempRegionLayer.setStyle({ fillOpacity: o }); if (editingPolygonLayer && (isEditingRegion || isEditingVertices)) editingPolygonLayer.setStyle({ fillOpacity: o }); }});

            // Line Event Listeners 
            startLineBtn.addEventListener('click', startLineCreation);
            finishLineBtn.addEventListener('click', finishLineCreation);
            cancelLineBtn.addEventListener('click', cancelLineCreation);
            editLineSelect.addEventListener('change', (e) => e.target.value ? loadLineEdit(e.target.value) : cancelLineEdit());
            saveLineChangesBtn.addEventListener('click', saveLineChanges);
            editLineVerticesBtn.addEventListener('click', startEditingLineVertices);
            cancelLineEditBtn.addEventListener('click', cancelLineEdit);
            clearLinesBtn.addEventListener('click', () => {
                if (confirm('Clear all lines for this map?')) { collectedLines = []; updateLinesOutput(); setLineEditState(false); setLineCreationState(false); setStatus('All lines cleared.'); }
            });
            lineColorInput.addEventListener('input', () => { if (tempLineLayer && isCreatingLine) tempLineLayer.setStyle({ color: lineColorInput.value }); if (editingLinePolylineLayer && isEditingLineVertices) editingLinePolylineLayer.setStyle({color: lineColorInput.value}); });
            lineWeightInput.addEventListener('input', () => { if (tempLineLayer && isCreatingLine) tempLineLayer.setStyle({ weight: parseInt(lineWeightInput.value) || 3 }); if (editingLinePolylineLayer && isEditingLineVertices) editingLinePolylineLayer.setStyle({weight: parseInt(lineWeightInput.value) || 3 }); });
            lineDashArrayInput.addEventListener('input', () => { if (tempLineLayer && isCreatingLine) tempLineLayer.setStyle({ dashArray: lineDashArrayInput.value.trim() || null }); if (editingLinePolylineLayer && isEditingLineVertices) editingLinePolylineLayer.setStyle({dashArray: lineDashArrayInput.value.trim() || null}); });
            
            showAllRegionsToggle.addEventListener('change', (e) => {
                showAllRegionsWhileEditing = e.target.checked;
                if (isEditingRegion) {
                    toggleOtherRegionsVisibility(showAllRegionsWhileEditing, currentlyEditingRegionIndex);
                }
            });

            viewJsonBtn.addEventListener('click', exportMapData);
            copyJsonBtn.addEventListener('click', copyCompleteJson);
        });
    </script>
</body>
</html>