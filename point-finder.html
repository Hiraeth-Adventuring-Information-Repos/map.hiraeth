<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Editor Tool</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
        crossorigin=""/>
    <style>
        /* --- Oldschool Style --- */
        body {
            font-family: "MS Sans Serif", "Tahoma", "Verdana", sans-serif;
            margin: 0; padding: 0; display: flex; flex-direction: column;
            height: 100vh; background-color: #c0c0c0; color: #000000;
            font-size: 12px;
        }
        .controls {
            padding: 8px 10px; background-color: #c0c0c0;
            border-bottom: 2px solid #808080; display: flex; flex-wrap: wrap;
            gap: 8px; align-items: flex-start;
        }
        .mode-selector {
            display: flex; margin-bottom: 8px;
        }
        .mode-tab {
            padding: 4px 10px; cursor: pointer; background-color: #c0c0c0;
            border: 1px solid #808080; border-left-color: #ffffff;
            border-top-color: #ffffff; font-weight: bold;
            box-shadow: inset -1px -1px 0px #404040, inset 1px 1px 0px #dfdfdf;
        }
        .mode-tab.active {
            background-color: #a0a0a0;
            border: 1px solid #808080; border-right-color: #ffffff;
            border-bottom-color: #ffffff;
            box-shadow: inset 1px 1px 0px #404040, inset -1px -1px 0px #dfdfdf;
        }
        .control-group {
            display: flex; flex-direction: column; gap: 4px; padding: 6px;
            border: 1px solid #808080; border-right-color: #ffffff;
            border-bottom-color: #ffffff; background-color: #c0c0c0;
            box-shadow: inset 1px 1px 0px #404040, inset -1px -1px 0px #dfdfdf;
        }
        .control-row { display: flex; align-items: center; gap: 5px; width: 100%; }
        .controls label {
            font-weight: normal; white-space: nowrap; font-size: 1em;
            min-width: 75px; text-align: right; padding-right: 5px;
        }
        .controls input[type="text"], .controls select, .controls textarea, .controls input[type="number"], .controls input[type="color"] {
            padding: 3px 5px; border: 1px solid #808080; background-color: #ffffff;
            color: #000000; font-family: inherit; font-size: 1em; flex-grow: 1;
            box-shadow: inset 1px 1px 1px #404040; box-sizing: border-box;
        }
        .controls input[type="color"] {
            width: 40px; height: 24px; padding: 0; cursor: pointer;
        }
        .controls input[type="number"] {
            width: 60px;
        }
        .controls select {
             appearance: none;
             background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23000000%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E');
             background-repeat: no-repeat; background-position: right 5px top 50%;
             background-size: .65em auto; padding-right: 1.5em;
        }
        #mapSelect { min-width: 200px; } /* Style map select */
        #pointDescription, #regionDescription, #mapBlurb { height: 4.5em; resize: vertical; }
        .controls button, .output-buttons button, .summary-actions button, .json-modal-copy, .json-modal-close { /* Added modal buttons */
            padding: 4px 10px; cursor: pointer; color: #000000;
            border: 1px solid #808080; border-left-color: #ffffff;
            border-top-color: #ffffff; background-color: #c0c0c0;
            font-size: 1em;
            box-shadow: inset -1px -1px 0px #404040, inset 1px 1px 0px #dfdfdf;
            text-align: center;
        }
        .controls button:active, .output-buttons button:active, .summary-actions button:active, .json-modal-copy:active, .json-modal-close:active { /* Added modal buttons */
             border: 1px solid #808080; border-right-color: #ffffff;
             border-bottom-color: #ffffff;
             box-shadow: inset 1px 1px 0px #404040, inset -1px -1px 0px #dfdfdf;
             background-color: #b0b0b0;
        }
        .controls button:disabled, .output-buttons button:disabled, .summary-actions button:disabled { /* Added summary buttons */
            color: #808080; background-color: #c0c0c0; cursor: default;
            box-shadow: none; border: 1px solid #a0a0a0;
        }
        .hidden { display: none !important; }
        #map {
            flex-grow: 1; width: 100%; background-color: #a0a0a0;
            border-top: 2px solid #808080; border-bottom: 2px solid #808080;
        }
        #map.disabled-map { pointer-events: none; opacity: 0.7; }
        #map.region-creation-mode, #map.vertex-adding-mode, #map.vertex-editing-mode { cursor: crosshair !important; } /* Cursor for region modes */
        .bottom-section {
             display: flex; flex-direction: column;
             border-top: 2px solid #808080; background-color: #c0c0c0;
        }
        .info-area { display: flex; padding: 8px 10px; gap: 10px; align-items: flex-start; }
        .left-info { display: flex; flex-direction: column; gap: 6px; align-items: flex-start; min-width: 180px; }
        .coords-section { display: flex; align-items: center; gap: 8px; }
        #coords-display {
            font-weight: normal; font-family: "Courier New", monospace; background-color: #ffffff;
            padding: 3px 6px; border: 1px solid #808080; box-shadow: inset 1px 1px 1px #404040;
            min-width: 90px; text-align: center;
        }
        .instructions { font-size: 0.9em; color: #404040; }
        #status { font-style: normal; color: #000000; font-size: 0.9em; margin-top: 4px; padding: 3px; border: 1px solid transparent; }
        #status.error { color: #ff0000; font-weight: bold; border: 1px dotted #ff0000; }
        #status.success { color: #008000; font-weight: bold; border: 1px dotted #008000; }
        .edit-selection { margin-top: 8px; }
        .edit-selection label { font-weight: normal; font-size: 1em; margin-bottom: 3px; display: block; text-align: left; }
        #editPointSelect, #editRegionSelect { width: 100%; }
        .map-summary { /* NEW Summary Area Style */
            flex-grow: 1; display: flex; flex-direction: column; gap: 6px;
            padding: 6px; border: 1px solid #808080; border-right-color: #ffffff;
            border-bottom-color: #ffffff; background-color: #c0c0c0;
            box-shadow: inset 1px 1px 0px #404040, inset -1px -1px 0px #dfdfdf;
        }
        .map-summary h3 { margin: 0 0 5px 0; font-size: 1.1em; }
        .summary-stats p { margin: 2px 0; font-size: 1em; }
        .summary-stats span { font-weight: bold; }
        .summary-actions { display: flex; gap: 8px; margin-top: 8px; }
        .summary-actions button { font-size: 0.9em; }

        .leaflet-popup-content-wrapper { background: #f0f0f0; color: #000000; border: 1px solid #808080; border-radius: 0; box-shadow: 2px 2px 3px rgba(0,0,0,0.3); }
        .leaflet-popup-content { font-family: inherit; font-size: 1em; margin: 8px 10px; }
        .leaflet-popup-tip-container { width: 20px; height: 10px; }
        .leaflet-popup-tip { background: #f0f0f0; border: 1px solid #808080; border-left: none; border-top: none; box-shadow: none; }
        .leaflet-marker-icon { filter: drop-shadow(1px 1px 1px rgba(0,0,0,0.5)); }
        /* Style for vertex markers */
        .vertex-marker {
            background-color: rgba(255, 0, 0, 0.7); /* Red */
            border: 1px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
            cursor: grab; /* Indicate draggable */
        }
        .vertex-marker:active {
            cursor: grabbing;
        }
        .new-vertex-marker {
            background-color: rgba(0, 255, 0, 0.7); /* Green */
            border: 1px solid #fff;
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
        }

        /* --- NEW JSON Modal Styles --- */
        .json-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6); /* Darker overlay */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000; /* Ensure it's on top */
            padding: 20px;
            box-sizing: border-box;
        }
        .json-modal-content {
            background-color: #c0c0c0;
            border: 1px solid #808080;
            border-left-color: #ffffff; /* 3D effect */
            border-top-color: #ffffff;
            box-shadow: inset -1px -1px 0px #404040, inset 1px 1px 0px #dfdfdf, 3px 3px 5px rgba(0,0,0,0.3); /* Inner + Outer shadow */
            width: 90%;
            max-width: 800px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }
        .json-modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #808080;
        }
        .json-modal-header h3 {
            margin: 0;
            font-size: 1.1em;
            font-weight: bold;
        }
        .json-modal-close {
            font-size: 1.4em;
            font-weight: bold;
            line-height: 1;
            padding: 0px 6px 2px 6px; /* Adjust padding for better look */
        }
        .json-modal-textarea {
            width: 100%;
            flex-grow: 1; /* Take available space */
            min-height: 200px; /* Ensure minimum height */
            font-family: "Courier New", monospace;
            font-size: 0.95em;
            border: 1px solid #808080;
            background-color: #ffffff;
            color: #000000;
            padding: 10px;
            box-sizing: border-box;
            margin-bottom: 10px;
            resize: none; /* Disable manual resize */
            box-shadow: inset 1px 1px 1px #404040;
            white-space: pre;
            overflow: auto; /* Add scrollbars if needed */
        }
        .json-modal-copy {
            align-self: flex-end; /* Position button to the right */
        }
    </style>
</head>
<body>

    <div class="controls">
        <!-- Map Selection & Loading Group -->
        <div class="control-group">
            <div class="mode-selector">
                <div class="mode-tab active" data-mode="points">Points</div>
                <div class="mode-tab" data-mode="regions">Regions</div>
            </div>
            <div class="control-row">
                <label for="mapSelect">Select Map:</label>
                <select id="mapSelect">
                    <option value="">-- Choose a map --</option>
                    <!-- Options populated by JS -->
                </select>
            </div>
            <div class="control-row">
                <button id="loadMapBtn">Load Map & Data</button>
            </div>
            <!-- Map Details -->
            <div class="control-row">
                <label for="scalePixels">Scale (Pixels):</label>
                <input type="number" id="scalePixels" value="3" min="1">
            </div>
            <div class="control-row">
                <label for="scaleKilometers">Scale (Units):</label>
                <input type="number" id="scaleKilometers" value="1" min="0.1" step="0.1">
            </div>
            <div class="control-row">
                <label for="mapBlurb">Map Blurb:</label>
                <textarea id="mapBlurb" placeholder="Brief description of this map (HTML allowed)"></textarea>
            </div>
            <!-- Export Button -->
            <div class="control-row">
                 <button id="exportMapDataBtn" disabled>View/Export Map Data (JSON)</button> <!-- Updated Label -->
            </div>
            <!-- Removed Copy Complete JSON button from here -->
        </div>

        <!-- Point Controls -->
        <div class="control-group point-controls">
            <div class="control-row">
                <label for="pointName">Point Name:</label>
                <input type="text" id="pointName" placeholder="Click map first or select point">
            </div>
            <div class="control-row">
                <label for="poiTypeSelect">Type:</label>
                <select id="poiTypeSelect">
                    <option value="">--Select Type--</option>
                </select>
            </div>
            <div class="control-row">
                <label for="pointDescription">Description:</label>
                <textarea id="pointDescription"></textarea>
            </div>
            <div class="control-row">
                <label for="pointWikiLink">Wiki Link:</label>
                <input type="text" id="pointWikiLink" placeholder="Optional URL">
            </div>
            <div class="control-row">
                <button id="addPointBtn" disabled>Add New Point</button>
                <button id="savePointChangesBtn" class="hidden">Save Changes</button>
                <button id="cancelPointEditBtn" class="hidden">Cancel Edit</button>
                <button id="clearPointsBtn" disabled>Clear All Points</button> <!-- Moved Clear button here -->
            </div>
        </div>

        <!-- Region Controls -->
        <div class="control-group region-controls hidden">
            <div class="control-row">
                <label for="regionName">Region Name:</label>
                <input type="text" id="regionName" placeholder="Enter region name">
            </div>
            <div class="control-row">
                <label for="regionTypeSelect">Type:</label>
                <select id="regionTypeSelect">
                    <option value="">--Select Type--</option>
                    <option value="political">Political</option>
                    <option value="terrain">Terrain</option>
                    <option value="climate">Climate</option>
                    <option value="cultural">Cultural</option>
                    <option value="other">Other</option>
                </select>
            </div>
            <div class="control-row">
                <label for="regionColor">Border Color:</label>
                <input type="color" id="regionColor" value="#3388ff">
            </div>
            <div class="control-row">
                <label for="regionFillColor">Fill Color:</label>
                <input type="color" id="regionFillColor" value="#3388ff">
            </div>
            <div class="control-row">
                <label for="regionOpacity">Fill Opacity:</label>
                <input type="number" id="regionOpacity" min="0.0" max="1.0" step="0.05" value="0.2">
            </div>
            <div class="control-row">
                <label for="regionDescription">Description:</label>
                <textarea id="regionDescription"></textarea>
            </div>
            <div class="control-row">
                <label for="regionWikiLink">Wiki Link:</label>
                <input type="text" id="regionWikiLink" placeholder="Optional URL">
            </div>
            <div class="control-row">
                <button id="startRegionBtn" disabled>Start Region</button>
                <button id="finishRegionBtn" class="hidden">Finish Region</button>
                <button id="cancelRegionBtn" class="hidden">Cancel</button>
                <button id="clearRegionsBtn" disabled>Clear All Regions</button> <!-- Moved Clear button here -->
            </div>
            <div class="control-row">
                <button id="saveRegionChangesBtn" class="hidden">Save Changes</button>
                <button id="addVerticesBtn" class="hidden">Add Vertices</button>
                <button id="editVerticesBtn" class="hidden">Edit Vertices</button>
                <button id="cancelRegionEditBtn" class="hidden">Cancel Edit</button>
            </div>
        </div>
        <span id="status">Select and load a map image first.</span>
    </div>

    <div id="map"></div>

    <div class="bottom-section">
        <div class="info-area">
            <div class="left-info">
                <!-- Point Mode Info -->
                <div class="point-info">
                    <span class="instructions">Click map for new coords:</span>
                    <div class="coords-section">
                        <span id="coords-display">[Y, X]</span>
                    </div>
                    <div class="edit-selection">
                        <label for="editPointSelect">Edit Existing Point:</label>
                        <select id="editPointSelect">
                            <option value="">--Select Point to Edit--</option>
                        </select>
                    </div>
                </div>
                <!-- Region Mode Info -->
                <div class="region-info hidden">
                    <span class="instructions">Click map to place vertices:</span>
                    <div class="coords-section">
                        <span id="region-vertices-count">0 vertices</span>
                    </div>
                    <div class="edit-selection">
                        <label for="editRegionSelect">Edit Existing Region:</label>
                        <select id="editRegionSelect">
                            <option value="">--Select Region to Edit--</option>
                        </select>
                    </div>
                </div>
            </div>

            <!-- NEW Map Summary Area -->
            <div class="map-summary">
                <h3>Map Data Summary</h3>
                <div class="summary-stats">
                    <p>Points: <span id="points-count">0</span></p>
                    <p>Regions: <span id="regions-count">0</span></p>
                </div>
                <div class="summary-actions">
                    <button id="viewJsonBtn" disabled>View Complete JSON</button>
                    <button id="copyJsonBtn" disabled>Copy Complete JSON</button>
                </div>
            </div>
            <!-- Removed old output-area -->
        </div>

        <!-- Removed Import Area -->
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
        crossorigin=""></script>

    <script>
        // --- DOM Element References ---
        const mapElement = document.getElementById('map');
        const mapSelect = document.getElementById('mapSelect');
        const loadMapBtn = document.getElementById('loadMapBtn');
        const exportMapDataBtn = document.getElementById('exportMapDataBtn'); // Now acts as View/Export
        const statusDisplay = document.getElementById('status');
        const modeTabs = document.querySelectorAll('.mode-tab');

        // Map Detail Elements
        const scalePixelsInput = document.getElementById('scalePixels');
        const scaleKilometersInput = document.getElementById('scaleKilometers');
        const mapBlurbInput = document.getElementById('mapBlurb');

        // Point Elements
        const pointNameInput = document.getElementById('pointName');
        const poiTypeSelect = document.getElementById('poiTypeSelect');
        const pointDescriptionInput = document.getElementById('pointDescription');
        const pointWikiLinkInput = document.getElementById('pointWikiLink');
        const addPointBtn = document.getElementById('addPointBtn');
        const savePointChangesBtn = document.getElementById('savePointChangesBtn');
        const cancelPointEditBtn = document.getElementById('cancelPointEditBtn');
        const coordsDisplay = document.getElementById('coords-display');
        const editPointSelect = document.getElementById('editPointSelect');
        const clearPointsBtn = document.getElementById('clearPointsBtn'); // Moved

        // Region Elements
        const regionNameInput = document.getElementById('regionName');
        const regionTypeSelect = document.getElementById('regionTypeSelect');
        const regionColorInput = document.getElementById('regionColor');
        const regionFillColorInput = document.getElementById('regionFillColor');
        const regionOpacityInput = document.getElementById('regionOpacity');
        const regionDescriptionInput = document.getElementById('regionDescription');
        const regionWikiLinkInput = document.getElementById('regionWikiLink');
        const startRegionBtn = document.getElementById('startRegionBtn');
        const finishRegionBtn = document.getElementById('finishRegionBtn');
        const cancelRegionBtn = document.getElementById('cancelRegionBtn');
        const saveRegionChangesBtn = document.getElementById('saveRegionChangesBtn');
        const addVerticesBtn = document.getElementById('addVerticesBtn');
        const editVerticesBtn = document.getElementById('editVerticesBtn');
        const cancelRegionEditBtn = document.getElementById('cancelRegionEditBtn');
        const editRegionSelect = document.getElementById('editRegionSelect');
        const regionVerticesCount = document.getElementById('region-vertices-count');
        const clearRegionsBtn = document.getElementById('clearRegionsBtn'); // Moved

        // Mode-specific UI groups
        const pointControls = document.querySelector('.point-controls');
        const regionControls = document.querySelector('.region-controls');
        const pointInfo = document.querySelector('.point-info');
        const regionInfo = document.querySelector('.region-info');

        // NEW Summary Elements
        const pointsCountDisplay = document.getElementById('points-count');
        const regionsCountDisplay = document.getElementById('regions-count');
        const viewJsonBtn = document.getElementById('viewJsonBtn');
        const copyJsonBtn = document.getElementById('copyJsonBtn');

        // --- State Variables ---
        let map = null; // Initialize map variable
        let imageLayer = null;
        let currentBounds = null;
        let lastClickedCoordsArray = null;
        let collectedPoints = [];
        let collectedRegions = [];
        let isEditingPoint = false;
        let isEditingRegion = false;
        let currentlyEditingPointIndex = -1;
        let currentlyEditingRegionIndex = -1;
        let currentMode = 'points'; // 'points' or 'regions'
        let currentMapId = null; // Store the ID of the loaded map

        // Region creation state
        let isCreatingRegion = false;
        let tempRegionVertices = [];
        let tempRegionLayer = null; // For preview during creation

        // Region vertex adding/editing state
        let isAddingVerticesToRegion = false;
        let isEditingVertices = false;
        let addingVerticesData = { index: -1, newPoints: [] };
        let editingVisualsLayerGroup = null;
        let editingPolygonLayer = null;

        // --- Predefined list of maps ---
        const availableMaps = [
            "Fair-Content.webp",
            "IceBeach.webp",
            "Cursed-Old-Lin.webp"
        ];
        const mapDirectory = "maps/";

        // --- POI Type Definitions ---
        const poiTypeGroups = {
            "Settlements": ["City", "Town", "Village", "Hamlet", "Settlement", "Capital"],
            "Structures": ["Castle", "Fortress", "Fort", "Tower", "Ruin", "Temple", "Shrine", "Mine", "Lighthouse", "Bridge", "Dungeon", "Lair", "Camp", "Asylum", "Landmark"],
            "Natural Features": ["Mountain", "Peak", "Forest", "Wood", "River", "Lake", "Cave", "Cavern", "Coast", "Bay", "Cove", "Swamp", "Marsh", "Desert", "Natural Landmark"],
            "Other": ["Point of Interest", "Region", "Portal"],
            "Unknown": ["Unknown"]
        };

        // --- Region Type Colors (defaults) ---
        const regionTypeColors = {
            "political": { color: "#3388ff", fillColor: "#3388ff" },
            "terrain": { color: "#33aa33", fillColor: "#33aa33" },
            "climate": { color: "#aa33aa", fillColor: "#aa33aa" },
            "cultural": { color: "#aaaa33", fillColor: "#aaaa33" },
            "other": { color: "#aa3333", fillColor: "#aa3333" }
        };

        // --- Helper Functions ---

        function setMode(mode) {
            currentMode = mode;

            // Update tab states
            modeTabs.forEach(tab => {
                tab.classList.toggle('active', tab.dataset.mode === mode);
            });

            // Toggle visibility of controls and info sections
            pointControls.classList.toggle('hidden', mode !== 'points');
            regionControls.classList.toggle('hidden', mode !== 'regions');
            pointInfo.classList.toggle('hidden', mode !== 'points');
            regionInfo.classList.toggle('hidden', mode !== 'regions');
            // Summary section is always visible

            // If changing mode, cancel any active edits or creation/adding/editing states
            if (mode === 'points') {
                cancelRegionCreation();
                cancelRegionEditing(); // This now also cancels vertex adding/editing
            } else { // mode === 'regions'
                cancelPointEditing();
            }

            // Update instructions
            updateStatus();
        }

        function populateMapSelector() {
            mapSelect.innerHTML = '<option value="">-- Choose a map --</option>';
            availableMaps.forEach(filename => {
                const option = document.createElement('option');
                option.value = filename;
                option.textContent = filename;
                mapSelect.appendChild(option);
            });
        }

        function populateTypeDropdown() {
            poiTypeSelect.innerHTML = '<option value="">--Select Type--</option>';
            for (const groupName in poiTypeGroups) {
                const optgroup = document.createElement('optgroup');
                optgroup.label = groupName;
                poiTypeGroups[groupName].forEach(type => {
                    const option = document.createElement('option');
                    option.value = type;
                    option.textContent = type;
                    optgroup.appendChild(option);
                });
                poiTypeSelect.appendChild(optgroup);
            }
        }

        function populatePointEditDropdown() {
            const previouslySelectedName = (currentlyEditingPointIndex >= 0 && currentlyEditingPointIndex < collectedPoints.length)
                                          ? collectedPoints[currentlyEditingPointIndex].name
                                          : null;

            editPointSelect.innerHTML = '<option value="">--Select Point to Edit--</option>';
            const sortedPoints = [...collectedPoints].sort((a, b) => a.name.localeCompare(b.name));

            sortedPoints.forEach(point => {
                const option = document.createElement('option');
                option.value = point.name;
                option.textContent = point.name;
                editPointSelect.appendChild(option);
            });

            if (previouslySelectedName) {
                editPointSelect.value = previouslySelectedName;
            } else {
                editPointSelect.value = "";
            }
            editPointSelect.disabled = collectedPoints.length === 0;
        }

        function populateRegionEditDropdown() {
            const previouslySelectedName = (currentlyEditingRegionIndex >= 0 && currentlyEditingRegionIndex < collectedRegions.length)
                                          ? collectedRegions[currentlyEditingRegionIndex].name
                                          : null;

            editRegionSelect.innerHTML = '<option value="">--Select Region to Edit--</option>';
            const sortedRegions = [...collectedRegions].sort((a, b) => a.name.localeCompare(b.name));

            sortedRegions.forEach(region => {
                const option = document.createElement('option');
                option.value = region.name;
                option.textContent = region.name;
                editRegionSelect.appendChild(option);
            });

            if (previouslySelectedName) {
                editRegionSelect.value = previouslySelectedName;
            } else {
                editRegionSelect.value = "";
            }
            editRegionSelect.disabled = collectedRegions.length === 0;
        }

        // --- UPDATED updatePointsOutput ---
        function updatePointsOutput() {
            // Update summary count
            const count = collectedPoints.length;
            pointsCountDisplay.textContent = count;

            // Enable/disable clear button
            clearPointsBtn.disabled = count === 0;

            // Update the edit dropdown
            populatePointEditDropdown();

            // Enable/disable global export/copy buttons if map is loaded
            const mapLoaded = !!imageLayer;
            exportMapDataBtn.disabled = !mapLoaded;
            viewJsonBtn.disabled = !mapLoaded;
            copyJsonBtn.disabled = !mapLoaded;
        }

        // --- UPDATED updateRegionsOutput ---
        function updateRegionsOutput() {
            // Update summary count
            const count = collectedRegions.length;
            regionsCountDisplay.textContent = count;

            // Enable/disable clear button
            clearRegionsBtn.disabled = count === 0;

            // Update the edit dropdown
            populateRegionEditDropdown();

            // Enable/disable global export/copy buttons if map is loaded
            const mapLoaded = !!imageLayer;
            exportMapDataBtn.disabled = !mapLoaded;
            viewJsonBtn.disabled = !mapLoaded;
            copyJsonBtn.disabled = !mapLoaded;
        }


        function setStatus(message, type = 'info') {
             statusDisplay.textContent = message;
             statusDisplay.className = type;
        }

        function updateStatus() {
            if (!imageLayer) {
                setStatus('Select and load a map image first.');
                return;
            }

            if (currentMode === 'points') {
                if (isEditingPoint) {
                    setStatus('Editing point. Modify details and Save Changes or Cancel.');
                } else {
                    setStatus('Click map for new point or select existing point to edit.');
                }
            } else { // regions mode
                if (isCreatingRegion) {
                    setStatus('Creating region. Click map to add vertices. Click Finish when done.');
                } else if (isAddingVerticesToRegion) {
                    setStatus(`Adding vertices to region '${collectedRegions[addingVerticesData.index].name}'. Click map to add, or click Stop.`);
                } else if (isEditingVertices) {
                    setStatus(`Editing vertices for region '${collectedRegions[currentlyEditingRegionIndex].name}'. Drag vertices to move, or click Stop.`);
                } else if (isEditingRegion) {
                    setStatus('Editing region. Modify details, Save Changes, Add Vertices, Edit Vertices, or Cancel.');
                } else {
                    setStatus('Fill in region details and click Start Region, or select existing region to edit.');
                }
            }
        }

        function setPointEditingState(editing, pointNameOrIndex = null) {
            isEditingPoint = editing;
            currentlyEditingPointIndex = -1; // Reset index

            if (editing && pointNameOrIndex !== null) {
                const nameToFind = (typeof pointNameOrIndex === 'number')
                                   ? collectedPoints[pointNameOrIndex]?.name
                                   : pointNameOrIndex;
                if (nameToFind) {
                    currentlyEditingPointIndex = collectedPoints.findIndex(p => p.name === nameToFind);
                }
            }

            addPointBtn.classList.toggle('hidden', editing);
            savePointChangesBtn.classList.toggle('hidden', !editing);
            cancelPointEditBtn.classList.toggle('hidden', !editing);
            mapElement.classList.toggle('disabled-map', editing);
            clearPointsBtn.classList.toggle('hidden', editing); // Hide clear button during edit

            if (!editing) {
                pointNameInput.value = '';
                poiTypeSelect.value = '';
                pointDescriptionInput.value = '';
                pointWikiLinkInput.value = '';
                coordsDisplay.textContent = '[Y, X]';
                lastClickedCoordsArray = null;
                addPointBtn.disabled = !imageLayer;
                editPointSelect.value = "";
            } else {
                 addPointBtn.disabled = true;
            }

            updateStatus();
        }

        function setRegionEditingState(editing, regionNameOrIndex = null) {
            isEditingRegion = editing;
            currentlyEditingRegionIndex = -1; // Reset index

            // --- Cancel vertex adding/editing if starting/stopping main edit ---
            if (isAddingVerticesToRegion) stopAddingVertices(false);
            if (isEditingVertices) stopEditingVertices(false);
            // ---

            if (editing && regionNameOrIndex !== null) {
                const nameToFind = (typeof regionNameOrIndex === 'number')
                                   ? collectedRegions[regionNameOrIndex]?.name
                                   : regionNameOrIndex;
                if (nameToFind) {
                    currentlyEditingRegionIndex = collectedRegions.findIndex(r => r.name === nameToFind);
                } else {
                    editing = false; // Couldn't find the region, cancel edit state
                }
            }

            startRegionBtn.classList.toggle('hidden', editing);
            saveRegionChangesBtn.classList.toggle('hidden', !editing);
            addVerticesBtn.classList.toggle('hidden', !editing);
            editVerticesBtn.classList.toggle('hidden', !editing);
            cancelRegionEditBtn.classList.toggle('hidden', !editing);
            clearRegionsBtn.classList.toggle('hidden', editing); // Hide clear button during edit
            // Map disabled only if editing details, not adding/editing vertices
            mapElement.classList.toggle('disabled-map', editing && !isAddingVerticesToRegion && !isEditingVertices);

            if (!editing) {
                if (!isCreatingRegion) { // Only reset fields if not in creation mode
                    regionNameInput.value = '';
                    regionTypeSelect.value = '';
                    regionDescriptionInput.value = '';
                    regionWikiLinkInput.value = '';
                    regionColorInput.value = '#3388ff';
                    regionFillColorInput.value = '#3388ff';
                    regionOpacityInput.value = '0.2';
                }
                startRegionBtn.disabled = !imageLayer; // Enable only if map is loaded
                editRegionSelect.value = "";

                // Clear any editing polygon visualization
                clearEditingVisuals();
            } else {
                startRegionBtn.disabled = true;
            }

            updateStatus();
        }

        function setRegionCreationState(creating) {
            isCreatingRegion = creating;
            tempRegionVertices = [];
            startRegionBtn.classList.toggle('hidden', creating);
            finishRegionBtn.classList.toggle('hidden', !creating);
            cancelRegionBtn.classList.toggle('hidden', !creating);
            clearRegionsBtn.classList.toggle('hidden', creating); // Hide clear button during creation
            mapElement.classList.toggle('region-creation-mode', creating);

            // Clear any temporary layers
            if (!creating && tempRegionLayer) {
                map.removeLayer(tempRegionLayer);
                tempRegionLayer = null;
            }

            updateRegionVerticesCount();
            updateStatus();
        }

        function setVertexAddingState(adding) {
            isAddingVerticesToRegion = adding;
            addVerticesBtn.textContent = adding ? 'Stop Adding Vertices' : 'Add Vertices';
            mapElement.classList.toggle('vertex-adding-mode', adding);
            // Map disabled only if editing details, not adding/editing vertices
            mapElement.classList.toggle('disabled-map', !adding && isEditingRegion && !isEditingVertices);

            // Disable/Enable other region controls during vertex adding
            saveRegionChangesBtn.disabled = adding || isEditingVertices;
            editVerticesBtn.disabled = adding; // Cannot edit vertices while adding
            cancelRegionEditBtn.disabled = adding;
            regionNameInput.disabled = adding || isEditingVertices;
            regionTypeSelect.disabled = adding || isEditingVertices;
            regionColorInput.disabled = adding || isEditingVertices;
            regionFillColorInput.disabled = adding || isEditingVertices;
            regionOpacityInput.disabled = adding || isEditingVertices;
            regionDescriptionInput.disabled = adding || isEditingVertices;
            regionWikiLinkInput.disabled = adding || isEditingVertices;
            editRegionSelect.disabled = adding || isEditingVertices;

            updateStatus();
        }

        function setVertexEditingState(editing) {
            isEditingVertices = editing;
            editVerticesBtn.textContent = editing ? 'Stop Editing Vertices' : 'Edit Vertices';
            mapElement.classList.toggle('vertex-editing-mode', editing);
            // Map disabled only if editing details, not adding/editing vertices
            mapElement.classList.toggle('disabled-map', !editing && isEditingRegion && !isAddingVerticesToRegion);

            // Disable/Enable other region controls during vertex editing
            saveRegionChangesBtn.disabled = editing || isAddingVerticesToRegion;
            addVerticesBtn.disabled = editing; // Cannot add vertices while editing
            cancelRegionEditBtn.disabled = editing;
            regionNameInput.disabled = editing || isAddingVerticesToRegion;
            regionTypeSelect.disabled = editing || isAddingVerticesToRegion;
            regionColorInput.disabled = editing || isAddingVerticesToRegion;
            regionFillColorInput.disabled = editing || isAddingVerticesToRegion;
            regionOpacityInput.disabled = editing || isAddingVerticesToRegion;
            regionDescriptionInput.disabled = editing || isAddingVerticesToRegion;
            regionWikiLinkInput.disabled = editing || isAddingVerticesToRegion;
            editRegionSelect.disabled = editing || isAddingVerticesToRegion;

            // Enable/disable marker dragging
            if (editingVisualsLayerGroup) {
                editingVisualsLayerGroup.eachLayer(layer => {
                    if (layer.options.isVertexMarker && layer.dragging) {
                        if (editing) {
                            layer.dragging.enable();
                        } else {
                            layer.dragging.disable();
                        }
                    }
                });
            }

            updateStatus();
        }


        function updateRegionVerticesCount() {
            const count = tempRegionVertices.length;
            regionVerticesCount.textContent = `${count} ${count === 1 ? 'vertex' : 'vertices'}`;
        }

        // --- UPDATED resetUIState ---
        function resetUIState() {
            setStatus('Select and load a map image first.');
            coordsDisplay.textContent = '[Y, X]';
            pointNameInput.value = '';
            poiTypeSelect.value = '';
            pointDescriptionInput.value = '';
            pointWikiLinkInput.value = '';
            regionNameInput.value = '';
            regionTypeSelect.value = '';
            regionDescriptionInput.value = '';
            regionWikiLinkInput.value = '';
            regionColorInput.value = '#3388ff';
            regionFillColorInput.value = '#3388ff';
            regionOpacityInput.value = '0.2';
            scalePixelsInput.value = '3'; // Reset map details
            scaleKilometersInput.value = '1';
            mapBlurbInput.value = '';
            addPointBtn.disabled = true;
            startRegionBtn.disabled = true;
            clearPointsBtn.disabled = true; // Moved button
            clearRegionsBtn.disabled = true; // Moved button
            exportMapDataBtn.disabled = true;
            viewJsonBtn.disabled = true; // Disable new buttons
            copyJsonBtn.disabled = true;
            pointsCountDisplay.textContent = '0'; // Reset counts
            regionsCountDisplay.textContent = '0';
            lastClickedCoordsArray = null;
            collectedPoints = [];
            collectedRegions = [];
            if (imageLayer && map && map.hasLayer(imageLayer)) {
                map.removeLayer(imageLayer);
            }
            imageLayer = null;
            currentBounds = null;
            currentMapId = null; // Reset map ID
            setPointEditingState(false);
            setRegionEditingState(false); // This now also resets vertex adding/editing state
            setRegionCreationState(false);
            populatePointEditDropdown();
            populateRegionEditDropdown();
            updateRegionVerticesCount();
            mapSelect.value = "";
        }

        // --- UPDATED loadImage Function ---
        async function loadImage() {
            const selectedFilename = mapSelect.value;
            if (!selectedFilename) { alert("Please select a map from the dropdown."); return; }

            const imageUrl = mapDirectory + selectedFilename;
            const jsonFilename = selectedFilename.replace(/\.(webp|png|jpg|jpeg)$/i, '.json');
            const jsonUrl = mapDirectory + jsonFilename;

            console.log("Loading map image:", imageUrl);
            console.log("Attempting to load map data:", jsonUrl);

            // Reset state when loading a new map
            resetUIState();

            loadMapBtn.disabled = true;
            setStatus('Loading image and map data...');

            try {
                // --- 1. Load Image ---
                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => reject(new Error(`Could not load image file: ${imageUrl}`));
                    img.src = imageUrl;
                });

                const mapWidth = img.naturalWidth;
                const mapHeight = img.naturalHeight;
                if (mapWidth === 0 || mapHeight === 0) {
                    throw new Error('Image has zero dimensions.');
                }
                setStatus(`Image loaded (${mapWidth}x${mapHeight}). Loading map data...`);
                currentBounds = [[0, 0], [mapHeight, mapWidth]];

                // --- 2. Load JSON Data ---
                let mapData = {};
                let jsonLoadError = null;
                try {
                    const response = await fetch(jsonUrl);
                    if (response.ok) {
                        mapData = await response.json();
                        console.log("Successfully loaded map data:", mapData);
                    } else if (response.status === 404) {
                        console.warn(`JSON file not found: ${jsonUrl}. Starting with empty data.`);
                        setStatus(`Image loaded. No existing map data found for ${jsonFilename}. Starting fresh.`);
                    } else {
                        throw new Error(`Failed to load JSON: ${response.status} ${response.statusText}`);
                    }
                } catch (fetchError) {
                    jsonLoadError = fetchError;
                    console.error(`Error fetching or parsing JSON: ${jsonUrl}`, fetchError);
                    setStatus(`Image loaded. Error loading map data: ${fetchError.message}. Starting fresh.`, 'error');
                }

                // --- 3. Initialize Map and Import Data ---
                if (!map) throw new Error("Map object not initialized.");

                imageLayer = L.imageOverlay(imageUrl, currentBounds);
                imageLayer.on('error', (e) => {
                    setStatus(`Error displaying image overlay.`, 'error');
                    if(imageLayer && map.hasLayer(imageLayer)) map.removeLayer(imageLayer);
                    imageLayer = null; loadMapBtn.disabled = false; exportMapDataBtn.disabled = true; viewJsonBtn.disabled = true; copyJsonBtn.disabled = true;
                });
                imageLayer.addTo(map);
                map.fitBounds(currentBounds);

                currentMapId = jsonFilename.replace('.json', '');

                scalePixelsInput.value = mapData.scalePixels || 3;
                scaleKilometersInput.value = mapData.scaleKilometers || 1;
                mapBlurbInput.value = mapData.blurb || "";

                let pointsImported = 0;
                let regionsImported = 0;
                try {
                    if (mapData.pointsOfInterest && Array.isArray(mapData.pointsOfInterest)) {
                        importPoints(mapData.pointsOfInterest, true);
                        pointsImported = mapData.pointsOfInterest.length;
                    }
                } catch (e) { console.error("Error during point import:", e); }
                try {
                    if (mapData.regions && Array.isArray(mapData.regions)) {
                        importRegions(mapData.regions, true);
                        regionsImported = mapData.regions.length;
                    }
                } catch (e) { console.error("Error during region import:", e); }

                let finalStatus = `Loaded: ${selectedFilename}. `;
                if (jsonLoadError) {
                    finalStatus += `Error loading data: ${jsonLoadError.message}. Starting fresh. `;
                } else {
                    finalStatus += `Imported ${pointsImported} points, ${regionsImported} regions. `;
                }
                finalStatus += `${currentMode === 'points' ? 'Click map for new point' : 'Fill in region details'}.`;
                setStatus(finalStatus, jsonLoadError ? 'error' : 'success');

                // Enable controls
                addPointBtn.disabled = true; // Still disabled until map click
                startRegionBtn.disabled = false;
                exportMapDataBtn.disabled = false; // Enable export/view button
                viewJsonBtn.disabled = false; // Enable summary buttons
                copyJsonBtn.disabled = false;

            } catch (error) {
                setStatus(`Error loading map: ${error.message}`, 'error');
                console.error("Map Loading Error:", error);
                resetUIState();
            } finally {
                loadMapBtn.disabled = false;
            }
        }

        // --- Internal importPoints Function (used by loadImage) ---
        function importPoints(dataToImport, suppressStatus = false) {
            let addedCount = 0;
            let skippedCount = 0;
            const existingNames = new Set(collectedPoints.map(p => p.name));

            dataToImport.forEach(item => {
                if (item && typeof item === 'object' &&
                    Array.isArray(item.coords) && item.coords.length === 2 &&
                    typeof item.name === 'string' && item.name.trim() !== "") {

                    const pointName = item.name.trim();
                    if (existingNames.has(pointName)) {
                        skippedCount++;
                    } else {
                        const lat = Number(item.coords[0]);
                        const lng = Number(item.coords[1]);

                        if (!isNaN(lat) && !isNaN(lng)) {
                            collectedPoints.push({
                                coords: [Math.round(lat), Math.round(lng)],
                                name: pointName,
                                type: item.type || "Unknown",
                                description: item.description || "",
                                wikiLink: item.wikiLink || ""
                            });
                            existingNames.add(pointName);
                            addedCount++;
                        } else {
                            console.warn("Skipping point with invalid coordinates:", item);
                            skippedCount++;
                        }
                    }
                } else {
                    console.warn("Skipping invalid/incomplete point during import:", item);
                    skippedCount++;
                }
            });

            updatePointsOutput(); // Updates count and dropdown
            if (!suppressStatus) { // Only show status if manually triggered (which is removed now)
                setStatus(`Import complete: Added ${addedCount} points, skipped ${skippedCount} (duplicates/invalid/incomplete).`, 'success');
            }
            setPointEditingState(false);
        }

        // --- Internal importRegions Function (used by loadImage) ---
        function importRegions(dataToImport, suppressStatus = false) {
            let addedCount = 0;
            let skippedCount = 0;
            const existingNames = new Set(collectedRegions.map(r => r.name));

            dataToImport.forEach(item => {
                if (item && typeof item === 'object' &&
                    Array.isArray(item.coordinates) && item.coordinates.length >= 3 &&
                    typeof item.name === 'string' && item.name.trim() !== "") {

                    const regionName = item.name.trim();
                    if (existingNames.has(regionName)) {
                        skippedCount++;
                    } else {
                        const validCoords = item.coordinates.every(coord =>
                            Array.isArray(coord) && coord.length === 2 &&
                            !isNaN(Number(coord[0])) && !isNaN(Number(coord[1])));

                        if (validCoords) {
                            collectedRegions.push({
                                id: item.id || `region-${regionName.toLowerCase().replace(/\s+/g, '-')}`,
                                name: regionName,
                                type: item.type || "",
                                description: item.description || "",
                                wikiLink: item.wikiLink || "",
                                color: item.color || "#3388ff",
                                fillColor: item.fillColor || "#3388ff",
                                fillOpacity: item.fillOpacity || 0.2,
                                coordinates: item.coordinates.map(coord => [Math.round(Number(coord[0])), Math.round(Number(coord[1]))])
                            });
                            existingNames.add(regionName);
                            addedCount++;
                        } else {
                            console.warn("Skipping region with invalid coordinates:", item);
                            skippedCount++;
                        }
                    }
                } else {
                    console.warn("Skipping invalid/incomplete region during import:", item);
                    skippedCount++;
                }
            });

            updateRegionsOutput(); // Updates count and dropdown
            if (!suppressStatus) { // Only show status if manually triggered (which is removed now)
                setStatus(`Import complete: Added ${addedCount} regions, skipped ${skippedCount} (duplicates/invalid/incomplete).`, 'success');
            }
            setRegionEditingState(false);
        }


        function loadPointForEditing(pointName) {
            const index = collectedPoints.findIndex(p => p.name === pointName);
            if (index === -1) {
                console.error("Point not found for editing:", pointName);
                setPointEditingState(false);
                return;
            }
            const point = collectedPoints[index];
            pointNameInput.value = point.name;
            poiTypeSelect.value = point.type || "";
            pointDescriptionInput.value = point.description || "";
            pointWikiLinkInput.value = point.wikiLink || "";
            coordsDisplay.textContent = `[${point.coords[0]}, ${point.coords[1]}]`;
            lastClickedCoordsArray = null; // Clear map click coords
            setPointEditingState(true, point.name);
        }

        function loadRegionForEditing(regionName) {
            const index = collectedRegions.findIndex(r => r.name === regionName);
            if (index === -1) {
                console.error("Region not found for editing:", regionName);
                setRegionEditingState(false);
                return;
            }

            const region = collectedRegions[index];
            regionNameInput.value = region.name;
            regionTypeSelect.value = region.type || "";
            regionDescriptionInput.value = region.description || "";
            regionWikiLinkInput.value = region.wikiLink || "";
            regionColorInput.value = region.color || "#3388ff";
            regionFillColorInput.value = region.fillColor || "#3388ff";
            regionOpacityInput.value = region.fillOpacity || 0.2;

            clearEditingVisuals();
            editingVisualsLayerGroup = L.layerGroup().addTo(map);

            editingPolygonLayer = L.polygon(region.coordinates, {
                color: region.color || "#3388ff",
                fillColor: region.fillColor || "#3388ff",
                fillOpacity: region.fillOpacity || 0.2,
                weight: 3,
                dashArray: "5, 5"
            });
            editingVisualsLayerGroup.addLayer(editingPolygonLayer);

            map.fitBounds(editingPolygonLayer.getBounds().pad(0.1));

            setRegionEditingState(true, region.name);
        }

        function savePointChanges() {
            if (!isEditingPoint || currentlyEditingPointIndex < 0 || currentlyEditingPointIndex >= collectedPoints.length) {
                 console.error("Save Changes called with invalid state:", isEditingPoint, currentlyEditingPointIndex);
                 return;
            }

            const originalPoint = collectedPoints[currentlyEditingPointIndex];
            const newName = pointNameInput.value.trim();
            const newType = poiTypeSelect.value;
            const newDescription = pointDescriptionInput.value.trim();
            const newWikiLink = pointWikiLinkInput.value.trim();

            if (!newName) { alert("Point Name cannot be empty."); pointNameInput.focus(); return; }
            if (!newType) { alert("Please select a Point Type."); poiTypeSelect.focus(); return; }

            if (newName !== originalPoint.name) {
                const nameConflict = collectedPoints.some((p, index) => index !== currentlyEditingPointIndex && p.name === newName);
                if (nameConflict) {
                    alert(`Another point named "${newName}" already exists.`); pointNameInput.focus(); return;
                }
            }
            originalPoint.name = newName;
            originalPoint.type = newType;
            originalPoint.description = newDescription;
            originalPoint.wikiLink = newWikiLink;

            updatePointsOutput();
            setStatus(`Point "${newName}" updated successfully.`, 'success');
            setPointEditingState(false);
        }

        function cancelPointEditing() {
            setPointEditingState(false);
            setStatus('Point editing cancelled.');
        }

        function saveRegionChanges() {
            if (!isEditingRegion || currentlyEditingRegionIndex < 0 || currentlyEditingRegionIndex >= collectedRegions.length) {
                console.error("Save Region Changes called with invalid state:", isEditingRegion, currentlyEditingRegionIndex);
                return;
            }

            const originalRegion = collectedRegions[currentlyEditingRegionIndex];
            const newName = regionNameInput.value.trim();
            const newType = regionTypeSelect.value;
            const newDescription = regionDescriptionInput.value.trim();
            const newWikiLink = regionWikiLinkInput.value.trim();
            const newColor = regionColorInput.value;
            const newFillColor = regionFillColorInput.value;
            const newOpacity = parseFloat(regionOpacityInput.value);

            if (!newName) { alert("Region Name cannot be empty."); regionNameInput.focus(); return; }
            if (isNaN(newOpacity) || newOpacity < 0 || newOpacity > 1) { alert("Invalid Opacity value (must be 0.0 to 1.0)."); regionOpacityInput.focus(); return; }

            if (newName !== originalRegion.name) {
                const nameConflict = collectedRegions.some((r, index) => index !== currentlyEditingRegionIndex && r.name === newName);
                if (nameConflict) {
                    alert(`Another region named "${newName}" already exists.`); regionNameInput.focus(); return;
                }
            }

            originalRegion.name = newName;
            originalRegion.type = newType;
            originalRegion.description = newDescription;
            originalRegion.wikiLink = newWikiLink;
            originalRegion.color = newColor;
            originalRegion.fillColor = newFillColor;
            originalRegion.fillOpacity = newOpacity;
            originalRegion.id = `region-${newName.toLowerCase().replace(/\s+/g, '-')}`;

            updateRegionsOutput();
            setStatus(`Region "${newName}" details updated successfully.`, 'success');
            setRegionEditingState(false);
        }

        function cancelRegionEditing() {
            setRegionEditingState(false);
            setStatus('Region editing cancelled.');
        }

        function startRegionCreation() {
            if (!imageLayer) { alert("Load a map first!"); return; }
            if (isEditingRegion) { alert("Finish editing the current region first."); return; }
            setRegionCreationState(true);
        }

        function handleMapClickForRegion(e) {
            if (!isCreatingRegion && !isAddingVerticesToRegion) return;

            const coords = [Math.round(e.latlng.lat), Math.round(e.latlng.lng)];

            if (isCreatingRegion) {
                tempRegionVertices.push(coords);
                updateRegionVerticesCount();

                if (tempRegionLayer) {
                    map.removeLayer(tempRegionLayer);
                }
                if (tempRegionVertices.length >= 2) {
                    const options = {
                        color: regionColorInput.value || '#3388ff',
                        fillColor: regionFillColorInput.value || '#3388ff',
                        fillOpacity: parseFloat(regionOpacityInput.value) || 0.2,
                        weight: 2,
                        dashArray: '5, 5'
                    };
                    tempRegionLayer = (tempRegionVertices.length === 2)
                        ? L.polyline(tempRegionVertices, options)
                        : L.polygon(tempRegionVertices, options);
                    tempRegionLayer.addTo(map);
                }
                setStatus(`Added vertex ${tempRegionVertices.length}. Click map for next, or Finish.`);
            } else if (isAddingVerticesToRegion) {
                handleMapClickForVertexAdd(coords);
            }
        }

        function finishRegionCreation() {
            if (!isCreatingRegion) return;
            if (tempRegionVertices.length < 3) {
                alert("A region needs at least 3 vertices.");
                return;
            }

            const regionName = regionNameInput.value.trim();
            const regionType = regionTypeSelect.value;
            const regionColor = regionColorInput.value;
            const regionFillColor = regionFillColorInput.value;
            const regionOpacity = parseFloat(regionOpacityInput.value);
            const regionDescription = regionDescriptionInput.value.trim();
            const regionWikiLink = regionWikiLinkInput.value.trim();

            if (!regionName) { alert("Region Name cannot be empty."); regionNameInput.focus(); return; }
            if (isNaN(regionOpacity) || regionOpacity < 0 || regionOpacity > 1) { alert("Invalid Opacity value (must be 0.0 to 1.0)."); regionOpacityInput.focus(); return; }

            const nameConflict = collectedRegions.some(r => r.name === regionName);
            if (nameConflict) {
                alert(`A region named "${regionName}" already exists.`); regionNameInput.focus(); return;
            }

            collectedRegions.push({
                id: `region-${regionName.toLowerCase().replace(/\s+/g, '-')}`,
                name: regionName,
                type: regionType,
                description: regionDescription,
                wikiLink: regionWikiLink,
                color: regionColor,
                fillColor: regionFillColor,
                fillOpacity: regionOpacity,
                coordinates: [...tempRegionVertices]
            });

            updateRegionsOutput();
            setStatus(`Region "${regionName}" created successfully.`, 'success');
            setRegionCreationState(false);
            regionNameInput.value = '';
            regionTypeSelect.value = '';
            regionDescriptionInput.value = '';
            regionWikiLinkInput.value = '';
        }

        function cancelRegionCreation() {
            if (!isCreatingRegion) return;
            setRegionCreationState(false);
            setStatus('Region creation cancelled.');
        }

        // --- Vertex Adding Logic ---
        function startAddingVertices() {
            if (!isEditingRegion || currentlyEditingRegionIndex < 0) return;
            if (isEditingVertices) { alert("Stop editing vertices first."); return; }

            if (isAddingVerticesToRegion) {
                stopAddingVertices(true);
            } else {
                addingVerticesData.index = currentlyEditingRegionIndex;
                addingVerticesData.newPoints = [];
                setVertexAddingState(true);
                if (editingPolygonLayer) {
                    editingPolygonLayer.setStyle({ dashArray: null, weight: 5 });
                }
            }
        }

        function stopAddingVertices(userInitiated = false) {
            if (!isAddingVerticesToRegion) return;

            const region = collectedRegions[addingVerticesData.index];
            if (addingVerticesData.newPoints.length > 0) {
                let closestSegmentIndex = -1;
                let minDistanceSq = Infinity;
                const firstNewPoint = L.latLng(addingVerticesData.newPoints[0]);

                for (let i = 0; i < region.coordinates.length; i++) {
                    const p1 = L.latLng(region.coordinates[i]);
                    const p2 = L.latLng(region.coordinates[(i + 1) % region.coordinates.length]);
                    const closestPointOnSegment = L.GeometryUtil.closest(map, L.polyline([p1, p2]), firstNewPoint);
                    const distanceSq = firstNewPoint.distanceTo(closestPointOnSegment) ** 2;

                    if (distanceSq < minDistanceSq) {
                        minDistanceSq = distanceSq;
                        closestSegmentIndex = i;
                    }
                }

                region.coordinates.splice(closestSegmentIndex + 1, 0, ...addingVerticesData.newPoints);

                updateRegionsOutput();
                loadRegionForEditing(region.name); // Reload to reflect changes
                setStatus(`Added ${addingVerticesData.newPoints.length} vertices to '${region.name}'.`, 'success');
            } else if (userInitiated) {
                setStatus(`Stopped adding vertices to '${region.name}'. No points added.`, 'info');
            }

            addingVerticesData.index = -1;
            addingVerticesData.newPoints = [];
            setVertexAddingState(false);
            if (editingPolygonLayer) { // Restore style if it exists (might have been reloaded)
                editingPolygonLayer.setStyle({ dashArray: "5, 5", weight: 3 });
            }
        }

        function handleMapClickForVertexAdd(coords) {
            if (!isAddingVerticesToRegion) return;

            addingVerticesData.newPoints.push(coords);

            if (editingVisualsLayerGroup) {
                L.circleMarker(coords, {
                    radius: 5, color: 'lime', fillColor: 'lime', fillOpacity: 0.8, pane: 'markerPane'
                }).addTo(editingVisualsLayerGroup);
            }

            setStatus(`Added new vertex ${addingVerticesData.newPoints.length}. Click map for next, or Stop Adding.`);
        }

        // --- Vertex Editing Logic ---
        function startEditingVertices() {
            if (!isEditingRegion || currentlyEditingRegionIndex < 0) return;
            if (isAddingVerticesToRegion) { alert("Stop adding vertices first."); return; }

            if (isEditingVertices) {
                stopEditingVertices(true);
            } else {
                setVertexEditingState(true);
                createVertexMarkers();
            }
        }

        function stopEditingVertices(userInitiated = false) {
            if (!isEditingVertices) return;

            let changed = false;
            if (editingVisualsLayerGroup) {
                const region = collectedRegions[currentlyEditingRegionIndex];
                const newCoords = [];

                // Collect current vertex marker positions in order
                const vertexMarkers = [];
                editingVisualsLayerGroup.eachLayer(layer => {
                    if (layer.options.isVertexMarker) {
                        vertexMarkers.push(layer);
                    }
                });
                vertexMarkers.sort((a, b) => a.options.vertexIndex - b.options.vertexIndex);

                vertexMarkers.forEach((marker, index) => {
                    const newLatLng = marker.getLatLng();
                    const newCoord = [Math.round(newLatLng.lat), Math.round(newLatLng.lng)];
                    newCoords.push(newCoord); // Add in sorted order

                    // Check if coordinate actually changed from original
                    if (index < region.coordinates.length && // Ensure original index exists
                        (region.coordinates[index][0] !== newCoord[0] ||
                         region.coordinates[index][1] !== newCoord[1])) {
                        changed = true;
                    }
                });

                 // Check if the number of vertices changed (due to midpoint drag)
                if (newCoords.length !== region.coordinates.length) {
                    changed = true;
                }

                if (changed) {
                    region.coordinates = newCoords; // Update with potentially reordered/new coords
                    updateRegionsOutput();
                    // Reload region to update polygon shape immediately and reset editing state
                    loadRegionForEditing(region.name);
                    setStatus(`Vertices updated for region '${region.name}'.`, 'success');
                } else if (userInitiated) {
                    setStatus(`Stopped editing vertices for '${region.name}'. No changes made.`, 'info');
                }
            }

            clearEditingVisuals(); // Remove markers
            setVertexEditingState(false);
            // Restore polygon style if needed (loadRegionForEditing already does this)
        }

        function createVertexMarkers() {
            if (!isEditingRegion || currentlyEditingRegionIndex < 0 || !editingPolygonLayer) return;

            clearEditingVisuals();
            editingVisualsLayerGroup = L.layerGroup().addTo(map);

            const region = collectedRegions[currentlyEditingRegionIndex];
            const latLngs = region.coordinates;

            editingPolygonLayer = L.polygon(latLngs, {
                color: region.color || "#3388ff",
                fillColor: region.fillColor || "#3388ff",
                fillOpacity: region.fillOpacity || 0.2,
                weight: 3,
                dashArray: "5, 5"
            }).addTo(editingVisualsLayerGroup);

            // Add draggable markers for each vertex
            latLngs.forEach((latLng, index) => {
                addVertexMarker(latLng, index);
            });

            // Add midpoint markers
            addMidpointMarkers();
        }

        function addVertexMarker(latLng, index) {
             const marker = L.marker(latLng, {
                draggable: true,
                icon: L.divIcon({
                    className: 'vertex-marker',
                    iconSize: [10, 10],
                    iconAnchor: [5, 5] // Center the icon
                }),
                isVertexMarker: true, // Custom option to identify these markers
                vertexIndex: index     // Store the original index
            }).addTo(editingVisualsLayerGroup);

            marker.on('drag', updatePolygonFromMarkers); // Update polygon shape while dragging
            marker.on('dragend', () => {
                // Snap to integer coordinates on drag end
                const newLatLng = marker.getLatLng();
                marker.setLatLng([Math.round(newLatLng.lat), Math.round(newLatLng.lng)]);
                updatePolygonFromMarkers(); // Update polygon with snapped coords
            });
            return marker;
        }

        function addMidpointMarkers() {
            if (!editingVisualsLayerGroup || !editingPolygonLayer) return;

            const latLngs = editingPolygonLayer.getLatLngs()[0]; // Get current polygon points

            // Remove existing midpoint markers first
            editingVisualsLayerGroup.eachLayer(layer => {
                if (layer.options.isMidpointMarker) {
                    editingVisualsLayerGroup.removeLayer(layer);
                }
            });

            // Add new midpoint markers
            for (let i = 0; i < latLngs.length; i++) {
                const p1 = latLngs[i];
                const p2 = latLngs[(i + 1) % latLngs.length]; // Wrap around
                const midPoint = L.latLng((p1.lat + p2.lat) / 2, (p1.lng + p2.lng) / 2);

                const midMarker = L.marker(midPoint, {
                    draggable: true, // Make midpoint draggable to become a new vertex
                    icon: L.divIcon({
                        className: 'new-vertex-marker', // Different style
                        iconSize: [8, 8],
                        iconAnchor: [4, 4]
                    }),
                    isMidpointMarker: true,
                    segmentStartIndex: i // Index of the vertex *before* this midpoint
                }).addTo(editingVisualsLayerGroup);

                midMarker.on('dragstart', (e) => {
                    // Convert this midpoint marker into a real vertex marker upon dragging
                    const marker = e.target;
                    const segmentStartIndex = marker.options.segmentStartIndex;
                    const newLatLng = marker.getLatLng(); // Position where drag started
                    const newCoord = [Math.round(newLatLng.lat), Math.round(newLatLng.lng)];

                    // Remove the midpoint marker itself
                    editingVisualsLayerGroup.removeLayer(marker);

                    // Insert the new coordinate into the polygon's latlngs
                    const currentLatLngs = editingPolygonLayer.getLatLngs()[0];
                    currentLatLngs.splice(segmentStartIndex + 1, 0, L.latLng(newCoord));
                    editingPolygonLayer.setLatLngs(currentLatLngs); // Update polygon shape

                    // Recreate all vertex and midpoint markers based on the new shape
                    // This is simpler than trying to re-index everything on the fly
                    recreateAllVertexMarkers();

                    // Find the newly created vertex marker and start dragging it
                    editingVisualsLayerGroup.eachLayer(layer => {
                        if (layer.options.isVertexMarker && layer.options.vertexIndex === segmentStartIndex + 1) {
                            // Manually trigger drag start on the new vertex marker
                            // This is a bit tricky and might require simulating events or finding a Leaflet internal way
                            // For simplicity, we'll just let the user click and drag the new vertex marker again after it appears.
                            // layer.fire('mousedown').fire('dragstart'); // This might not work reliably across browsers/versions
                        }
                    });

                    setStatus('Added new vertex. Continue dragging or Stop Editing.', 'info');
                });
            }
        }

        function recreateAllVertexMarkers() {
            if (!editingVisualsLayerGroup || !editingPolygonLayer) return;

            const currentLatLngs = editingPolygonLayer.getLatLngs()[0];

            // Remove existing vertex and midpoint markers
            editingVisualsLayerGroup.eachLayer(layer => {
                if (layer.options.isVertexMarker || layer.options.isMidpointMarker) {
                    editingVisualsLayerGroup.removeLayer(layer);
                }
            });

            // Add new vertex markers
            currentLatLngs.forEach((latLng, index) => {
                addVertexMarker(latLng, index);
            });

            // Add new midpoint markers
            addMidpointMarkers();
        }


        function updatePolygonFromMarkers() {
            if (!isEditingVertices || !editingVisualsLayerGroup || !editingPolygonLayer) return;

            const newLatLngs = [];
            const vertexMarkers = [];
            editingVisualsLayerGroup.eachLayer(layer => {
                if (layer.options.isVertexMarker) {
                    vertexMarkers.push(layer);
                }
            });
            // Sort markers by their vertex index to maintain shape
            vertexMarkers.sort((a, b) => a.options.vertexIndex - b.options.vertexIndex);

            vertexMarkers.forEach(marker => {
                newLatLngs.push(marker.getLatLng());
            });

            if (newLatLngs.length >= 3) {
                editingPolygonLayer.setLatLngs(newLatLngs);
                // Update midpoint markers dynamically as vertices move
                addMidpointMarkers();
            }
        }

        function clearEditingVisuals() {
            if (editingVisualsLayerGroup) {
                map.removeLayer(editingVisualsLayerGroup);
                editingVisualsLayerGroup = null;
                editingPolygonLayer = null; // Clear reference
            }
        }

        // --- Helper to generate the complete map data object ---
                // --- Helper to generate the complete map data object ---
                function generateCompleteMapData() {
            const selectedFilename = mapSelect.value;

            // --- DETAILED STATE CHECK ---
            console.log("--- generateCompleteMapData called ---");
            console.log("Current State Check:", {
                selectedFilename: selectedFilename,
                imageLayerExists: !!imageLayer,
                currentMapIdValue: currentMapId,
                currentBoundsValue: currentBounds ? JSON.stringify(currentBounds) : null // Stringify for better logging
            });

            // Attempt to fix mapSelect value if it seems wrong but other state exists
            if (!selectedFilename && imageLayer && currentMapId) {
                console.warn("mapSelect.value is empty, attempting to find matching option for mapId:", currentMapId);
                for (const option of mapSelect.options) {
                    // Check if the option's value (filename) contains the map ID
                    if (option.value && option.value.toLowerCase().includes(currentMapId.toLowerCase())) {
                        mapSelect.value = option.value;
                        console.log("Restored mapSelect.value to:", mapSelect.value);
                        // Re-read the value after setting it
                        selectedFilename = mapSelect.value;
                        break;
                    }
                }
                if (!selectedFilename) {
                     console.error("Could not find a matching option in mapSelect for mapId:", currentMapId);
                }
            }
            // --- END ATTEMPT TO FIX mapSelect ---


            // --- FINAL CHECK ---
            if (!selectedFilename || !imageLayer || !currentMapId || !currentBounds) {
                console.error("generateCompleteMapData failed: One or more required state variables are missing.");
                // Log which specific variable failed
                if (!selectedFilename) console.error("Reason: selectedFilename is missing or empty.");
                if (!imageLayer) console.error("Reason: imageLayer is null or undefined.");
                if (!currentMapId) console.error("Reason: currentMapId is null or undefined.");
                if (!currentBounds) console.error("Reason: currentBounds is null or undefined.");
                return null; // Not enough info to generate
            }
            console.log("All checks passed. Generating map data for:", currentMapId);
            // --- END FINAL CHECK ---


            // Sort points and regions alphabetically by name for the final output
            const sortedPoints = [...collectedPoints].sort((a, b) => a.name.localeCompare(b.name));
            const sortedRegions = [...collectedRegions].sort((a, b) => a.name.localeCompare(b.name));

            const mapData = {
                id: currentMapId,
                // Use selectedFilename to derive name if needed, ensure consistency
                name: currentMapId.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
                width: currentBounds[1][1], // lng corresponds to width
                height: currentBounds[1][0], // lat corresponds to height
                imageUrl: mapDirectory + selectedFilename, // Use the potentially corrected filename
                scalePixels: parseInt(scalePixelsInput.value) || 3,
                scaleKilometers: parseFloat(scaleKilometersInput.value) || 1,
                blurb: mapBlurbInput.value || "",
                pointsOfInterest: sortedPoints.map(p => ({
                    coords: p.coords,
                    name: p.name || "",
                    type: p.type || "Unknown",
                    description: p.description || "",
                    wikiLink: p.wikiLink || ""
                })),
                regions: sortedRegions.map(r => ({
                    id: r.id || `region-${(r.name || "untitled").toLowerCase().replace(/\s+/g, '-')}`,
                    name: r.name || "",
                    description: r.description || "",
                    type: r.type || "",
                    color: r.color || "#3388ff",
                    fillColor: r.fillColor || "#3388ff",
                    fillOpacity: r.fillOpacity || 0.2,
                    wikiLink: r.wikiLink || "",
                    coordinates: r.coordinates || []
                }))
            };
            console.log("Map data generated successfully.");
            return mapData;
        }

        // --- UPDATED Export Function (Shows Modal) ---
                // --- UPDATED Export Function (Shows Modal) ---
                function exportMapData() {
            console.log("--- exportMapData (View JSON) button clicked ---");
            // Log state *just before* calling generate
             console.log("State before calling generateCompleteMapData:", {
                selectedFilename: mapSelect.value,
                imageLayerExists: !!imageLayer,
                currentMapIdValue: currentMapId,
                currentBoundsValue: currentBounds ? JSON.stringify(currentBounds) : null
            });

            const mapData = generateCompleteMapData(); // This now has internal logging

            if (!mapData) {
                // The alert is now more specific if generateCompleteMapData returned null
                alert("Export failed: Map state is incomplete. Check console logs for details.");
                setStatus('Export failed. Map state incomplete. See console.', 'error');
                return;
            }

            const jsonString = JSON.stringify(mapData, null, 2); // Pretty print JSON
            showJsonModal(jsonString, mapData.id + '.json'); // Show in modal
            setStatus('Map data ready to copy from the modal.', 'success');
        }


        // --- NEW Show JSON Modal Function ---
        function showJsonModal(jsonContent, filename) {
            // Remove existing modal if any
            const existingModal = document.querySelector('.json-modal');
            if (existingModal) {
                document.body.removeChild(existingModal);
            }

            // Create modal elements
            const modal = document.createElement('div');
            modal.className = 'json-modal';
            // Close modal if clicking outside the content area
            modal.onclick = (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            };

            const modalContent = document.createElement('div');
            modalContent.className = 'json-modal-content';

            const header = document.createElement('div');
            header.className = 'json-modal-header';

            const title = document.createElement('h3');
            title.textContent = filename;

            const closeBtn = document.createElement('button');
            closeBtn.textContent = '';
            closeBtn.className = 'json-modal-close';
            closeBtn.title = 'Close'; // Tooltip
            closeBtn.onclick = () => document.body.removeChild(modal);

            header.appendChild(title);
            header.appendChild(closeBtn);

            const textarea = document.createElement('textarea');
            textarea.className = 'json-modal-textarea';
            textarea.value = jsonContent;
            textarea.readOnly = true;

            const copyBtn = document.createElement('button');
            copyBtn.textContent = 'Copy to Clipboard';
            copyBtn.className = 'json-modal-copy';
            copyBtn.onclick = () => {
                navigator.clipboard.writeText(textarea.value)
                    .then(() => {
                        copyBtn.textContent = 'Copied!';
                        textarea.select(); // Keep text selected
                        setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
                    })
                    .catch(err => {
                        console.error("Copy failed: ", err);
                        copyBtn.textContent = 'Copy Failed!';
                        setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
                        // Fallback for older browsers (less reliable)
                        try {
                            textarea.select();
                            document.execCommand('copy');
                            copyBtn.textContent = 'Copied! (Fallback)';
                            setTimeout(() => copyBtn.textContent = 'Copy to Clipboard', 2000);
                        } catch (execErr) {
                            console.error("Fallback copy failed: ", execErr);
                        }
                    });
            };

            modalContent.appendChild(header);
            modalContent.appendChild(textarea);
            modalContent.appendChild(copyBtn);
            modal.appendChild(modalContent);

            document.body.appendChild(modal);
            textarea.focus(); // Focus textarea for immediate interaction
            textarea.select(); // Select text automatically
        }


        // --- NEW Copy Complete JSON Function (Direct Copy) ---
                // --- NEW Copy Complete JSON Function (Direct Copy) ---
                function copyCompleteJson() {
            console.log("--- copyCompleteJson button clicked ---");
             // Log state *just before* calling generate
             console.log("State before calling generateCompleteMapData:", {
                selectedFilename: mapSelect.value,
                imageLayerExists: !!imageLayer,
                currentMapIdValue: currentMapId,
                currentBoundsValue: currentBounds ? JSON.stringify(currentBounds) : null
            });

            const mapData = generateCompleteMapData(); // This now has internal logging

            if (!mapData) {
                 // The alert is now more specific if generateCompleteMapData returned null
                alert("Copy failed: Map state is incomplete. Check console logs for details.");
                setStatus('Copy failed. Map state incomplete. See console.', 'error');
                return;
            }

            const jsonString = JSON.stringify(mapData, null, 2);

            navigator.clipboard.writeText(jsonString)
                .then(() => setStatus('Complete map JSON copied to clipboard!', 'success'))
                .catch(err => {
                    setStatus('Failed to copy complete JSON.', 'error');
                    console.error("Copy JSON error:", err);
                    // Optionally show the modal as a fallback if direct copy fails
                    // showJsonModal(jsonString, mapData.id + '.json');
                });
        }


        // --- Map Initialization ---
        function initMap() {
            if (map) return; // Already initialized

            map = L.map('map', {
                crs: L.CRS.Simple,
                minZoom: -5,
                maxZoom: 5,
                center: [0, 0],
                zoom: 0,
                doubleClickZoom: false
            });

            map.on('click', (e) => {
                if (isEditingPoint || (isEditingRegion && !isAddingVerticesToRegion && !isEditingVertices)) {
                    return;
                }

                if (currentMode === 'points' && !isEditingPoint) {
                    lastClickedCoordsArray = [Math.round(e.latlng.lat), Math.round(e.latlng.lng)];
                    coordsDisplay.textContent = `[${lastClickedCoordsArray[0]}, ${lastClickedCoordsArray[1]}]`;
                    pointNameInput.value = '';
                    poiTypeSelect.value = '';
                    pointDescriptionInput.value = '';
                    pointWikiLinkInput.value = '';
                    addPointBtn.disabled = false;
                    setStatus('Coordinates captured. Enter point details and click Add New Point.');
                    pointNameInput.focus();
                } else if (currentMode === 'regions' && (isCreatingRegion || isAddingVerticesToRegion)) {
                    handleMapClickForRegion(e);
                }
            });

            map.on('mousemove', (e) => {
                if (!isEditingPoint && !isEditingRegion && !isCreatingRegion && !isAddingVerticesToRegion && !isEditingVertices) { // Show only when idle
                    coordsDisplay.textContent = `[${Math.round(e.latlng.lat)}, ${Math.round(e.latlng.lng)}]`;
                }
            });
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            initMap();
            populateMapSelector();
            populateTypeDropdown();
            resetUIState();
            setMode('points');

            loadMapBtn.addEventListener('click', loadImage);
            exportMapDataBtn.addEventListener('click', exportMapData); // Changed target function

            // Mode switching
            modeTabs.forEach(tab => {
                tab.addEventListener('click', () => setMode(tab.dataset.mode));
            });

            // Point Controls
            addPointBtn.addEventListener('click', () => {
                if (!lastClickedCoordsArray) { alert("Click on the map first to set coordinates."); return; }
                const pointName = pointNameInput.value.trim();
                const pointType = poiTypeSelect.value;
                const pointDescription = pointDescriptionInput.value.trim();
                const pointWikiLink = pointWikiLinkInput.value.trim();

                if (!pointName) { alert("Point Name cannot be empty."); pointNameInput.focus(); return; }
                if (!pointType) { alert("Please select a Point Type."); poiTypeSelect.focus(); return; }

                const nameConflict = collectedPoints.some(p => p.name === pointName);
                if (nameConflict) {
                    alert(`A point named "${pointName}" already exists.`); pointNameInput.focus(); return;
                }

                collectedPoints.push({
                    coords: lastClickedCoordsArray,
                    name: pointName,
                    type: pointType,
                    description: pointDescription,
                    wikiLink: pointWikiLink
                });
                updatePointsOutput();
                setStatus(`Point "${pointName}" added successfully.`, 'success');
                pointNameInput.value = '';
                poiTypeSelect.value = '';
                pointDescriptionInput.value = '';
                pointWikiLinkInput.value = '';
                coordsDisplay.textContent = '[Y, X]';
                lastClickedCoordsArray = null;
                addPointBtn.disabled = true;
            });

            editPointSelect.addEventListener('change', (e) => {
                if (e.target.value) {
                    loadPointForEditing(e.target.value);
                } else {
                    cancelPointEditing();
                }
            });
            savePointChangesBtn.addEventListener('click', savePointChanges);
            cancelPointEditBtn.addEventListener('click', cancelPointEditing);
            clearPointsBtn.addEventListener('click', () => { // Moved button listener
                if (confirm('Are you sure you want to clear all points? This cannot be undone.')) {
                    collectedPoints = [];
                    updatePointsOutput();
                    setPointEditingState(false); // Ensure UI resets if editing was cancelled by clearing
                    setStatus('All points cleared.');
                }
            });

            // Region Controls
            startRegionBtn.addEventListener('click', startRegionCreation);
            finishRegionBtn.addEventListener('click', finishRegionCreation);
            cancelRegionBtn.addEventListener('click', cancelRegionCreation);

            editRegionSelect.addEventListener('change', (e) => {
                if (e.target.value) {
                    loadRegionForEditing(e.target.value);
                } else {
                    cancelRegionEditing();
                }
            });
            saveRegionChangesBtn.addEventListener('click', saveRegionChanges);
            cancelRegionEditBtn.addEventListener('click', cancelRegionEditing);
            addVerticesBtn.addEventListener('click', startAddingVertices);
            editVerticesBtn.addEventListener('click', startEditingVertices);
            clearRegionsBtn.addEventListener('click', () => { // Moved button listener
                if (confirm('Are you sure you want to clear all regions? This cannot be undone.')) {
                    collectedRegions = [];
                    updateRegionsOutput();
                    setRegionEditingState(false); // Ensure UI resets
                    setRegionCreationState(false); // Ensure UI resets
                    setStatus('All regions cleared.');
                }
            });

            // Update region preview colors dynamically
            regionColorInput.addEventListener('input', () => {
                const color = regionColorInput.value;
                if (tempRegionLayer && isCreatingRegion) tempRegionLayer.setStyle({ color: color });
                if (editingPolygonLayer && (isEditingRegion || isEditingVertices)) editingPolygonLayer.setStyle({ color: color });
            });
            regionFillColorInput.addEventListener('input', () => {
                const color = regionFillColorInput.value;
                if (tempRegionLayer && isCreatingRegion) tempRegionLayer.setStyle({ fillColor: color });
                if (editingPolygonLayer && (isEditingRegion || isEditingVertices)) editingPolygonLayer.setStyle({ fillColor: color });
            });
            regionOpacityInput.addEventListener('input', () => {
                const opacity = parseFloat(regionOpacityInput.value);
                if (!isNaN(opacity)) {
                    if (tempRegionLayer && isCreatingRegion) tempRegionLayer.setStyle({ fillOpacity: opacity });
                    if (editingPolygonLayer && (isEditingRegion || isEditingVertices)) editingPolygonLayer.setStyle({ fillOpacity: opacity });
                }
            });
            regionTypeSelect.addEventListener('change', (e) => {
                const type = e.target.value;
                if (regionTypeColors[type] && !isEditingRegion && !isCreatingRegion) {
                    regionColorInput.value = regionTypeColors[type].color;
                    regionFillColorInput.value = regionTypeColors[type].fillColor;
                }
            });

            // NEW Summary Area Button Listeners
            viewJsonBtn.addEventListener('click', exportMapData); // Reuses the export function to show modal
            copyJsonBtn.addEventListener('click', copyCompleteJson); // Uses the direct copy function

            // Removed Import Controls Listener
        });

    </script>

</body>
</html>