<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Map Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script src="https://unpkg.com/leaflet-geometryutil"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Modern Style --- */
        body {
            font-family: 'Inter', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Custom scrollbar for a cleaner look in dark mode */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; } /* slate-800 */
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; } /* slate-600 */
        ::-webkit-scrollbar-thumb:hover { background: #64748b; } /* slate-500 */

        /* Leaflet map cursors for different interaction modes */
        #map.region-creation-mode, #map.vertex-adding-mode, #map.vertex-editing-mode,
        #map.line-creation-mode, #map.line-vertex-editing-mode { cursor: crosshair !important; }

        /* Styles for vertex markers on the map, making them distinct and interactive */
        .vertex-marker, .line-vertex-marker {
            background-color: rgba(239, 68, 68, 0.9); /* Red-500 */
            border: 2px solid #fff;
            border-radius: 9999px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
            cursor: grab;
            transition: transform 0.1s ease-in-out;
        }
        .vertex-marker:active, .line-vertex-marker:active { cursor: grabbing; transform: scale(1.2); }
        
        .new-vertex-marker, .new-line-vertex-marker {
            background-color: rgba(34, 197, 94, 0.9); /* Green-500 */
            border: 2px solid #fff;
            border-radius: 9999px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        
        /* Style for the active/selected vertex marker */
        .vertex-marker.active, .line-vertex-marker.active {
            background-color: #3b82f6; /* Blue-500 */
            border: 2px solid #ffffff;
            transform: scale(1.3);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.5);
        }

        /* Sidebar transition for smooth collapsing */
        #sidebar {
            transition: margin-left 0.3s ease-in-out, transform 0.3s ease-in-out;
        }

        /* Leaflet popup dark theme */
        .leaflet-popup-content-wrapper { background: #334155; color: #e2e8f0; border: 1px solid #475569; border-radius: 8px; }
        .leaflet-popup-content { font-family: 'Inter', sans-serif; }
        .leaflet-popup-tip { background: #334155; }

        /* -- UX IMPROVEMENT: Animation for status bar feedback -- */
        @keyframes flash-success { 0%, 100% { background-color: transparent; } 50% { background-color: rgba(34, 197, 94, 0.2); } }
        @keyframes flash-error { 0%, 100% { background-color: transparent; } 50% { background-color: rgba(239, 68, 68, 0.2); } }
        .status-flash-success { animation: flash-success 0.8s ease-in-out; }
        .status-flash-error { animation: flash-error 0.8s ease-in-out; }
    </style>
</head>
<body class="bg-slate-900 text-slate-300 overflow-hidden">
    
    <div class="flex h-screen w-screen">
        <aside id="sidebar" class="absolute lg:relative z-20 w-full max-w-sm lg:max-w-xs xl:max-w-sm h-full bg-slate-800 border-r border-slate-700 shadow-lg lg:shadow-none flex flex-col transform lg:transform-none -translate-x-full lg:translate-x-0">
            <header class="p-4 border-b border-slate-700 flex items-center justify-between flex-shrink-0">
                <h1 class="text-xl font-bold text-slate-200">Map Editor</h1>
                <button id="sidebar-close-btn" class="lg:hidden text-slate-400 hover:text-slate-100">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </header>

            <div class="flex-grow overflow-y-auto p-4 space-y-6">
                
                <details id="map-settings-panel" class="space-y-4" open>
                    <summary class="font-semibold text-slate-400 cursor-pointer hover:text-slate-100">1. Map Settings</summary>
                    <div class="pl-4 space-y-3 text-sm">
                        <div class="control-row">
                            <label for="mapFileSelect" class="font-medium text-slate-300">Map File:</label>
                            <select id="mapFileSelect" class="mt-1 w-full"></select>
                        </div>
                         <div class="control-row">
                            <label for="subMapSelect" class="font-medium text-slate-300">Sub-Map:</label>
                            <select id="subMapSelect" class="mt-1 w-full" disabled></select>
                        </div>
                        <button id="loadSubMapBtn" class="w-full" disabled>Load Selected Map</button>
                    </div>
                </details>
                
                <div id="editor-controls" class="hidden space-y-6">
                    <div>
                        <h2 class="font-semibold text-slate-400 mb-2">2. Editing Mode</h2>
                        <div class="flex bg-slate-900 rounded-lg p-1">
                            <button data-mode="points" class="mode-tab flex-1 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors">Points</button>
                            <button data-mode="regions" class="mode-tab flex-1 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors">Regions</button>
                            <button data-mode="lines" class="mode-tab flex-1 px-3 py-1.5 text-sm font-semibold rounded-md transition-colors">Lines</button>
                        </div>
                    </div>

                    <div class="point-controls space-y-4">
                         <details class="space-y-4" open>
                            <summary class="font-semibold text-slate-400 cursor-pointer hover:text-slate-100">Point Editor</summary>
                             <div class="pl-4 space-y-3 text-sm">
                                <div class="control-row">
                                    <label class="font-medium text-slate-300">Edit Existing Point:</label>
                                    <select id="editPointSelect" class="mt-1 w-full"></select>
                                </div>
                                <hr class="border-slate-700">
                                
                                <div id="point-creation-panel">
                                    <p class="text-sm text-slate-400 mb-2">Click on the map to place a new point, then fill out the details below.</p>
                                </div>
                                
                                <div class="control-row">
                                    <label for="pointName" class="font-medium text-slate-300">Point Name:</label>
                                    <input type="text" id="pointName" placeholder="Click map or select point" class="mt-1 w-full">
                                </div>
                                 <div class="control-row">
                                    <label for="poiTypeSelect" class="font-medium text-slate-300">Type:</label>
                                    <select id="poiTypeSelect" class="mt-1 w-full"></select>
                                </div>
                                <div class="control-row">
                                    <label for="pointDescription" class="font-medium text-slate-300">Description:</label>
                                    <textarea id="pointDescription" class="mt-1 w-full h-24"></textarea>
                                </div>
                                <div class="control-row">
                                    <label for="pointWikiLink" class="font-medium text-slate-300">Wiki Link:</label>
                                    <input type="text" id="pointWikiLink" placeholder="Optional URL" class="mt-1 w-full">
                                </div>
                                <div class="flex items-center gap-2 mt-2">
                                    <button id="addPointBtn" class="flex-grow" disabled>Add New Point</button>
                                    <button id="savePointChangesBtn" class="flex-grow hidden">Save Changes</button>
                                    <button id="cancelPointEditBtn" class="flex-grow hidden" data-variant="secondary">Cancel</button>
                                </div>
                             </div>
                        </details>
                    </div>
                    
                    <div class="region-controls hidden space-y-4">
                         <details class="space-y-4" open>
                            <summary class="font-semibold text-slate-400 cursor-pointer hover:text-slate-100">Region Editor</summary>
                            <div class="pl-4 space-y-3 text-sm">
                                <div class="control-row">
                                    <label class="font-medium text-slate-300">Edit Existing Region:</label>
                                    <select id="editRegionSelect" class="mt-1 w-full"></select>
                                </div>
                                <hr class="border-slate-700">

                                <div id="region-form-details">
                                     <div class="control-row">
                                        <label for="regionName" class="font-medium text-slate-300">Region Name:</label>
                                        <input type="text" id="regionName" placeholder="Enter region name" class="mt-1 w-full">
                                    </div>
                                    <div class="control-row mt-3">
                                        <label for="regionTypeSelect" class="font-medium text-slate-300">Type:</label>
                                        <select id="regionTypeSelect" class="mt-1 w-full">
                                            <option value="">--Select Type--</option> <option value="political">Political</option> <option value="terrain">Terrain</option> <option value="climate">Climate</option> <option value="cultural">Cultural</option> <option value="other">Other</option>
                                        </select>
                                    </div>
                                    <div class="grid grid-cols-2 gap-3 mt-3">
                                        <div class="control-row"> <label for="regionColor" class="font-medium text-slate-300">Border</label> <input type="color" id="regionColor" value="#3388ff" class="mt-1 w-full h-9"> </div>
                                        <div class="control-row"> <label for="regionFillColor" class="font-medium text-slate-300">Fill</label> <input type="color" id="regionFillColor" value="#3388ff" class="mt-1 w-full h-9"> </div>
                                    </div>
                                     <div class="control-row mt-3">
                                        <label for="regionOpacity" class="font-medium text-slate-300">Fill Opacity: <span id="regionOpacityValue">0.2</span></label>
                                        <input type="range" id="regionOpacity" min="0.0" max="1.0" step="0.05" value="0.2" class="mt-1 w-full">
                                    </div>
                                    <div class="control-row mt-3"> <label for="regionDescription" class="font-medium text-slate-300">Description:</label> <textarea id="regionDescription" class="mt-1 w-full h-24"></textarea> </div>
                                    <div class="control-row mt-3"> <label for="regionWikiLink" class="font-medium text-slate-300">Wiki Link:</label> <input type="text" id="regionWikiLink" placeholder="Optional URL" class="mt-1 w-full"> </div>
                                </div>
                                
                                <div id="regionCreationControls" class="flex flex-col gap-2 mt-4">
                                    <button id="startRegionBtn" disabled>Start Drawing New Region</button>
                                    <button id="finishRegionBtn" class="hidden">Finish Region</button>
                                    <button id="cancelRegionBtn" class="hidden" data-variant="secondary">Cancel Drawing</button>
                                </div>
                                
                                <div id="regionEditingControls" class="hidden flex-col gap-2 mt-4">
                                    <button id="saveRegionChangesBtn">Save Changes</button>
                                    <div class="grid grid-cols-2 gap-2">
                                        <button id="addVerticesBtn" data-variant="secondary">Add Points</button>
                                        <button id="editVerticesBtn" data-variant="secondary">Adjust Shape</button>
                                    </div>
                                    <div class="control-row items-center justify-start py-2">
                                        <input type="checkbox" id="showAllRegionsToggle" class="h-4 w-4 rounded border-slate-600 text-indigo-500 focus:ring-indigo-500 bg-slate-700">
                                        <label for="showAllRegionsToggle" class="ml-2 block text-sm text-slate-300">Show other regions while editing</label>
                                    </div>
                                    <button id="cancelRegionEditBtn" data-variant="secondary">Cancel Edit</button>
                                </div>

                            </div>
                        </details>
                    </div>
                    
                    <div class="line-controls hidden space-y-4">
                        <details class="space-y-4" open>
                            <summary class="font-semibold text-slate-400 cursor-pointer hover:text-slate-100">Line Editor</summary>
                             <div class="pl-4 space-y-3 text-sm">
                                 <div class="control-row">
                                    <label class="font-medium text-slate-300">Edit Existing Line:</label>
                                    <select id="editLineSelect" class="mt-1 w-full"></select>
                                </div>
                                <hr class="border-slate-700">
                                
                                <div id="line-form-details">
                                    <div class="control-row">
                                        <label for="lineName" class="font-medium text-slate-300">Line Name (Optional):</label>
                                        <input type="text" id="lineName" placeholder="e.g., King's Road" class="mt-1 w-full">
                                    </div>
                                    <div class="control-row mt-3">
                                        <label for="lineTypeSelect" class="font-medium text-slate-300">Type:</label>
                                        <select id="lineTypeSelect" class="mt-1 w-full">
                                            <option value="">--Select Type--</option> <option value="highway">Highway</option> <option value="main_road">Main Road</option> <option value="street">Street</option> <option value="path">Path</option> <option value="track">Track</option> <option value="river">River</option> <option value="stream">Stream</option> <option value="cliff">Cliff Edge</option> <option value="border">Border</option> <option value="other">Other</option>
                                        </select>
                                    </div>
                                    <div class="grid grid-cols-2 gap-3 mt-3">
                                        <div class="control-row"> <label for="lineColor" class="font-medium text-slate-300">Color</label> <input type="color" id="lineColor" value="#808080" class="mt-1 w-full h-9"> </div>
                                        <div class="control-row"> <label for="lineWeight" class="font-medium text-slate-300">Weight</label> <input type="number" id="lineWeight" min="1" max="20" step="1" value="3" class="mt-1 w-full"> </div>
                                    </div>
                                    <div class="control-row mt-3">
                                        <label for="lineDashArray" class="font-medium text-slate-300 flex items-center">
                                            Dash Array
                                            <span class="ml-1 text-slate-400 cursor-help" title="e.g., '5, 10' for 5px dash, 10px space. Leave blank for a solid line.">(?)</span>
                                        </label>
                                        <input type="text" id="lineDashArray" placeholder="e.g., 5, 5" class="mt-1 w-full">
                                    </div>
                                    <div class="control-row mt-3"> <label for="lineDescription" class="font-medium text-slate-300">Description:</label> <textarea id="lineDescription" class="mt-1 w-full h-24"></textarea> </div>
                                    <div class="control-row mt-3"> <label for="lineWikiLink" class="font-medium text-slate-300">Wiki Link:</label> <input type="text" id="lineWikiLink" placeholder="Optional URL" class="mt-1 w-full"> </div>
                                </div>

                                <div id="lineCreationControls" class="flex flex-col gap-2 mt-4">
                                    <button id="startLineBtn" disabled>Start Drawing New Line</button>
                                    <button id="finishLineBtn" class="hidden">Finish Line</button>
                                    <button id="cancelLineBtn" class="hidden" data-variant="secondary">Cancel Drawing</button>
                                </div>

                                 <div id="lineEditingControls" class="hidden flex-col gap-2 mt-4">
                                    <button id="saveLineChangesBtn">Save Changes</button>
                                    <button id="editLineVerticesBtn" data-variant="secondary">Adjust Shape</button>
                                    <button id="cancelLineEditBtn" data-variant="secondary">Cancel Edit</button>
                                </div>
                            </div>
                        </details>
                    </div>
                </div>
            </div>

            <footer class="p-4 border-t border-slate-700 flex-shrink-0 space-y-4 text-sm">
                <details id="map-details-panel" class="hidden space-y-4">
                    <summary class="font-semibold text-slate-400 cursor-pointer hover:text-slate-100">Map Details</summary>
                     <div class="pl-4 space-y-3 text-sm">
                        <div class="control-row">
                            <label for="mapBlurb" class="font-medium text-slate-300">Map Blurb (HTML allowed):</label>
                            <textarea id="mapBlurb" placeholder="Brief description..." class="mt-1 w-full h-20"></textarea>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <label for="scalePixels" class="font-medium text-slate-300">Scale Pixels</label>
                                <input type="number" id="scalePixels" value="3" min="1" class="mt-1 w-full">
                            </div>
                            <div>
                                <label for="scaleKilometers" class="font-medium text-slate-300">Scale Units</label>
                                <input type="number" id="scaleKilometers" value="1" min="0.1" step="0.1" class="mt-1 w-full">
                            </div>
                        </div>
                    </div>
                </details>

                <div class="map-summary p-3 bg-slate-700/50 rounded-lg">
                    <h3 class="font-semibold text-slate-300 mb-2">Map Summary</h3>
                    <div class="summary-stats grid grid-cols-3 gap-2 text-center">
                        <div>
                            <p class="font-bold text-lg text-slate-100" id="points-count">0</p>
                            <p class="text-xs text-slate-400">Points</p>
                        </div>
                        <div>
                            <p class="font-bold text-lg text-slate-100" id="regions-count">0</p>
                            <p class="text-xs text-slate-400">Regions</p>
                        </div>
                        <div>
                            <p class="font-bold text-lg text-slate-100" id="lines-count">0</p>
                            <p class="text-xs text-slate-400">Lines</p>
                        </div>
                    </div>
                </div>
                <button id="exportDataBtn" data-variant="secondary" disabled>Export Map Data</button>
                <div class="flex items-center gap-2">
                    <button id="clearPointsBtn" class="flex-1 text-xs" data-variant="danger" disabled>Clear Points</button>
                    <button id="clearRegionsBtn" class="flex-1 text-xs hidden" data-variant="danger" disabled>Clear Regions</button>
                    <button id="clearLinesBtn" class="flex-1 text-xs hidden" data-variant="danger" disabled>Clear Lines</button>
                </div>
            </footer>
        </aside>

        <main id="main-content" class="flex-1 flex flex-col relative transition-all duration-300 ease-in-out lg:ml-0">
            <button id="sidebar-open-btn" class="absolute top-4 left-4 z-10 p-2 bg-slate-800 rounded-md shadow-md text-slate-300 hover:bg-slate-700 hover:text-slate-100 transition-all">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
            </button>

            <div id="map" class="flex-grow w-full h-full bg-slate-700"></div>
            
            <div id="info-bar" class="absolute bottom-0 left-0 right-0 z-10 bg-slate-900/80 backdrop-blur-sm p-2 shadow-t flex items-center justify-between text-sm pointer-events-none">
                <span id="status-text" class="text-slate-200 font-medium px-2">Select a map file to begin.</span>
                <div class="flex items-center space-x-4">
                    <div id="coords-display" class="font-mono bg-slate-700 text-white rounded px-2 py-1 text-xs tracking-wider">[Y, X]</div>
                    <div id="region-vertices-count" class="hidden text-slate-300 font-medium">0 vertices</div>
                    <div id="line-vertices-count" class="hidden text-slate-300 font-medium">0 vertices</div>
                </div>
            </div>
        </main>
    </div>

    <div id="json-modal" class="hidden fixed inset-0 bg-black/60 flex items-center justify-center p-4 z-50">
        <div class="bg-slate-800 rounded-lg shadow-xl w-full max-w-2xl max-h-[90vh] flex flex-col border border-slate-700">
            <header class="p-4 border-b border-slate-700 flex justify-between items-center">
                <h3 class="font-semibold text-lg text-slate-200" id="json-modal-title">Complete Map Data</h3>
                <button class="json-modal-close text-slate-400 hover:text-slate-100">&times;</button>
            </header>
            <textarea id="json-modal-textarea" readonly class="flex-grow p-4 font-mono text-xs bg-slate-900 text-slate-300 resize-none"></textarea>
            <footer class="p-4 bg-slate-900/50 border-t border-slate-700 flex justify-end">
                <button id="json-modal-copy">Copy to Clipboard</button>
            </footer>
        </div>
    </div>


    <script>
        // --- DOM Element References ---
        const mapElement = document.getElementById('map');
        const mapFileSelect = document.getElementById('mapFileSelect');
        const subMapSelect = document.getElementById('subMapSelect');
        const loadSubMapBtn = document.getElementById('loadSubMapBtn');
        const infoBar = document.getElementById('info-bar');
        const statusDisplay = document.getElementById('status-text');
        const modeTabs = document.querySelectorAll('.mode-tab');
        const sidebar = document.getElementById('sidebar');
        const sidebarOpenBtn = document.getElementById('sidebar-open-btn');
        const sidebarCloseBtn = document.getElementById('sidebar-close-btn');
        const mainContent = document.getElementById('main-content');
        const scalePixelsInput = document.getElementById('scalePixels');
        const scaleKilometersInput = document.getElementById('scaleKilometers');
        const mapBlurbInput = document.getElementById('mapBlurb');
        const pointNameInput = document.getElementById('pointName');
        const poiTypeSelect = document.getElementById('poiTypeSelect');
        const pointDescriptionInput = document.getElementById('pointDescription');
        const pointWikiLinkInput = document.getElementById('pointWikiLink');
        const addPointBtn = document.getElementById('addPointBtn');
        const savePointChangesBtn = document.getElementById('savePointChangesBtn');
        const cancelPointEditBtn = document.getElementById('cancelPointEditBtn');
        const coordsDisplay = document.getElementById('coords-display');
        const editPointSelect = document.getElementById('editPointSelect');
        const clearPointsBtn = document.getElementById('clearPointsBtn');
        const regionNameInput = document.getElementById('regionName');
        const regionTypeSelect = document.getElementById('regionTypeSelect');
        const regionColorInput = document.getElementById('regionColor');
        const regionFillColorInput = document.getElementById('regionFillColor');
        const regionOpacityInput = document.getElementById('regionOpacity');
        const regionOpacityValue = document.getElementById('regionOpacityValue');
        const regionDescriptionInput = document.getElementById('regionDescription');
        const regionWikiLinkInput = document.getElementById('regionWikiLink');
        const startRegionBtn = document.getElementById('startRegionBtn');
        const finishRegionBtn = document.getElementById('finishRegionBtn');
        const cancelRegionBtn = document.getElementById('cancelRegionBtn');
        const saveRegionChangesBtn = document.getElementById('saveRegionChangesBtn');
        const addVerticesBtn = document.getElementById('addVerticesBtn');
        const editVerticesBtn = document.getElementById('editVerticesBtn');
        const cancelRegionEditBtn = document.getElementById('cancelRegionEditBtn');
        const editRegionSelect = document.getElementById('editRegionSelect');
        const regionVerticesCount = document.getElementById('region-vertices-count');
        const clearRegionsBtn = document.getElementById('clearRegionsBtn');
        const showAllRegionsToggle = document.getElementById('showAllRegionsToggle');
        const regionCreationControls = document.getElementById('regionCreationControls');
        const regionEditingControls = document.getElementById('regionEditingControls');
        const lineNameInput = document.getElementById('lineName');
        const lineTypeSelect = document.getElementById('lineTypeSelect');
        const lineColorInput = document.getElementById('lineColor');
        const lineWeightInput = document.getElementById('lineWeight');
        const lineDashArrayInput = document.getElementById('lineDashArray');
        const lineDescriptionInput = document.getElementById('lineDescription');
        const lineWikiLinkInput = document.getElementById('lineWikiLink');
        const startLineBtn = document.getElementById('startLineBtn');
        const finishLineBtn = document.getElementById('finishLineBtn');
        const cancelLineBtn = document.getElementById('cancelLineBtn');
        const clearLinesBtn = document.getElementById('clearLinesBtn');
        const saveLineChangesBtn = document.getElementById('saveLineChangesBtn');
        const editLineVerticesBtn = document.getElementById('editLineVerticesBtn');
        const cancelLineEditBtn = document.getElementById('cancelLineEditBtn');
        const editLineSelect = document.getElementById('editLineSelect');
        const lineVerticesCountDisplay = document.getElementById('line-vertices-count');
        const lineCreationControls = document.getElementById('lineCreationControls');
        const lineEditingControls = document.getElementById('lineEditingControls');
        const pointControls = document.querySelector('.point-controls');
        const regionControls = document.querySelector('.region-controls');
        const lineControls = document.querySelector('.line-controls');
        const pointsCountDisplay = document.getElementById('points-count');
        const regionsCountDisplay = document.getElementById('regions-count');
        const linesCountDisplay = document.getElementById('lines-count');
        const exportDataBtn = document.getElementById('exportDataBtn');
        const jsonModal = document.getElementById('json-modal');
        const jsonModalTitle = document.getElementById('json-modal-title');
        const jsonModalTextarea = document.getElementById('json-modal-textarea');
        const jsonModalCopyBtn = document.getElementById('json-modal-copy');
        const jsonModalCloseBtns = document.querySelectorAll('.json-modal-close');
        // UX FIX References
        const editorControls = document.getElementById('editor-controls');
        const mapDetailsPanel = document.getElementById('map-details-panel');

        // --- State Variables ---
        let map = null, imageLayer = null, masterMapData = [], currentMapObject = null, currentBounds = null;
        let lastClickedCoordsArray = null, collectedPoints = [], collectedRegions = [], collectedLines = [];
        let isEditingPoint = false, editingPointMarker = null, isEditingRegion = false, isEditingLine = false;
        let currentlyEditingPointIndex = -1, currentlyEditingRegionIndex = -1, currentlyEditingLineIndex = -1;
        let currentMode = 'points', isCreatingRegion = false, tempRegionVertices = [], tempRegionLayer = null;
        let isAddingVerticesToRegion = false, isEditingVertices = false;
        let addingVerticesData = { index: -1, newPoints: [] };
        let editingVisualsLayerGroup = null, editingPolygonLayer = null;
        let isCreatingLine = false, tempLineVertices = [], tempLineLayer = null, isEditingLineVertices = false;
        let editingLineVisualsLayerGroup = null, editingLinePolylineLayer = null, activeVertexMarker = null;
        let showAllRegionsWhileEditing = false, otherRegionsLayerGroup = null;

        // --- Hardcoded Data ---
        const HARDCODED_MAP_FILES = { "All Maps (Manifest)": "maps/maps.json", "Icebeach": "maps/icebeach.json", "Castgate": "maps/castgate.json", "Cursed Old-Lin": "maps/Cursed-Old-Lin.json", "Arfordir": "maps/Arfordir.json", "Gelwood": "maps/gelwood.json", "Southern Thalassia": "maps/southern-thalassia.json" };
        const poiTypeGroups = { "Settlements": ["City", "Town", "Village", "Hamlet", "Settlement", "Capital"], "Structures": ["Castle", "Fortress", "Fort", "Tower", "Ruin", "Temple", "Shrine", "Mine", "Lighthouse", "Bridge", "Dungeon", "Lair", "Camp", "Asylum", "Landmark"], "Natural Features": ["Mountain", "Peak", "Forest", "Wood", "River", "Lake", "Cave", "Cavern", "Coast", "Bay", "Cove", "Swamp", "Marsh", "Desert", "Natural Landmark"], "Other": ["Point of Interest", "Region", "Portal"], "Unknown": ["Unknown"] };
        const regionTypeColors = { "political": { color: "#3b82f6", fillColor: "#3b82f6" }, "terrain": { color: "#22c55e", fillColor: "#22c55e" }, "climate": { color: "#a855f7", fillColor: "#a855f7" }, "cultural": { color: "#eab308", fillColor: "#eab308" }, "other": { color: "#ef4444", fillColor: "#ef4444" } };

        // --- Helper: Apply Modern Styles ---
        function applyModernStyles() {
            document.querySelectorAll('button').forEach(btn => {
                const variant = btn.dataset.variant;
                let baseClasses = 'px-4 py-2 text-sm font-semibold rounded-md shadow-sm transition-all duration-150 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-slate-800';
                let variantClasses = '';
                if (variant === 'secondary') { variantClasses = 'bg-slate-700 text-slate-300 border border-slate-600 hover:bg-slate-600 focus:ring-indigo-500'; } 
                else if (variant === 'danger') { variantClasses = 'bg-red-500/10 text-red-400 hover:bg-red-500/20 border border-red-500/20 focus:ring-red-500'; } 
                else { variantClasses = 'bg-indigo-500 text-white hover:bg-indigo-600 focus:ring-indigo-500'; }
                btn.className = `${baseClasses} ${variantClasses} disabled:bg-slate-700 disabled:text-slate-500 disabled:cursor-not-allowed disabled:shadow-none`;
            });
            document.querySelectorAll('input[type="text"], input[type="number"], select, textarea').forEach(el => {
                let base = 'block w-full rounded-md border-0 py-1.5 shadow-sm ring-1 ring-inset sm:text-sm sm:leading-6 bg-slate-700 text-slate-200 ring-slate-600 placeholder:text-slate-400 focus:ring-2 focus:ring-inset focus:ring-indigo-500 disabled:cursor-not-allowed disabled:bg-slate-800 disabled:text-slate-400 disabled:ring-slate-700';
                el.className = base;
            });
            document.querySelectorAll('input[type="color"]').forEach(el => {
                el.className = 'block w-full rounded-md border-0 p-1 h-9 bg-slate-700 ring-1 ring-inset ring-slate-600 cursor-pointer focus:ring-2 focus:ring-inset focus:ring-indigo-500';
            })
        }

        // --- UI & Mode Management ---

        // UX FIX: New function to show/hide the main editor controls
        function showEditorControls(show) {
            editorControls.classList.toggle('hidden', !show);
            mapDetailsPanel.classList.toggle('hidden', !show);
        }

        function setMode(mode) {
            currentMode = mode;
            modeTabs.forEach(tab => {
                const isActive = tab.dataset.mode === mode;
                tab.classList.toggle('bg-slate-700', isActive); tab.classList.toggle('text-slate-100', isActive);
                tab.classList.toggle('shadow-sm', isActive); tab.classList.toggle('bg-transparent', !isActive);
                tab.classList.toggle('text-slate-400', !isActive); tab.classList.toggle('hover:bg-slate-800', !isActive);
            });
            pointControls.classList.toggle('hidden', mode !== 'points');
            regionControls.classList.toggle('hidden', mode !== 'regions');
            lineControls.classList.toggle('hidden', mode !== 'lines');
            clearPointsBtn.classList.toggle('hidden', mode !== 'points');
            clearRegionsBtn.classList.toggle('hidden', mode !== 'regions');
            clearLinesBtn.classList.toggle('hidden', mode !== 'lines');
            regionVerticesCount.classList.toggle('hidden', mode !== 'regions');
            lineVerticesCountDisplay.classList.toggle('hidden', mode !== 'lines');
            if (mode !== 'points' && isEditingPoint) cancelPointEditing();
            if (mode !== 'regions' && (isCreatingRegion || isEditingRegion)) { cancelRegionCreation(); cancelRegionEditing(); }
            if (mode !== 'lines' && (isCreatingLine || isEditingLine)) { cancelLineCreation(); cancelLineEdit(); }
            updateStatusMessage();
        }

        function updateStatusMessage(message, type = 'info') {
            if (message) {
                statusDisplay.textContent = message;
                statusDisplay.className = 'font-medium px-2 transition-colors ';
                if (type === 'error') statusDisplay.classList.add('text-red-400');
                else if (type === 'success') statusDisplay.classList.add('text-green-400');
                else statusDisplay.classList.add('text-slate-200');
            }
        }
        
        // UX FIX: New function to flash the status bar for feedback
        let flashTimeout;
        function flashStatusMessage(message, type = 'info') {
            updateStatusMessage(message, type);
            clearTimeout(flashTimeout);
            infoBar.classList.remove('status-flash-success', 'status-flash-error');
            // This little trick forces a reflow to restart the animation
            void infoBar.offsetWidth; 
            if (type === 'success') infoBar.classList.add('status-flash-success');
            if (type === 'error') infoBar.classList.add('status-flash-error');
            flashTimeout = setTimeout(() => {
                 infoBar.classList.remove('status-flash-success', 'status-flash-error');
            }, 800);
        }

        function updateStatus() {
            if (!currentMapObject) { updateStatusMessage('Select and load a map to begin editing.'); return; }
            if (currentMode === 'points') { updateStatusMessage(isEditingPoint ? 'Editing point: Drag marker or click map to move. Save or Cancel.' : 'Click map for a new point or select one to edit.'); } 
            else if (currentMode === 'regions') {
                if (isCreatingRegion) updateStatusMessage('Click on the map to add points. Click Finish when done.');
                else if (isAddingVerticesToRegion) updateStatusMessage(`Adding points to region. Click map to add, or click Stop.`);
                else if (isEditingVertices) { if (activeVertexMarker) updateStatusMessage(`Point selected. Drag to move, or press Delete/Backspace to remove.`); else updateStatusMessage(`Adjusting shape. Drag points, or click a point to select it for deletion.`); } 
                else if (isEditingRegion) updateStatusMessage('Editing region. Modify details, Save, Adjust Shape, or Cancel.');
                else updateStatusMessage('Fill in details and click Start Drawing, or select a region to edit.');
            } else if (currentMode === 'lines') {
                if (isCreatingLine) updateStatusMessage('Click on the map to add line points. Click Finish Line when done.');
                else if (isEditingLineVertices) { if (activeVertexMarker) updateStatusMessage(`Point selected. Drag to move, or press Delete/Backspace to remove.`); else updateStatusMessage(`Adjusting shape. Drag points, or click a point for deletion.`); } 
                else if (isEditingLine) updateStatusMessage('Editing line. Modify details, Save Changes, Adjust Shape, or Cancel.');
                else updateStatusMessage('Fill in details and click Start Drawing, or select a line to edit.');
            }
        }
        
        // --- Full Original Logic (Ported to new UI) ---
        // NOTE: The core logic remains largely the same, but UI state management is updated for the new UX.
        // A few key functions are modified below to show the pattern.
        function findMapByIdRecursive(items, id) { for (const item of items) { if (item.id === id) return item; if (item.children && Array.isArray(item.children)) { const found = findMapByIdRecursive(item.children, id); if (found) return found; } } return null; }
        
        function toggleOtherRegionsVisibility(show, exceptIndex = -1) {
            if (otherRegionsLayerGroup) { map.removeLayer(otherRegionsLayerGroup); otherRegionsLayerGroup = null; }
            if (show) {
                otherRegionsLayerGroup = L.layerGroup();
                collectedRegions.forEach((region, index) => {
                    if (index === exceptIndex) return;
                    // UX TWEAK: Increased visibility for "other" regions while editing.
                    L.polygon(region.coordinates, {
                        color: region.color || '#3388ff',
                        fillColor: region.fillColor || '#3388ff',
                        fillOpacity: 0.1, // Changed from 0.05
                        weight: 2,        // Changed from 1
                        dashArray: '3, 5',
                        interactive: false
                    }).addTo(otherRegionsLayerGroup);
                });
                otherRegionsLayerGroup.addTo(map);
            }
        }

        function populateSubMapSelector(mapData) { subMapSelect.innerHTML = '<option value="">-- Choose a map --</option>'; const foundMaps = []; function findMapsRecursive(items) { if (!items || !Array.isArray(items)) return; items.forEach(item => { if (item && typeof item === 'object') { if (item.imageUrl) { foundMaps.push({ id: item.id, name: item.name }); } if (item.children && Array.isArray(item.children)) { findMapsRecursive(item.children); } } }); } findMapsRecursive(mapData); foundMaps.sort((a, b) => a.name.localeCompare(b.name)).forEach(mapInfo => { const option = document.createElement('option'); option.value = mapInfo.id; option.textContent = mapInfo.name; subMapSelect.appendChild(option); }); subMapSelect.disabled = false; loadSubMapBtn.disabled = false; }
        function populateTypeDropdown() { poiTypeSelect.innerHTML = '<option value="">--Select Type--</option>'; for (const groupName in poiTypeGroups) { const optgroup = document.createElement('optgroup'); optgroup.label = groupName; poiTypeGroups[groupName].forEach(type => { const option = document.createElement('option'); option.value = type; option.textContent = type; optgroup.appendChild(option); }); poiTypeSelect.appendChild(optgroup); } }
        function populatePointEditDropdown() { const previouslySelectedName = (currentlyEditingPointIndex >= 0 && currentlyEditingPointIndex < collectedPoints.length) ? collectedPoints[currentlyEditingPointIndex].name : null; editPointSelect.innerHTML = '<option value="">--Select Point to Edit--</option>'; const sortedPoints = [...collectedPoints].sort((a, b) => a.name.localeCompare(b.name)); sortedPoints.forEach(point => { const option = document.createElement('option'); option.value = point.name; option.textContent = point.name; editPointSelect.appendChild(option); }); editPointSelect.value = previouslySelectedName || ""; editPointSelect.disabled = collectedPoints.length === 0; }
        function populateRegionEditDropdown() { const previouslySelectedName = (currentlyEditingRegionIndex >= 0 && currentlyEditingRegionIndex < collectedRegions.length) ? collectedRegions[currentlyEditingRegionIndex].name : null; editRegionSelect.innerHTML = '<option value="">--Select Region to Edit--</option>'; const sortedRegions = [...collectedRegions].sort((a, b) => a.name.localeCompare(b.name)); sortedRegions.forEach(region => { const option = document.createElement('option'); option.value = region.name; option.textContent = region.name; editRegionSelect.appendChild(option); }); editRegionSelect.value = previouslySelectedName || ""; editRegionSelect.disabled = collectedRegions.length === 0; }
        function populateLineEditDropdown() { const previouslySelectedValue = (currentlyEditingLineIndex >= 0 && currentlyEditingLineIndex < collectedLines.length) ? (collectedLines[currentlyEditingLineIndex].name || collectedLines[currentlyEditingLineIndex].id) : null; editLineSelect.innerHTML = '<option value="">--Select Line to Edit--</option>'; const sortedLines = [...collectedLines].sort((a, b) => (a.name || "Unnamed Line").localeCompare(b.name || "Unnamed Line")); sortedLines.forEach(line => { const option = document.createElement('option'); option.value = line.name || line.id; option.textContent = line.name || `Line ID: ${line.id.substring(0,10)}...`; editLineSelect.appendChild(option); }); editLineSelect.value = previouslySelectedValue || ""; editLineSelect.disabled = collectedLines.length === 0; }
        function updatePointsOutput() { pointsCountDisplay.textContent = collectedPoints.length; clearPointsBtn.disabled = collectedPoints.length === 0 || !currentMapObject; populatePointEditDropdown(); const mapLoaded = !!imageLayer; exportDataBtn.disabled = !mapLoaded; }
        function updateRegionsOutput() { regionsCountDisplay.textContent = collectedRegions.length; clearRegionsBtn.disabled = collectedRegions.length === 0 || !currentMapObject; populateRegionEditDropdown(); const mapLoaded = !!imageLayer; exportDataBtn.disabled = !mapLoaded; }
        function updateLinesOutput() { linesCountDisplay.textContent = collectedLines.length; clearLinesBtn.disabled = collectedLines.length === 0 || !currentMapObject; populateLineEditDropdown(); const mapLoaded = !!imageLayer; exportDataBtn.disabled = !mapLoaded; }
        function setPointEditingState(editing, pointNameOrIndex = null) { isEditingPoint = editing; currentlyEditingPointIndex = -1; if (editingPointMarker) { map.removeLayer(editingPointMarker); editingPointMarker = null; } if (editing && pointNameOrIndex !== null) { const nameToFind = (typeof pointNameOrIndex === 'number') ? collectedPoints[pointNameOrIndex]?.name : pointNameOrIndex; if (nameToFind) currentlyEditingPointIndex = collectedPoints.findIndex(p => p.name === nameToFind); if (currentlyEditingPointIndex !== -1) { const point = collectedPoints[currentlyEditingPointIndex]; editingPointMarker = L.circleMarker(point.coords, { draggable: true, color: 'magenta', fillColor: '#ff00ff', fillOpacity: 0.5, radius: 10 }).addTo(map); editingPointMarker.on('dragend', function(event) { const marker = event.target; const position = marker.getLatLng(); lastClickedCoordsArray = [Math.round(position.lat), Math.round(position.lng)]; coordsDisplay.textContent = `[${lastClickedCoordsArray[0]}, ${lastClickedCoordsArray[1]}]`; updateStatusMessage('Point position updated by drag. Modify details and Save or Cancel.'); }); map.panTo(point.coords); } else { editing = false; isEditingPoint = false; } } addPointBtn.classList.toggle('hidden', editing); savePointChangesBtn.classList.toggle('hidden', !editing); cancelPointEditBtn.classList.toggle('hidden', !editing); if (!editing) { pointNameInput.value = ''; poiTypeSelect.value = ''; pointDescriptionInput.value = ''; pointWikiLinkInput.value = ''; coordsDisplay.textContent = '[Y, X]'; lastClickedCoordsArray = null; addPointBtn.disabled = !currentMapObject; editPointSelect.value = ""; } else { addPointBtn.disabled = true; } updateStatus(); }
        function setRegionEditingState(editing, regionNameOrIndex = null) { isEditingRegion = editing; currentlyEditingRegionIndex = -1; if (isAddingVerticesToRegion) stopAddingVertices(false); if (isEditingVertices) stopEditingVertices(false); if (editing && regionNameOrIndex !== null) { const nameToFind = (typeof regionNameOrIndex === 'number') ? collectedRegions[regionNameOrIndex]?.name : regionNameOrIndex; if (nameToFind) currentlyEditingRegionIndex = collectedRegions.findIndex(r => r.name === nameToFind); else editing = false; } regionCreationControls.classList.toggle('hidden', editing); regionEditingControls.classList.toggle('hidden', !editing); if (!editing) { if (!isCreatingRegion) { regionNameInput.value = ''; regionTypeSelect.value = ''; regionDescriptionInput.value = ''; regionWikiLinkInput.value = ''; regionColorInput.value = '#3388ff'; regionFillColorInput.value = '#3388ff'; regionOpacityInput.value = '0.2'; regionOpacityValue.textContent = '0.2';} startRegionBtn.disabled = !currentMapObject; editRegionSelect.value = ""; clearEditingVisuals(); toggleOtherRegionsVisibility(false); } else { startRegionBtn.disabled = true; } updateStatus(); }
        function setLineEditState(editing, lineIdOrName = null) { isEditingLine = editing; currentlyEditingLineIndex = -1; if (!editing && isEditingLineVertices) stopEditingLineVertices(false); if (editing && lineIdOrName !== null) { let foundIndex = collectedLines.findIndex(l => l.name === lineIdOrName && l.name); if (foundIndex === -1) foundIndex = collectedLines.findIndex(l => l.id === lineIdOrName); if (foundIndex !== -1) currentlyEditingLineIndex = foundIndex; else editing = false; } lineCreationControls.classList.toggle('hidden', editing); lineEditingControls.classList.toggle('hidden', !editing); if (!editing) { lineNameInput.value = ''; lineTypeSelect.value = ''; lineColorInput.value = '#808080'; lineWeightInput.value = '3'; lineDashArrayInput.value = ''; lineDescriptionInput.value = ''; lineWikiLinkInput.value = ''; startLineBtn.disabled = !currentMapObject; editLineSelect.value = ""; if (tempLineLayer) { map.removeLayer(tempLineLayer); tempLineLayer = null; } clearLineEditingVisuals(); } else { startLineBtn.disabled = true; } updateStatus(); }
        function setRegionCreationState(creating) { isCreatingRegion = creating; if(creating) tempRegionVertices = []; startRegionBtn.classList.toggle('hidden', creating); finishRegionBtn.classList.toggle('hidden', !creating); cancelRegionBtn.classList.toggle('hidden', !creating); mapElement.classList.toggle('region-creation-mode', creating); if (!creating && tempRegionLayer) { map.removeLayer(tempRegionLayer); tempRegionLayer = null; } updateRegionVerticesCount(); updateStatus(); }
        function setLineCreationState(creating) { isCreatingLine = creating; if (creating) tempLineVertices = []; startLineBtn.classList.toggle('hidden', creating); finishLineBtn.classList.toggle('hidden', !creating); cancelLineBtn.classList.toggle('hidden', !creating); mapElement.classList.toggle('line-creation-mode', creating); if (!creating && tempLineLayer) { map.removeLayer(tempLineLayer); tempLineLayer = null; } updateLineVerticesCount(); updateStatus(); }
        function updateRegionVerticesCount() { const count = tempRegionVertices.length; regionVerticesCount.textContent = `${count} ${count === 1 ? 'vertex' : 'vertices'}`; }
        function updateLineVerticesCount() { const count = tempLineVertices.length; lineVerticesCountDisplay.textContent = `${count} ${count === 1 ? 'vertex' : 'vertices'}`; }
        
        function resetUIForNewMap() {
            updateStatusMessage('Select a map file and click Load.');
            showEditorControls(false); // UX FIX: Hide editor until map is loaded
            coordsDisplay.textContent = '[Y, X]';
            document.querySelectorAll('input[type="text"], input[type="number"], textarea, select').forEach(el => {
                if (el.tagName === 'SELECT') el.value = '';
                else el.value = '';
            });
            scalePixelsInput.value = '3';
            scaleKilometersInput.value = '1';
            regionOpacityInput.value = '0.2';
            regionOpacityValue.textContent = '0.2';
            lastClickedCoordsArray = null;
            collectedPoints = []; collectedRegions = []; collectedLines = [];
            if (imageLayer && map) {
                map.eachLayer(layer => {
                    if (layer !== imageLayer && layer !== map) map.removeLayer(layer);
                });
                map.removeLayer(imageLayer);
                imageLayer = null;
            }
            currentMapObject = null;
            currentBounds = null;
            setPointEditingState(false);
            setRegionEditingState(false);
            setRegionCreationState(false);
            setLineEditState(false);
            setLineCreationState(false);
            updatePointsOutput();
            updateRegionsOutput();
            updateLinesOutput();
            updateRegionVerticesCount();
            updateLineVerticesCount();
        }

        async function handleMapFileSelection(event) { const filePath = event.target.value; if (!filePath) { resetUIForNewMap(); subMapSelect.innerHTML = '<option value="">-- Load a file first --</option>'; subMapSelect.disabled = true; loadSubMapBtn.disabled = true; return; } try { updateStatusMessage(`Loading ${filePath}...`, 'info'); const response = await fetch(filePath); if (!response.ok) { throw new Error(`HTTP error! status: ${response.status}`); } const jsonObject = await response.json(); if (Array.isArray(jsonObject)) { masterMapData = jsonObject; populateSubMapSelector(masterMapData); updateStatusMessage("Manifest file loaded. Select a map from the dropdown.", "success"); resetUIForNewMap(); subMapSelect.disabled = false; loadSubMapBtn.disabled = false; } else if (typeof jsonObject === 'object' && jsonObject !== null && jsonObject.imageUrl) { masterMapData = [jsonObject]; subMapSelect.innerHTML = `<option value="${jsonObject.id || ''}">${jsonObject.name || 'Single Map'}</option>`; subMapSelect.disabled = true; loadSubMapBtn.disabled = true; await loadMap(jsonObject); } else { throw new Error("Invalid JSON format. Must be an array of map objects or a single map object with an 'imageUrl' property."); } } catch (error) { flashStatusMessage(`Error loading map file: ${error.message}`, 'error'); console.error(error); masterMapData = []; subMapSelect.innerHTML = '<option value="">-- Load failed --</option>'; subMapSelect.disabled = true; loadSubMapBtn.disabled = true; resetUIForNewMap(); } }
        async function loadMapFromSelector() { const selectedMapId = subMapSelect.value; if (!selectedMapId) { alert("Please select a map from the dropdown."); return; } let mapData = null; function findMapById(items, id) { for (const item of items) { if (item.id === id) return item; if (item.children && Array.isArray(item.children)) { const found = findMapById(item.children, id); if(found) return found; } } return null; } mapData = findMapById(masterMapData, selectedMapId); if (mapData) { await loadMap(mapData); } else { alert(`Could not find map data in the manifest for ID: ${selectedMapId}`); } }
        
        async function loadMap(mapData) {
            if (!mapData || !mapData.imageUrl) { alert(`Cannot load map: the provided data is missing an 'imageUrl'.`); return; }
            resetUIForNewMap();
            currentMapObject = mapData;
            loadSubMapBtn.disabled = true;
            updateStatusMessage('Loading image and map data...');
            try {
                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = () => reject(new Error(`Could not load image file: ${mapData.imageUrl}`));
                    img.src = mapData.imageUrl;
                });
                const mapWidth = mapData.width || img.naturalWidth;
                const mapHeight = mapData.height || img.naturalHeight;
                if (mapWidth === 0 || mapHeight === 0) throw new Error('Image has zero dimensions.');
                currentBounds = [[0, 0], [mapHeight, mapWidth]];
                if (!map) throw new Error("Map object not initialized.");
                imageLayer = L.imageOverlay(mapData.imageUrl, currentBounds).addTo(map);
                map.fitBounds(currentBounds);
                scalePixelsInput.value = currentMapObject.scalePixels || 3;
                scaleKilometersInput.value = currentMapObject.scaleKilometers || 1;
                mapBlurbInput.value = currentMapObject.blurb || "";
                let pointsImported = 0, regionsImported = 0, linesImported = 0;
                if (currentMapObject.pointsOfInterest) { importPoints(currentMapObject.pointsOfInterest, true); pointsImported = currentMapObject.pointsOfInterest.length; }
                if (currentMapObject.regions) { importRegions(currentMapObject.regions, true); regionsImported = currentMapObject.regions.length; }
                if (currentMapObject.roads) { importLines(currentMapObject.roads, true); linesImported = currentMapObject.roads.length; }
                
                // UX FIX: Show editor controls AFTER map is loaded successfully
                showEditorControls(true);
                setMode('points');
                
                let finalStatus = `Loaded: ${currentMapObject.name}. Imported ${pointsImported} points, ${regionsImported} regions, ${linesImported} lines.`;
                flashStatusMessage(finalStatus, 'success');
                updateStatus();

            } catch (error) {
                flashStatusMessage(`Error loading map: ${error.message}`, 'error');
                console.error("Map Loading Error:", error);
                resetUIForNewMap();
                if (masterMapData.length > 1) { subMapSelect.disabled = false; loadSubMapBtn.disabled = false; }
            } finally {
                if (masterMapData.length > 1) { loadSubMapBtn.disabled = false; }
            }
        }
        
        function importPoints(dataToImport, suppressStatus = false) { let addedCount = 0, skippedCount = 0; const existingNames = new Set(collectedPoints.map(p => p.name)); dataToImport.forEach(item => { if (item && typeof item === 'object' && Array.isArray(item.coords) && item.coords.length === 2 && typeof item.name === 'string' && item.name.trim() !== "") { const pointName = item.name.trim(); if (existingNames.has(pointName)) skippedCount++; else { const lat = Number(item.coords[0]), lng = Number(item.coords[1]); if (!isNaN(lat) && !isNaN(lng)) { collectedPoints.push({ coords: [Math.round(lat), Math.round(lng)], name: pointName, type: item.type || "Unknown", description: item.description || "", wikiLink: item.wikiLink || "" }); existingNames.add(pointName); addedCount++; } else { console.warn("Skipping point with invalid coordinates:", item); skippedCount++; } } } else { console.warn("Skipping invalid/incomplete point during import:", item); skippedCount++;} }); updatePointsOutput(); if (!suppressStatus) flashStatusMessage(`Import complete: Added ${addedCount} points, skipped ${skippedCount}.`, 'success'); setPointEditingState(false); }
        function importRegions(dataToImport, suppressStatus = false) { let addedCount = 0, skippedCount = 0; const existingNames = new Set(collectedRegions.map(r => r.name)); dataToImport.forEach(item => { if (item && typeof item === 'object' && Array.isArray(item.coordinates) && item.coordinates.length >= 3 && typeof item.name === 'string' && item.name.trim() !== "") { const regionName = item.name.trim(); if (existingNames.has(regionName)) skippedCount++; else { const validCoords = item.coordinates.every(coord => Array.isArray(coord) && coord.length === 2 && !isNaN(Number(coord[0])) && !isNaN(Number(coord[1]))); if (validCoords) { collectedRegions.push({ id: item.id || `region-${regionName.toLowerCase().replace(/\s+/g, '-')}`, name: regionName, type: item.type || "", description: item.description || "", wikiLink: item.wikiLink || "", color: item.color || "#3388ff", fillColor: item.fillColor || "#3388ff", fillOpacity: item.fillOpacity ?? 0.2, coordinates: item.coordinates.map(coord => [Math.round(Number(coord[0])), Math.round(Number(coord[1]))]) }); existingNames.add(regionName); addedCount++; } else { console.warn("Skipping region with invalid coordinates:", item); skippedCount++; } } } else { console.warn("Skipping invalid/incomplete region during import:", item); skippedCount++; } }); updateRegionsOutput(); if (!suppressStatus) flashStatusMessage(`Import complete: Added ${addedCount} regions, skipped ${skippedCount}.`, 'success'); setRegionEditingState(false); }
        function importLines(dataToImport, suppressStatus = false) { let addedCount = 0, skippedCount = 0; const existingIds = new Set(collectedLines.map(l => l.id)); dataToImport.forEach(item => { if (item && typeof item === 'object' && Array.isArray(item.coordinates) && item.coordinates.length >= 2 && typeof item.id === 'string' && item.id.trim() !== "") { const lineId = item.id.trim(); if (existingIds.has(lineId)) skippedCount++; else { const validCoords = item.coordinates.every(coord => Array.isArray(coord) && coord.length === 2 && !isNaN(Number(coord[0])) && !isNaN(Number(coord[1]))); if (validCoords) { collectedLines.push({ id: lineId, name: item.name || "", type: item.type || "", description: item.description || "", wikiLink: item.wikiLink || "", color: item.color || "#808080", weight: item.weight || 3, dashArray: item.dashArray || "", coordinates: item.coordinates.map(coord => [Math.round(Number(coord[0])), Math.round(Number(coord[1]))]) }); existingIds.add(lineId); addedCount++; } else { console.warn("Skipping line with invalid coordinates:", item); skippedCount++; } } } else { console.warn("Skipping invalid/incomplete line during import:", item); skippedCount++; } }); updateLinesOutput(); if (!suppressStatus) flashStatusMessage(`Line import: Added ${addedCount}, skipped ${skippedCount}.`, 'success'); setLineEditState(false); }
        function loadPointForEditing(pointName) { const index = collectedPoints.findIndex(p => p.name === pointName); if (index === -1) { setPointEditingState(false); return; } const point = collectedPoints[index]; pointNameInput.value = point.name; poiTypeSelect.value = point.type || ""; pointDescriptionInput.value = point.description || ""; pointWikiLinkInput.value = point.wikiLink || ""; coordsDisplay.textContent = `[${point.coords[0]}, ${point.coords[1]}]`; lastClickedCoordsArray = [...point.coords]; setPointEditingState(true, point.name); }
        function loadRegionForEditing(regionName) { const index = collectedRegions.findIndex(r => r.name === regionName); if (index === -1) { setRegionEditingState(false); return; } const region = collectedRegions[index]; regionNameInput.value = region.name; regionTypeSelect.value = region.type || ""; regionDescriptionInput.value = region.description || ""; regionWikiLinkInput.value = region.wikiLink || ""; regionColorInput.value = region.color || "#3b82f6"; regionFillColorInput.value = region.fillColor || "#3b82f6"; regionOpacityInput.value = region.fillOpacity ?? 0.2; regionOpacityValue.textContent = region.fillOpacity ?? 0.2; clearEditingVisuals(); editingVisualsLayerGroup = L.layerGroup().addTo(map); editingPolygonLayer = L.polygon(region.coordinates, { color: region.color || "#3b82f6", fillColor: region.fillColor || "#3b82f6", fillOpacity: region.fillOpacity ?? 0.2, weight: 3, dashArray: "5, 5" }); editingVisualsLayerGroup.addLayer(editingPolygonLayer); map.fitBounds(editingPolygonLayer.getBounds().pad(0.1)); if (showAllRegionsWhileEditing) { toggleOtherRegionsVisibility(true, index); } setRegionEditingState(true, region.name); }
        function loadLineEdit(lineIdOrName) { let index = collectedLines.findIndex(l => l.name === lineIdOrName && l.name); if (index === -1) index = collectedLines.findIndex(l => l.id === lineIdOrName); if (index === -1) { setLineEditState(false); return; } const line = collectedLines[index]; lineNameInput.value = line.name || ""; lineTypeSelect.value = line.type || ""; lineColorInput.value = line.color || "#808080"; lineWeightInput.value = line.weight || 3; lineDashArrayInput.value = line.dashArray || ""; lineDescriptionInput.value = line.description || ""; lineWikiLinkInput.value = line.wikiLink || ""; if (tempLineLayer) map.removeLayer(tempLineLayer); tempLineLayer = L.polyline(line.coordinates, { color: line.color || "#FFD700", weight: (parseInt(line.weight) || 3) + 2, opacity: 0.8, dashArray: '10, 5' }).addTo(map); if (line.coordinates && line.coordinates.length > 0) map.fitBounds(L.polyline(line.coordinates).getBounds().pad(0.1)); setLineEditState(true, line.id); }
        function savePointChanges() { if (!isEditingPoint || currentlyEditingPointIndex < 0 || currentlyEditingPointIndex >= collectedPoints.length) return; const originalPoint = collectedPoints[currentlyEditingPointIndex]; const newName = pointNameInput.value.trim(), newType = poiTypeSelect.value; if (!newName) { alert("Point Name cannot be empty."); pointNameInput.focus(); return; } if (!newType) { alert("Please select a Point Type."); poiTypeSelect.focus(); return; } if (newName !== originalPoint.name && collectedPoints.some((p, i) => i !== currentlyEditingPointIndex && p.name === newName)) { alert(`Another point named "${newName}" already exists.`); pointNameInput.focus(); return; } originalPoint.name = newName; originalPoint.type = newType; originalPoint.description = pointDescriptionInput.value.trim(); originalPoint.wikiLink = pointWikiLinkInput.value.trim(); if (lastClickedCoordsArray) originalPoint.coords = [...lastClickedCoordsArray]; updatePointsOutput(); flashStatusMessage(`Point "${newName}" updated.`, 'success'); setPointEditingState(false); }
        function cancelPointEditing() { if (editingPointMarker) { map.removeLayer(editingPointMarker); editingPointMarker = null; } setPointEditingState(false); updateStatusMessage('Point editing cancelled.'); }
        function saveRegionChanges() { if (!isEditingRegion || currentlyEditingRegionIndex < 0 || currentlyEditingRegionIndex >= collectedRegions.length) return; const originalRegion = collectedRegions[currentlyEditingRegionIndex]; const newName = regionNameInput.value.trim(), newType = regionTypeSelect.value; const newDescription = regionDescriptionInput.value.trim(), newWikiLink = regionWikiLinkInput.value.trim(); const newColor = regionColorInput.value, newFillColor = regionFillColorInput.value; const newOpacity = parseFloat(regionOpacityInput.value); if (!newName) { alert("Region Name cannot be empty."); regionNameInput.focus(); return; } if (isNaN(newOpacity) || newOpacity < 0 || newOpacity > 1) { alert("Invalid Opacity (0.0-1.0)."); regionOpacityInput.focus(); return; } if (newName !== originalRegion.name && collectedRegions.some((r, i) => i !== currentlyEditingRegionIndex && r.name === newName)) { alert(`Another region named "${newName}" already exists.`); regionNameInput.focus(); return; } originalRegion.name = newName; originalRegion.type = newType; originalRegion.description = newDescription; originalRegion.wikiLink = newWikiLink; originalRegion.color = newColor; originalRegion.fillColor = newFillColor; originalRegion.fillOpacity = newOpacity; originalRegion.id = `region-${newName.toLowerCase().replace(/\s+/g, '-')}`; updateRegionsOutput(); flashStatusMessage(`Region "${newName}" updated.`, 'success'); setRegionEditingState(false); }
        function cancelRegionEditing() { setRegionEditingState(false); updateStatusMessage('Region editing cancelled.'); }
        function saveLineChanges() { if (!isEditingLine || currentlyEditingLineIndex < 0 || currentlyEditingLineIndex >= collectedLines.length) return; const originalLine = collectedLines[currentlyEditingLineIndex]; const newName = lineNameInput.value.trim(), newType = lineTypeSelect.value; const newColor = lineColorInput.value, newWeight = parseInt(lineWeightInput.value); const newDashArray = lineDashArrayInput.value.trim(); const newDescription = lineDescriptionInput.value.trim(), newWikiLink = lineWikiLinkInput.value.trim(); if (isNaN(newWeight) || newWeight < 1) { alert("Invalid Line Weight."); lineWeightInput.focus(); return; } originalLine.name = newName; originalLine.type = newType; originalLine.color = newColor; originalLine.weight = newWeight; originalLine.dashArray = newDashArray; originalLine.description = newDescription; originalLine.wikiLink = newWikiLink; updateLinesOutput(); flashStatusMessage(`Line "${newName || originalLine.id}" updated.`, 'success'); setLineEditState(false); }
        function cancelLineEdit() { if (tempLineLayer) { map.removeLayer(tempLineLayer); tempLineLayer = null; } setLineEditState(false); updateStatusMessage('Line editing cancelled.'); }
        function startRegionCreation() { if (!currentMapObject) { alert("Load a map first!"); return; } if (isEditingRegion) { alert("Finish editing the current region first."); return; } setRegionCreationState(true); }
        function startLineCreation() { if (!currentMapObject) { alert("Load a map first!"); return; } if (isEditingLine) { alert("Finish editing current line first."); return; } setLineCreationState(true); }
        function handleMapClickForRegion(e) { if (!isCreatingRegion && !isAddingVerticesToRegion) return; const coords = [Math.round(e.latlng.lat), Math.round(e.latlng.lng)]; if (isCreatingRegion) { tempRegionVertices.push(coords); updateRegionVerticesCount(); if (tempRegionLayer) map.removeLayer(tempRegionLayer); if (tempRegionVertices.length >= 2) { const options = { color: regionColorInput.value || '#3388ff', fillColor: regionFillColorInput.value || '#3388ff', fillOpacity: parseFloat(regionOpacityInput.value) || 0.2, weight: 2, dashArray: '5, 5' }; tempRegionLayer = (tempRegionVertices.length === 2) ? L.polyline(tempRegionVertices, options) : L.polygon(tempRegionVertices, options); tempRegionLayer.addTo(map); } updateStatusMessage(`Added vertex ${tempRegionVertices.length}. Click map for next, or Finish.`); } else if (isAddingVerticesToRegion) handleMapClickForVertexAdd(coords); }
        function handleMapClickForLineCreation(e) { if (!isCreatingLine) return; const coords = [Math.round(e.latlng.lat), Math.round(e.latlng.lng)]; tempLineVertices.push(coords); updateLineVerticesCount(); if (tempLineLayer) map.removeLayer(tempLineLayer); if (tempLineVertices.length >= 1) { const lineOpts = { color: lineColorInput.value || '#808080', weight: parseInt(lineWeightInput.value) || 3, dashArray: lineDashArrayInput.value.trim() || null, opacity: 0.7 }; tempLineLayer = (tempLineVertices.length === 1) ? L.circleMarker(tempLineVertices[0], {...lineOpts, radius: lineOpts.weight + 2, fillOpacity: 0.5 }) : L.polyline(tempLineVertices, lineOpts); tempLineLayer.addTo(map); } updateStatusMessage(`Added line vertex ${tempLineVertices.length}. Click map for next, or Finish Line.`); }
        function finishRegionCreation() { if (!isCreatingRegion || tempRegionVertices.length < 3) { alert("A region needs at least 3 vertices."); return; } const regionName = regionNameInput.value.trim(), regionType = regionTypeSelect.value; const regionColor = regionColorInput.value, regionFillColor = regionFillColorInput.value; const regionOpacity = parseFloat(regionOpacityInput.value); const regionDescription = regionDescriptionInput.value.trim(), regionWikiLink = regionWikiLinkInput.value.trim(); if (!regionName) { alert("Region Name cannot be empty."); regionNameInput.focus(); return; } if (isNaN(regionOpacity) || regionOpacity < 0 || regionOpacity > 1) { alert("Invalid Opacity (0.0-1.0)."); regionOpacityInput.focus(); return; } if (collectedRegions.some(r => r.name === regionName)) { alert(`A region named "${regionName}" already exists.`); regionNameInput.focus(); return; } collectedRegions.push({ id: `region-${regionName.toLowerCase().replace(/\s+/g, '-')}`, name: regionName, type: regionType, description: regionDescription, wikiLink: regionWikiLink, color: regionColor, fillColor: regionFillColor, fillOpacity: regionOpacity, coordinates: [...tempRegionVertices] }); updateRegionsOutput(); flashStatusMessage(`Region "${regionName}" created.`, 'success'); setRegionCreationState(false); regionNameInput.value = ''; regionTypeSelect.value = ''; regionDescriptionInput.value = ''; regionWikiLinkInput.value = ''; }
        function cancelRegionCreation() { if (!isCreatingRegion) return; setRegionCreationState(false); updateStatusMessage('Region creation cancelled.'); }
        function finishLineCreation() { if (!isCreatingLine || tempLineVertices.length < 2) { alert("A line needs at least 2 vertices."); return; } const lineName = lineNameInput.value.trim(), lineType = lineTypeSelect.value; const lineColor = lineColorInput.value, lineWeight = parseInt(lineWeightInput.value); const lineDashArray = lineDashArrayInput.value.trim(); const lineDescription = lineDescriptionInput.value.trim(), lineWikiLink = lineWikiLinkInput.value.trim(); if (isNaN(lineWeight) || lineWeight < 1) { alert("Invalid Line Weight."); lineWeightInput.focus(); return; } const lineId = `line-${currentMapObject.id || 'map'}-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`; collectedLines.push({ id: lineId, name: lineName, type: lineType, description: lineDescription, wikiLink: lineWikiLink, color: lineColor, weight: lineWeight, dashArray: lineDashArray, coordinates: [...tempLineVertices] }); updateLinesOutput(); flashStatusMessage(`Line "${lineName || lineId}" created.`, 'success'); setLineCreationState(false); lineNameInput.value = ''; lineTypeSelect.value = ''; lineDescriptionInput.value = ''; lineWikiLinkInput.value = ''; lineColorInput.value = '#808080'; lineWeightInput.value = '3'; lineDashArrayInput.value = ''; }
        function cancelLineCreation() { if (!isCreatingLine) return; setLineCreationState(false); updateStatusMessage('Line creation cancelled.'); }
        function startAddingVertices() { if (!isEditingRegion || currentlyEditingRegionIndex < 0) return; if (isEditingVertices) { alert("Stop adjusting shape first."); return; } if (isAddingVerticesToRegion) stopAddingVertices(true); else { addingVerticesData.index = currentlyEditingRegionIndex; addingVerticesData.newPoints = []; setVertexAddingState(true); if (editingPolygonLayer) editingPolygonLayer.setStyle({ dashArray: null, weight: 5 }); } }
        function stopAddingVertices(userInitiated = false) { if (!isAddingVerticesToRegion) return; const region = collectedRegions[addingVerticesData.index]; if (addingVerticesData.newPoints.length > 0) { let closestSegmentIndex = -1, minDistanceSq = Infinity; const firstNewPoint = L.latLng(addingVerticesData.newPoints[0]); for (let i = 0; i < region.coordinates.length; i++) { const p1 = L.latLng(region.coordinates[i]), p2 = L.latLng(region.coordinates[(i + 1) % region.coordinates.length]); const closestPointOnSegment = L.GeometryUtil.closest(map, L.polyline([p1, p2]), firstNewPoint); const distanceSq = firstNewPoint.distanceTo(closestPointOnSegment) ** 2; if (distanceSq < minDistanceSq) { minDistanceSq = distanceSq; closestSegmentIndex = i; } } region.coordinates.splice(closestSegmentIndex + 1, 0, ...addingVerticesData.newPoints); updateRegionsOutput(); loadRegionForEditing(region.name); flashStatusMessage(`Added ${addingVerticesData.newPoints.length} points to '${region.name}'.`, 'success'); } else if (userInitiated) updateStatusMessage(`Stopped adding points to '${region.name}'. No points added.`, 'info'); addingVerticesData.index = -1; addingVerticesData.newPoints = []; setVertexAddingState(false); if (editingPolygonLayer) editingPolygonLayer.setStyle({ dashArray: "5, 5", weight: 3 }); }
        function handleMapClickForVertexAdd(coords) { if (!isAddingVerticesToRegion) return; addingVerticesData.newPoints.push(coords); if (editingVisualsLayerGroup) L.circleMarker(coords, { radius: 5, color: 'lime', fillColor: 'lime', fillOpacity: 0.8, pane: 'markerPane' }).addTo(editingVisualsLayerGroup); updateStatusMessage(`Added new point ${addingVerticesData.newPoints.length}. Click map for next, or Stop Adding.`); }
        function startEditingVertices() { if (!isEditingRegion || currentlyEditingRegionIndex < 0) return; if (isAddingVerticesToRegion) { alert("Stop adding points first."); return; } if (isEditingVertices) stopEditingVertices(true); else { setVertexEditingState(true); createVertexMarkers(); } }
        function stopEditingVertices(userInitiated = false) { if (!isEditingVertices) return; let changed = false; if (editingVisualsLayerGroup) { const region = collectedRegions[currentlyEditingRegionIndex]; const newCoords = []; const vertexMarkers = []; editingVisualsLayerGroup.eachLayer(layer => { if (layer.options.isVertexMarker) vertexMarkers.push(layer); }); vertexMarkers.sort((a, b) => a.options.vertexIndex - b.options.vertexIndex); vertexMarkers.forEach((marker, index) => { const newLatLng = marker.getLatLng(), newCoord = [Math.round(newLatLng.lat), Math.round(newLatLng.lng)]; newCoords.push(newCoord); if (index < region.coordinates.length && (region.coordinates[index][0] !== newCoord[0] || region.coordinates[index][1] !== newCoord[1])) changed = true; }); if (newCoords.length !== region.coordinates.length) changed = true; if (changed) { region.coordinates = newCoords; updateRegionsOutput(); loadRegionForEditing(region.name); flashStatusMessage(`Shape updated for region '${region.name}'.`, 'success'); } else if (userInitiated) updateStatusMessage(`Stopped adjusting shape for '${region.name}'. No changes made.`, 'info'); } clearEditingVisuals(); setVertexEditingState(false); }
        function createVertexMarkers() { if (!isEditingRegion || currentlyEditingRegionIndex < 0 || !editingPolygonLayer) return; clearEditingVisuals(); editingVisualsLayerGroup = L.layerGroup().addTo(map); const region = collectedRegions[currentlyEditingRegionIndex]; const latLngs = region.coordinates; editingPolygonLayer = L.polygon(latLngs, { color: region.color || "#3388ff", fillColor: region.fillColor || "#3388ff", fillOpacity: region.fillOpacity || 0.2, weight: 3, dashArray: "5, 5" }).addTo(editingVisualsLayerGroup); latLngs.forEach((latLng, index) => addVertexMarker(latLng, index)); addMidpointMarkers(); }
        function addVertexMarker(latLng, index) { const marker = L.marker(latLng, { draggable: true, icon: L.divIcon({ className: 'vertex-marker', iconSize: [12, 12], iconAnchor: [6, 6] }), isVertexMarker: true, vertexIndex: index }).addTo(editingVisualsLayerGroup); marker.on('drag', updatePolygonFromMarkers); marker.on('dragend', () => { const newLatLng = marker.getLatLng(); marker.setLatLng([Math.round(newLatLng.lat), Math.round(newLatLng.lng)]); updatePolygonFromMarkers(); }); marker.on('click', (e) => { L.DomEvent.stopPropagation(e); if (activeVertexMarker && activeVertexMarker._icon) activeVertexMarker._icon.classList.remove('active'); activeVertexMarker = marker; if (marker._icon) marker._icon.classList.add('active'); updateStatus(); }); return marker; }
        function addMidpointMarkers() { if (!editingVisualsLayerGroup || !editingPolygonLayer) return; const latLngs = editingPolygonLayer.getLatLngs()[0]; editingVisualsLayerGroup.eachLayer(layer => { if (layer.options.isMidpointMarker) editingVisualsLayerGroup.removeLayer(layer); }); for (let i = 0; i < latLngs.length; i++) { const p1 = latLngs[i], p2 = latLngs[(i + 1) % latLngs.length]; const midPoint = L.latLng((p1.lat + p2.lat) / 2, (p1.lng + p2.lng) / 2); const midMarker = L.marker(midPoint, { draggable: true, icon: L.divIcon({ className: 'new-vertex-marker', iconSize: [8, 8], iconAnchor: [4, 4] }), isMidpointMarker: true, segmentStartIndex: i }).addTo(editingVisualsLayerGroup); midMarker.on('dragstart', (e) => { const marker = e.target, segmentStartIndex = marker.options.segmentStartIndex; const newLatLng = marker.getLatLng(), newCoord = [Math.round(newLatLng.lat), Math.round(newLatLng.lng)]; editingVisualsLayerGroup.removeLayer(marker); const currentLatLngs = editingPolygonLayer.getLatLngs()[0]; currentLatLngs.splice(segmentStartIndex + 1, 0, L.latLng(newCoord)); editingPolygonLayer.setLatLngs(currentLatLngs); recreateAllVertexMarkers(); updateStatusMessage('Added new point. Continue dragging or Stop.', 'info'); }); } }
        function recreateAllVertexMarkers() { if (!editingVisualsLayerGroup || !editingPolygonLayer) return; const currentLatLngs = editingPolygonLayer.getLatLngs()[0]; editingVisualsLayerGroup.eachLayer(layer => { if (layer.options.isVertexMarker || layer.options.isMidpointMarker) editingVisualsLayerGroup.removeLayer(layer); }); currentLatLngs.forEach((latLng, index) => addVertexMarker(latLng, index)); addMidpointMarkers(); }
        function updatePolygonFromMarkers() { if (!isEditingVertices || !editingVisualsLayerGroup || !editingPolygonLayer) return; const newLatLngs = [], vertexMarkers = []; editingVisualsLayerGroup.eachLayer(layer => { if (layer.options.isVertexMarker) vertexMarkers.push(layer); }); vertexMarkers.sort((a, b) => a.options.vertexIndex - b.options.vertexIndex); vertexMarkers.forEach(marker => newLatLngs.push(marker.getLatLng())); if (newLatLngs.length >= 3) { editingPolygonLayer.setLatLngs(newLatLngs); addMidpointMarkers(); } }
        function clearEditingVisuals() { if (editingVisualsLayerGroup) { map.removeLayer(editingVisualsLayerGroup); editingVisualsLayerGroup = null; editingPolygonLayer = null; } activeVertexMarker = null; }
        function setVertexEditingState(editing) { isEditingVertices = editing; editVerticesBtn.textContent = editing ? 'Stop Adjusting' : 'Adjust Shape'; addVerticesBtn.textContent = isAddingVerticesToRegion ? 'Stop Adding' : 'Add Points'; mapElement.classList.toggle('vertex-editing-mode', editing); mapElement.classList.toggle('disabled-map', !editing && isEditingRegion && !isAddingVerticesToRegion); saveRegionChangesBtn.disabled = editing || isAddingVerticesToRegion; cancelRegionEditBtn.disabled = editing || isAddingVerticesToRegion; regionNameInput.disabled = editing || isAddingVerticesToRegion; regionTypeSelect.disabled = editing || isAddingVerticesToRegion; editRegionSelect.disabled = editing || isAddingVerticesToRegion; startRegionBtn.disabled = true; if (editingVisualsLayerGroup) { editingVisualsLayerGroup.eachLayer(layer => { if (layer.options.isVertexMarker && layer.dragging) { if (editing) layer.dragging.enable(); else layer.dragging.disable(); } }); } if (!editing) activeVertexMarker = null; updateStatus(); }
        function setVertexAddingState(adding) { isAddingVerticesToRegion = adding; addVerticesBtn.textContent = adding ? 'Stop Adding' : 'Add Points'; mapElement.classList.toggle('vertex-adding-mode', adding); mapElement.classList.toggle('disabled-map', !adding && isEditingRegion && !isEditingVertices); saveRegionChangesBtn.disabled = adding || isEditingVertices; cancelRegionEditBtn.disabled = adding || isEditingVertices; editVerticesBtn.disabled = adding; regionNameInput.disabled = adding || isEditingVertices; regionTypeSelect.disabled = adding || isEditingVertices; editRegionSelect.disabled = adding || isEditingVertices; startRegionBtn.disabled = true; updateStatus(); }
        function setLineVertexEditingState(editing) { isEditingLineVertices = editing; editLineVerticesBtn.textContent = editing ? 'Stop Adjusting' : 'Adjust Shape'; mapElement.classList.toggle('line-vertex-editing-mode', editing); mapElement.classList.toggle('disabled-map', !editing && isEditingLine && !isCreatingLine); saveLineChangesBtn.disabled = editing; editLineVerticesBtn.disabled = false; cancelLineEditBtn.disabled = editing; lineNameInput.disabled = editing; lineTypeSelect.disabled = editing; lineColorInput.disabled = editing; lineWeightInput.disabled = editing; lineDashArrayInput.disabled = editing; lineDescriptionInput.disabled = editing; lineWikiLinkInput.disabled = editing; editLineSelect.disabled = editing; startLineBtn.disabled = true; if (editingLineVisualsLayerGroup) { editingLineVisualsLayerGroup.eachLayer(layer => { if (layer.options.isLineVertexMarker && layer.dragging) { if (editing) layer.dragging.enable(); else layer.dragging.disable(); } }); } if (!editing) activeVertexMarker = null; updateStatus(); }
        function startEditingLineVertices() { if (!isEditingLine || currentlyEditingLineIndex < 0) return; if (isEditingLineVertices) { stopEditingLineVertices(true); } else { setLineVertexEditingState(true); createLineVertexMarkersAndPolyline(); saveLineChangesBtn.classList.add('hidden'); cancelLineEditBtn.classList.add('hidden'); editLineVerticesBtn.textContent = 'Stop Adjusting'; } }
        function stopEditingLineVertices(userInitiated = false) { if (!isEditingLineVertices) return; let changed = false; const line = collectedLines[currentlyEditingLineIndex]; if (editingLineVisualsLayerGroup && line) { const newCoords = []; const vertexMarkers = []; editingLineVisualsLayerGroup.eachLayer(layer => { if (layer.options.isLineVertexMarker) vertexMarkers.push(layer); }); vertexMarkers.sort((a, b) => a.options.vertexIndex - b.options.vertexIndex); vertexMarkers.forEach((marker, index) => { const newLatLng = marker.getLatLng(); const newCoord = [Math.round(newLatLng.lat), Math.round(newLatLng.lng)]; newCoords.push(newCoord); if (index < line.coordinates.length && (line.coordinates[index][0] !== newCoord[0] || line.coordinates[index][1] !== newCoord[1])) changed = true; }); if (newCoords.length !== line.coordinates.length) changed = true; if (changed) { line.coordinates = newCoords; updateLinesOutput(); flashStatusMessage(`Line shape updated for '${line.name || line.id}'. Save changes to persist.`, 'success'); } else if (userInitiated) { updateStatusMessage(`Stopped adjusting line shape. No changes to points.`, 'info'); } } clearLineEditingVisuals(); setLineVertexEditingState(false); loadLineEdit(line.name || line.id); saveLineChangesBtn.classList.remove('hidden'); cancelLineEditBtn.classList.remove('hidden'); editLineVerticesBtn.textContent = 'Adjust Shape'; editLineVerticesBtn.classList.remove('hidden'); }
        function createLineVertexMarkersAndPolyline() { if (!isEditingLine || currentlyEditingLineIndex < 0) return; clearLineEditingVisuals(); editingLineVisualsLayerGroup = L.layerGroup().addTo(map); const line = collectedLines[currentlyEditingLineIndex]; const latLngs = line.coordinates.map(c => L.latLng(c[0], c[1])); editingLinePolylineLayer = L.polyline(latLngs, { color: line.color || "#808080", weight: line.weight || 3, dashArray: line.dashArray || null, opacity: 0.9 }).addTo(editingLineVisualsLayerGroup); latLngs.forEach((latLng, index) => addLineVertexMarker(latLng, index)); addLineMidpointMarkers(); if (tempLineLayer) map.removeLayer(tempLineLayer); }
        function addLineVertexMarker(latLng, index) { const marker = L.marker(latLng, { draggable: true, icon: L.divIcon({ className: 'line-vertex-marker', iconSize: [12, 12], iconAnchor: [6, 6] }), isLineVertexMarker: true, vertexIndex: index }).addTo(editingLineVisualsLayerGroup); marker.on('drag', updateLinePolylineFromMarkers); marker.on('dragend', () => { const newLatLng = marker.getLatLng(); marker.setLatLng([Math.round(newLatLng.lat), Math.round(newLatLng.lng)]); updateLinePolylineFromMarkers(); }); marker.on('click', (e) => { L.DomEvent.stopPropagation(e); if (activeVertexMarker && activeVertexMarker._icon) activeVertexMarker._icon.classList.remove('active'); activeVertexMarker = marker; if (marker._icon) marker._icon.classList.add('active'); updateStatus(); }); return marker; }
        function addLineMidpointMarkers() { if (!editingLineVisualsLayerGroup || !editingLinePolylineLayer) return; const latLngs = editingLinePolylineLayer.getLatLngs(); editingLineVisualsLayerGroup.eachLayer(layer => { if (layer.options.isLineMidpointMarker) editingLineVisualsLayerGroup.removeLayer(layer); }); for (let i = 0; i < latLngs.length - 1; i++) { const p1 = latLngs[i], p2 = latLngs[i + 1]; const midPoint = L.latLng((p1.lat + p2.lat) / 2, (p1.lng + p2.lng) / 2); const midMarker = L.marker(midPoint, { draggable: true, icon: L.divIcon({ className: 'new-line-vertex-marker', iconSize: [8, 8], iconAnchor: [4, 4] }), isLineMidpointMarker: true, segmentStartIndex: i }).addTo(editingLineVisualsLayerGroup); midMarker.on('dragstart', (e) => { const draggedMidMarker = e.target; const segmentStartIndex = draggedMidMarker.options.segmentStartIndex; const newLatLng = draggedMidMarker.getLatLng(); const newCoord = [Math.round(newLatLng.lat), Math.round(newLatLng.lng)]; editingLineVisualsLayerGroup.removeLayer(draggedMidMarker); const currentPolylineLatLngs = editingLinePolylineLayer.getLatLngs(); currentPolylineLatLngs.splice(segmentStartIndex + 1, 0, L.latLng(newCoord)); editingLinePolylineLayer.setLatLngs(currentPolylineLatLngs); recreateAllLineVertexMarkers(); updateStatusMessage('Added new line point. Continue dragging or Stop.', 'info'); }); } }
        function recreateAllLineVertexMarkers() { if (!editingLineVisualsLayerGroup || !editingLinePolylineLayer) return; const currentLatLngs = editingLinePolylineLayer.getLatLngs(); editingLineVisualsLayerGroup.eachLayer(layer => { if (layer.options.isLineVertexMarker || layer.options.isLineMidpointMarker) { editingLineVisualsLayerGroup.removeLayer(layer); } }); currentLatLngs.forEach((latLng, index) => addLineVertexMarker(latLng, index)); addLineMidpointMarkers(); }
        function updateLinePolylineFromMarkers() { if (!isEditingLineVertices || !editingLineVisualsLayerGroup || !editingLinePolylineLayer) return; const newLatLngs = []; const vertexMarkers = []; editingLineVisualsLayerGroup.eachLayer(layer => { if (layer.options.isLineVertexMarker) vertexMarkers.push(layer); }); vertexMarkers.sort((a, b) => a.options.vertexIndex - b.options.vertexIndex); vertexMarkers.forEach(marker => newLatLngs.push(marker.getLatLng())); if (newLatLngs.length >= 2) { editingLinePolylineLayer.setLatLngs(newLatLngs); addLineMidpointMarkers(); } }
        function clearLineEditingVisuals() { if (editingLineVisualsLayerGroup) { map.removeLayer(editingLineVisualsLayerGroup); editingLineVisualsLayerGroup = null; editingLinePolylineLayer = null; } activeVertexMarker = null; }
        function generateCompleteMapData() { if (!currentMapObject) { return null; } const updatedMasterData = JSON.parse(JSON.stringify(masterMapData)); let mapToUpdate = findMapByIdRecursive(updatedMasterData, currentMapObject.id); if (!mapToUpdate) { if (updatedMasterData.length === 1 && updatedMasterData[0].id === currentMapObject.id) { mapToUpdate = updatedMasterData[0]; } else { console.error("Could not find edited map in data structure."); return null; } } mapToUpdate.scalePixels = parseInt(scalePixelsInput.value) || 3; mapToUpdate.scaleKilometers = parseFloat(scaleKilometersInput.value) || 1; mapToUpdate.blurb = mapBlurbInput.value || ""; mapToUpdate.pointsOfInterest = [...collectedPoints].sort((a,b)=>a.name.localeCompare(b.name)).map(p => ({ coords: p.coords, name: p.name || "", type: p.type || "Unknown", description: p.description || "", wikiLink: p.wikiLink || "" })); mapToUpdate.regions = [...collectedRegions].sort((a,b)=>a.name.localeCompare(b.name)).map(r => ({ id: r.id || `region-${(r.name || "untitled").toLowerCase().replace(/\s+/g, '-')}`, name: r.name || "", description: r.description || "", type: r.type || "", color: r.color || "#3388ff", fillColor: r.fillColor || "#3388ff", fillOpacity: r.fillOpacity ?? 0.2, wikiLink: r.wikiLink || "", coordinates: r.coordinates || [] })); mapToUpdate.roads = [...collectedLines].sort((a,b)=>(a.name||a.id).localeCompare(b.name||b.id)).map(l => ({ id: l.id, name: l.name || "", type: l.type || "", color: l.color || "#808080", weight: l.weight || 3, dashArray: l.dashArray || "", description: l.description || "", wikiLink: l.wikiLink || "", coordinates: l.coordinates || [] })); if (masterMapData.length === 1) { return mapToUpdate; } return updatedMasterData; }
        function showJsonModal(jsonContent, filename = "maps.json") { jsonModalTitle.textContent = filename; jsonModalTextarea.value = jsonContent; jsonModal.classList.remove('hidden'); }
        function initMap() { if (map) return; map = L.map('map', { crs: L.CRS.Simple, minZoom: -5, maxZoom: 5, center: [0, 0], zoom: 0, doubleClickZoom: false }); map.on('click', (e) => { if (activeVertexMarker) { if (activeVertexMarker._icon) activeVertexMarker._icon.classList.remove('active'); activeVertexMarker = null; updateStatus(); } if (!currentMapObject) return; const isEditingActivity = isEditingPoint || (currentMode === 'regions' && (isCreatingRegion || isAddingVerticesToRegion || isEditingVertices)) || (currentMode === 'lines' && (isCreatingLine || isEditingLineVertices)); if (isEditingActivity) { if (currentMode === 'points' && isEditingPoint && editingPointMarker) { const newCoords = [Math.round(e.latlng.lat), Math.round(e.latlng.lng)]; lastClickedCoordsArray = newCoords; coordsDisplay.textContent = `[${newCoords[0]}, ${newCoords[1]}]`; editingPointMarker.setLatLng(e.latlng); updateStatusMessage('Point position updated by click.'); } else if (currentMode === 'regions' && (isCreatingRegion || isAddingVerticesToRegion)) { handleMapClickForRegion(e); } else if (currentMode === 'lines' && isCreatingLine) { handleMapClickForLineCreation(e); } return; } if (currentMode === 'points') { lastClickedCoordsArray = [Math.round(e.latlng.lat), Math.round(e.latlng.lng)]; coordsDisplay.textContent = `[${lastClickedCoordsArray[0]}, ${lastClickedCoordsArray[1]}]`; pointNameInput.value = ''; poiTypeSelect.value = ''; pointDescriptionInput.value = ''; pointWikiLinkInput.value = ''; addPointBtn.disabled = false; updateStatusMessage('Coordinates captured. Enter details and Add.'); pointNameInput.focus(); } }); map.on('mousemove', (e) => { const isPassiveMode = !isEditingPoint && !(currentMode === 'regions' && (isCreatingRegion || isAddingVerticesToRegion || isEditingVertices)) && !(currentMode === 'lines' && (isCreatingLine || isEditingLineVertices)); if (isPassiveMode) { coordsDisplay.textContent = `[${Math.round(e.latlng.lat)}, ${Math.round(e.latlng.lng)}]`; } }); }
        function populateMapFileSelector() { mapFileSelect.innerHTML = '<option value="">-- Select a map file --</option>'; for (const [name, path] of Object.entries(HARDCODED_MAP_FILES)) { const option = document.createElement('option'); option.value = path; option.textContent = name; mapFileSelect.appendChild(option); } }
        function handleVertexDelete() { if (!activeVertexMarker) return; if (currentMode === 'regions' && isEditingVertices && editingPolygonLayer) { const latLngs = editingPolygonLayer.getLatLngs()[0]; if (latLngs.length <= 3) { alert("A region must have at least 3 points."); return; } latLngs.splice(activeVertexMarker.options.vertexIndex, 1); editingPolygonLayer.setLatLngs(latLngs); activeVertexMarker = null; recreateAllVertexMarkers(); updateStatusMessage('Point deleted.', 'info'); } else if (currentMode === 'lines' && isEditingLineVertices && editingLinePolylineLayer) { const latLngs = editingLinePolylineLayer.getLatLngs(); if (latLngs.length <= 2) { alert("A line must have at least 2 points."); return; } latLngs.splice(activeVertexMarker.options.vertexIndex, 1); editingLinePolylineLayer.setLatLngs(latLngs); activeVertexMarker = null; recreateAllLineVertexMarkers(); updateStatusMessage('Point deleted.', 'info'); } }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            applyModernStyles(); initMap(); populateTypeDropdown(); populateMapFileSelector(); resetUIForNewMap();
            sidebarOpenBtn.addEventListener('click', () => sidebar.classList.remove('-translate-x-full'));
            sidebarCloseBtn.addEventListener('click', () => sidebar.classList.add('-translate-x-full'));
            regionOpacityInput.addEventListener('input', (e) => { regionOpacityValue.textContent = e.target.value; });
            jsonModalCloseBtns.forEach(btn => btn.addEventListener('click', () => jsonModal.classList.add('hidden')));
            jsonModal.addEventListener('click', (e) => { if (e.target === jsonModal) jsonModal.classList.add('hidden'); });
            document.addEventListener('keydown', (e) => { if ((e.key === 'Delete' || e.key === 'Backspace') && activeVertexMarker) { e.preventDefault(); handleVertexDelete(); } });
            mapFileSelect.addEventListener('change', handleMapFileSelection);
            loadSubMapBtn.addEventListener('click', loadMapFromSelector);
            modeTabs.forEach(tab => tab.addEventListener('click', () => setMode(tab.dataset.mode)));
            addPointBtn.addEventListener('click', () => { if (!lastClickedCoordsArray) { alert("Click on the map to set coordinates for the new point."); return; } const name = pointNameInput.value.trim(), type = poiTypeSelect.value; if (!name) { alert("Point Name cannot be empty."); pointNameInput.focus(); return; } if (!type) { alert("Please select a Point Type."); poiTypeSelect.focus(); return; } if (collectedPoints.some(p => p.name === name)) { alert(`Point "${name}" already exists.`); pointNameInput.focus(); return; } const coordsToUse = lastClickedCoordsArray; collectedPoints.push({ coords: coordsToUse, name: name, type: type, description: pointDescriptionInput.value.trim(), wikiLink: pointWikiLinkInput.value.trim() }); updatePointsOutput(); flashStatusMessage(`Point "${name}" added.`, 'success'); pointNameInput.value = ''; poiTypeSelect.value = ''; pointDescriptionInput.value = ''; pointWikiLinkInput.value = ''; coordsDisplay.textContent = '[Y, X]'; lastClickedCoordsArray = null; addPointBtn.disabled = true; });
            editPointSelect.addEventListener('change', (e) => e.target.value ? loadPointForEditing(e.target.value) : cancelPointEditing());
            savePointChangesBtn.addEventListener('click', savePointChanges);
            cancelPointEditBtn.addEventListener('click', cancelPointEditing);
            clearPointsBtn.addEventListener('click', () => { if (confirm('Clear all points?')) { collectedPoints = []; updatePointsOutput(); setPointEditingState(false); flashStatusMessage('All points cleared.'); } });
            startRegionBtn.addEventListener('click', startRegionCreation);
            finishRegionBtn.addEventListener('click', finishRegionCreation);
            cancelRegionBtn.addEventListener('click', cancelRegionCreation);
            editRegionSelect.addEventListener('change', (e) => e.target.value ? loadRegionForEditing(e.target.value) : cancelRegionEditing());
            saveRegionChangesBtn.addEventListener('click', saveRegionChanges);
            cancelRegionEditBtn.addEventListener('click', cancelRegionEditing);
            addVerticesBtn.addEventListener('click', startAddingVertices);
            editVerticesBtn.addEventListener('click', startEditingVertices);
            clearRegionsBtn.addEventListener('click', () => { if (confirm('Clear all regions?')) { collectedRegions = []; updateRegionsOutput(); setRegionEditingState(false); setRegionCreationState(false); flashStatusMessage('All regions cleared.'); } });
            regionColorInput.addEventListener('input', () => { const c = regionColorInput.value; if (tempRegionLayer && isCreatingRegion) tempRegionLayer.setStyle({ color: c }); if (editingPolygonLayer && (isEditingRegion || isEditingVertices)) editingPolygonLayer.setStyle({ color: c }); });
            regionFillColorInput.addEventListener('input', () => { const c = regionFillColorInput.value; if (tempRegionLayer && isCreatingRegion) tempRegionLayer.setStyle({ fillColor: c }); if (editingPolygonLayer && (isEditingRegion || isEditingVertices)) editingPolygonLayer.setStyle({ fillColor: c }); });
            regionOpacityInput.addEventListener('input', (e) => { const o = parseFloat(e.target.value); if (!isNaN(o)) { if (tempRegionLayer && isCreatingRegion) tempRegionLayer.setStyle({ fillOpacity: o }); if (editingPolygonLayer && (isEditingRegion || isEditingVertices)) editingPolygonLayer.setStyle({ fillOpacity: o }); } });
            regionTypeSelect.addEventListener('change', (e) => { const t = e.target.value; if (regionTypeColors[t] && !isEditingRegion && !isCreatingRegion) { regionColorInput.value = regionTypeColors[t].color; regionFillColorInput.value = regionTypeColors[t].fillColor; } });
            startLineBtn.addEventListener('click', startLineCreation);
            finishLineBtn.addEventListener('click', finishLineCreation);
            cancelLineBtn.addEventListener('click', cancelLineCreation);
            editLineSelect.addEventListener('change', (e) => e.target.value ? loadLineEdit(e.target.value) : cancelLineEdit());
            saveLineChangesBtn.addEventListener('click', saveLineChanges);
            editLineVerticesBtn.addEventListener('click', startEditingLineVertices);
            cancelLineEditBtn.addEventListener('click', cancelLineEdit);
            clearLinesBtn.addEventListener('click', () => { if (confirm('Clear all lines?')) { collectedLines = []; updateLinesOutput(); setLineEditState(false); setLineCreationState(false); flashStatusMessage('All lines cleared.'); } });
            lineColorInput.addEventListener('input', () => { if (tempLineLayer && isCreatingLine) tempLineLayer.setStyle({ color: lineColorInput.value }); if (editingLinePolylineLayer && isEditingLineVertices) editingLinePolylineLayer.setStyle({ color: lineColorInput.value }); });
            lineWeightInput.addEventListener('input', () => { if (tempLineLayer && isCreatingLine) tempLineLayer.setStyle({ weight: parseInt(lineWeightInput.value) || 3 }); if (editingLinePolylineLayer && isEditingLineVertices) editingLinePolylineLayer.setStyle({ weight: parseInt(lineWeightInput.value) || 3 }); });
            lineDashArrayInput.addEventListener('input', () => { if (tempLineLayer && isCreatingLine) tempLineLayer.setStyle({ dashArray: lineDashArrayInput.value.trim() || null }); if (editingLinePolylineLayer && isEditingLineVertices) editingLinePolylineLayer.setStyle({ dashArray: lineDashArrayInput.value.trim() || null }); });
            showAllRegionsToggle.addEventListener('change', (e) => { showAllRegionsWhileEditing = e.target.checked; if (isEditingRegion) { toggleOtherRegionsVisibility(showAllRegionsWhileEditing, currentlyEditingRegionIndex); } });
            exportDataBtn.addEventListener('click', () => showJsonModal(JSON.stringify(generateCompleteMapData(), null, 2)));
            jsonModalCopyBtn.addEventListener('click', () => { navigator.clipboard.writeText(jsonModalTextarea.value).then(() => { jsonModalCopyBtn.textContent = 'Copied!'; setTimeout(() => jsonModalCopyBtn.textContent = 'Copy to Clipboard', 2000); }); });
        });
    </script>
</body>
</html>