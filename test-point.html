<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hiraeth - Point Finder & Map Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        canvas {
            cursor: crosshair;
            background-color: #f0f0f0;
            border: 1px solid #ccc;
        }
        .sidebar {
            height: 100vh;
            overflow-y: auto;
        }
        .zoom-container {
            overflow: auto;
            height: 100vh;
            width: 100%;
        }
        .btn {
            @apply inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500;
        }
        .btn-secondary {
            @apply bg-gray-600 hover:bg-gray-700 focus:ring-gray-500;
        }
        .btn-danger {
            @apply bg-red-600 hover:bg-red-700 focus:ring-red-500;
        }
        .input-field {
            @apply block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <div class="flex">
        <!-- Sidebar -->
        <div class="w-80 flex-shrink-0 bg-white shadow-lg sidebar p-4 space-y-4">
            <h1 class="text-xl font-bold">Map Editor</h1>
            
            <!-- File Loader -->
            <div>
                <label for="map-loader" class="block text-sm font-medium text-gray-700">Load maps.json</label>
                <input type="file" id="map-loader" accept=".json" class="mt-1 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100">
            </div>

            <div id="controls-panel" class="hidden space-y-4">
                 <!-- Zoom Controls -->
                <div>
                    <h3 class="font-semibold">Zoom</h3>
                    <div class="flex items-center space-x-2 mt-1">
                        <button id="zoom-out" class="btn btn-secondary text-sm py-1 px-3">-</button>
                        <span id="zoom-level">100%</span>
                        <button id="zoom-in" class="btn btn-secondary text-sm py-1 px-3">+</button>
                    </div>
                </div>
                
                <!-- Edit Mode -->
                <div>
                    <h3 class="font-semibold">Edit Mode</h3>
                    <div class="grid grid-cols-2 gap-2 mt-1">
                        <button id="mode-select" class="btn text-sm">Select</button>
                        <button id="mode-point" class="btn btn-secondary text-sm">Add Point</button>
                        <button id="mode-line" class="btn btn-secondary text-sm">Add Line</button>
                        <button id="mode-region" class="btn btn-secondary text-sm">Add Region</button>
                    </div>
                </div>

                <!-- Info Panel -->
                <div class="p-2 bg-gray-50 rounded-md">
                    <p id="mouse-coords" class="text-sm font-mono">X: 0, Y: 0</p>
                    <p id="map-info" class="text-sm"></p>
                </div>

                <!-- Editor Panel -->
                <div id="editor-panel" class="hidden space-y-3 bg-indigo-50 p-3 rounded-md">
                    <h3 class="font-semibold text-indigo-800">Edit Feature</h3>
                    <div>
                        <label for="edit-name" class="block text-sm font-medium text-gray-700">Name</label>
                        <input type="text" id="edit-name" class="input-field mt-1">
                    </div>
                    <div>
                        <label for="edit-desc" class="block text-sm font-medium text-gray-700">Description</label>
                        <textarea id="edit-desc" rows="3" class="input-field mt-1"></textarea>
                    </div>
                     <div>
                        <label for="edit-id" class="block text-sm font-medium text-gray-700">ID (optional)</label>
                        <input type="text" id="edit-id" class="input-field mt-1">
                    </div>
                    <button id="delete-feature" class="btn btn-danger w-full">Delete Feature</button>
                </div>

                <!-- Export -->
                <button id="export-map" class="btn w-full">Export Updated JSON</button>
            </div>
             <div id="welcome-message" class="text-center p-4 bg-gray-50 rounded-lg">
                <p class="font-semibold">Welcome!</p>
                <p class="text-sm text-gray-600">Please load a `maps.json` file to begin editing.</p>
            </div>
        </div>

        <!-- Canvas Area -->
        <div id="zoom-container" class="flex-grow flex items-center justify-center zoom-container bg-gray-200">
            <canvas id="map-canvas"></canvas>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // DOM Elements
            const canvas = document.getElementById('map-canvas');
            const ctx = canvas.getContext('2d');
            const fileInput = document.getElementById('map-loader');
            const controlsPanel = document.getElementById('controls-panel');
            const welcomeMessage = document.getElementById('welcome-message');
            const editorPanel = document.getElementById('editor-panel');
            const mouseCoordsEl = document.getElementById('mouse-coords');
            const mapInfoEl = document.getElementById('map-info');

            // Zoom elements
            const zoomContainer = document.getElementById('zoom-container');
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');
            const zoomLevelEl = document.getElementById('zoom-level');

            // Mode buttons
            const modeButtons = {
                select: document.getElementById('mode-select'),
                point: document.getElementById('mode-point'),
                line: document.getElementById('mode-line'),
                region: document.getElementById('mode-region'),
            };

            // Editor fields
            const editName = document.getElementById('edit-name');
            const editDesc = document.getElementById('edit-desc');
            const editId = document.getElementById('edit-id');
            const deleteBtn = document.getElementById('delete-feature');
            const exportBtn = document.getElementById('export-map');

            // Application State
            let mapData = null;
            let mapImage = new Image();
            let editMode = 'select'; // select, point, line, region
            let selectedFeature = null;
            let selectedFeatureParent = null;
            let dragging = false;
            let dragStart = { x: 0, y: 0 };
            let currentLine = [];
            let zoom = 1.0;

            // --- Initialization ---
            fileInput.addEventListener('change', handleFileLoad);
            
            function handleFileLoad(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        mapData = JSON.parse(e.target.result);
                        initializeEditor();
                    } catch (error) {
                        alert('Error parsing JSON file: ' + error.message);
                        console.error(error);
                    }
                };
                reader.readAsText(file);
            }

            function initializeEditor() {
                welcomeMessage.classList.add('hidden');
                controlsPanel.classList.remove('hidden');

                mapImage.src = mapData.image_url;
                mapImage.onload = () => {
                    canvas.width = mapData.width;
                    canvas.height = mapData.height;
                    mapInfoEl.textContent = `Map: ${mapData.name} (${mapData.width}x${mapData.height})`;
                    setZoom(1.0); // Reset zoom
                };
                mapImage.onerror = () => {
                    alert('Failed to load map image from URL: ' + mapData.image_url);
                    // Still draw the features, just on a blank background
                    canvas.width = mapData.width;
                    canvas.height = mapData.height;
                    mapInfoEl.textContent = `Map: ${mapData.name} (${mapData.width}x${mapData.height})`;
                    setZoom(1.0);
                }
            }
            
            // --- Drawing ---
            function redrawCanvas() {
                if (!mapData) return;
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw map image
                if (mapImage.complete && mapImage.naturalWidth > 0) {
                     ctx.drawImage(mapImage, 0, 0);
                } else {
                     ctx.fillStyle = '#f0f0f0';
                     ctx.fillRect(0, 0, canvas.width, canvas.height);
                }

                // Recursively draw all features
                drawFeaturesRecursive(mapData);
                
                // Highlight selected feature
                if (selectedFeature) {
                    highlightFeature(selectedFeature);
                }

                // Draw currently creating line/region
                if ((editMode === 'line' || editMode === 'region') && currentLine.length > 0) {
                    ctx.strokeStyle = '#00ff00';
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.2)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(currentLine[0].x, currentLine[0].y);
                    for (let i = 1; i < currentLine.length; i++) {
                        ctx.lineTo(currentLine[i].x, currentLine[i].y);
                    }
                    if (editMode === 'region') {
                        ctx.closePath();
                        ctx.fill();
                    }
                    ctx.stroke();
                }
            }
            
            function drawFeaturesRecursive(dataNode) {
                // Ensure feature arrays exist
                if (!dataNode.regions) dataNode.regions = [];
                if (!dataNode.lines) dataNode.lines = [];
                if (!dataNode.pois) dataNode.pois = [];
                if (!dataNode.maps) dataNode.maps = [];
            
                // Draw regions
                ctx.strokeStyle = 'rgba(255, 0, 255, 0.8)';
                ctx.fillStyle = 'rgba(255, 0, 255, 0.2)';
                ctx.lineWidth = 2;
                dataNode.regions.forEach(region => {
                    if (region.points && region.points.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(region.points[0][0], region.points[0][1]);
                        for (let i = 1; i < region.points.length; i++) {
                            ctx.lineTo(region.points[i][0], region.points[i][1]);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                    }
                });

                // Draw lines
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
                ctx.lineWidth = 3;
                dataNode.lines.forEach(line => {
                    if(line.points && line.points.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(line.points[0][0], line.points[0][1]);
                        for (let i = 1; i < line.points.length; i++) {
                            ctx.lineTo(line.points[i][0], line.points[i][1]);
                        }
                        ctx.stroke();
                    }
                });

                // Draw points (pois)
                ctx.fillStyle = 'rgba(255, 255, 0, 1)';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 1.5;
                dataNode.pois.forEach(poi => {
                    ctx.beginPath();
                    ctx.arc(poi.x, poi.y, 7, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                });

                // Recurse into sub-maps
                dataNode.maps.forEach(subMap => {
                    // Optionally draw boundary of submap
                    if(subMap.boundary) {
                        ctx.strokeStyle = 'rgba(200, 200, 200, 0.7)';
                        ctx.fillStyle = 'rgba(200, 200, 200, 0.1)';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(subMap.boundary[0][0], subMap.boundary[0][1]);
                        for (let i = 1; i < subMap.boundary.length; i++) {
                            ctx.lineTo(subMap.boundary[i][0], subMap.boundary[i][1]);
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                    drawFeaturesRecursive(subMap);
                });
            }

            function highlightFeature(feature) {
                 ctx.lineWidth = 4;
                 ctx.strokeStyle = '#00ff00'; // Bright green
                 ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';

                 if (feature.hasOwnProperty('x')) { // POI
                    ctx.beginPath();
                    ctx.arc(feature.x, feature.y, 10, 0, 2 * Math.PI);
                    ctx.stroke();
                 } else if (feature.points) { // Line or Region
                    if (feature.points.length < 2) return;
                    ctx.beginPath();
                    ctx.moveTo(feature.points[0][0], feature.points[0][1]);
                    for (let i = 1; i < feature.points.length; i++) {
                        ctx.lineTo(feature.points[i][0], feature.points[i][1]);
                    }
                    // If it's a region, close the path
                    const featureType = getFeatureType(feature);
                    if (featureType === 'region') {
                       ctx.closePath();
                       ctx.fill();
                    }
                    ctx.stroke();
                 }
            }


            // --- Event Handling ---
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('contextmenu', handleRightClick); // To finish line/region

            function getMousePos(evt) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: Math.round((evt.clientX - rect.left) / zoom),
                    y: Math.round((evt.clientY - rect.top) / zoom)
                };
            }
            
            function handleMouseDown(e) {
                const pos = getMousePos(e);
                if (editMode === 'select') {
                    const found = findFeatureAt(pos);
                    if (found) {
                        selectFeature(found.feature, found.parent);
                        dragging = true;
                        dragStart = pos;
                    } else {
                        selectFeature(null, null);
                    }
                } else if (editMode === 'point') {
                    const newPoi = { name: 'New Point', x: pos.x, y: pos.y, description: '' };
                    mapData.pois.push(newPoi);
                    selectFeature(newPoi, mapData);
                } else if (editMode === 'line' || editMode === 'region') {
                    currentLine.push(pos);
                }
                redrawCanvas();
            }

            function handleMouseMove(e) {
                const pos = getMousePos(e);
                mouseCoordsEl.textContent = `X: ${pos.x}, Y: ${pos.y}`;

                if (dragging && selectedFeature) {
                    const dx = pos.x - dragStart.x;
                    const dy = pos.y - dragStart.y;

                    if (selectedFeature.hasOwnProperty('x')) { // POI
                        selectedFeature.x += dx;
                        selectedFeature.y += dy;
                    } else if (selectedFeature.points) { // Line or Region
                        selectedFeature.points = selectedFeature.points.map(p => [p[0] + dx, p[1] + dy]);
                    }

                    dragStart = pos;
                    updateEditorPanel();
                    redrawCanvas();
                }
            }

            function handleMouseUp(e) {
                dragging = false;
            }

            function handleRightClick(e) {
                e.preventDefault();
                if ((editMode === 'line' || editMode === 'region') && currentLine.length > 1) {
                    const newFeature = {
                        name: `New ${editMode}`,
                        description: '',
                        points: currentLine.map(p => [p.x, p.y])
                    };
                    
                    if (editMode === 'line') {
                        if (!mapData.lines) mapData.lines = [];
                        mapData.lines.push(newFeature);
                    } else { // region
                         if (!mapData.regions) mapData.regions = [];
                        mapData.regions.push(newFeature);
                    }
                    
                    selectFeature(newFeature, mapData);
                    currentLine = [];
                    setEditMode('select');
                    redrawCanvas();
                }
            }
            
            // --- Feature Management ---
            function findFeatureAt(pos, node = mapData) {
                const pointRadius = 10;
                let found = null;
                
                // Check POIs (reverse order for top-most)
                for (let i = node.pois.length - 1; i >= 0; i--) {
                    const poi = node.pois[i];
                    const dist = Math.sqrt((pos.x - poi.x)**2 + (pos.y - poi.y)**2);
                    if (dist <= pointRadius) return { feature: poi, parent: node };
                }

                // Check Lines & Regions (more complex, simplified here)
                // A proper check would be distance to line segment or point-in-polygon test
                // For simplicity, we check near vertices for now
                const checkVertices = (feature) => {
                     for (const p of feature.points) {
                         const dist = Math.sqrt((pos.x - p[0])**2 + (pos.y - p[1])**2);
                         if (dist <= pointRadius) return true;
                     }
                     return false;
                }

                for (let i = node.lines.length - 1; i >= 0; i--) {
                    if (checkVertices(node.lines[i])) return { feature: node.lines[i], parent: node };
                }
                 for (let i = node.regions.length - 1; i >= 0; i--) {
                    // A simple point-in-polygon check
                    if (isPointInPolygon(pos, node.regions[i].points)) {
                         return { feature: node.regions[i], parent: node };
                    }
                }

                // Recurse into submaps
                for (const subMap of node.maps) {
                    found = findFeatureAt(pos, subMap);
                    if (found) return found;
                }

                return null;
            }
            
            function isPointInPolygon(point, polygon) {
                // Ray-casting algorithm for point-in-polygon test
                let x = point.x, y = point.y;
                let inside = false;
                for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                    let xi = polygon[i][0], yi = polygon[i][1];
                    let xj = polygon[j][0], yj = polygon[j][1];

                    let intersect = ((yi > y) !== (yj > y))
                        && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                    if (intersect) inside = !inside;
                }
                return inside;
            }


            function selectFeature(feature, parent) {
                selectedFeature = feature;
                selectedFeatureParent = parent;
                updateEditorPanel();
                redrawCanvas();
            }
            
            function getFeatureType(feature) {
                if (!feature) return 'none';
                if (feature.hasOwnProperty('x')) return 'poi';
                // This is a simplification. We need a way to distinguish lines from regions.
                // Assuming regions always have the same start/end point, but that's not guaranteed.
                // We'll rely on which array it came from. The `findFeatureAt` needs to be smarter.
                // For now, let's use a trick: check if it's in a `regions` array.
                if (selectedFeatureParent && selectedFeatureParent.regions.includes(feature)) {
                    return 'region';
                }
                return 'line';
            }
            
            // --- UI Updates ---
            function setEditMode(mode) {
                editMode = mode;
                currentLine = []; // Clear any in-progress lines
                Object.values(modeButtons).forEach(btn => btn.classList.add('btn-secondary'));
                modeButtons[mode].classList.remove('btn-secondary');
                redrawCanvas();
            }

            function updateEditorPanel() {
                if (selectedFeature) {
                    editorPanel.classList.remove('hidden');
                    editName.value = selectedFeature.name || '';
                    editDesc.value = selectedFeature.description || '';
                    editId.value = selectedFeature.id || '';
                } else {
                    editorPanel.classList.add('hidden');
                }
            }

            // --- UI Event Listeners ---
            Object.keys(modeButtons).forEach(key => {
                modeButtons[key].addEventListener('click', () => setEditMode(key));
            });

            editName.addEventListener('input', (e) => {
                if(selectedFeature) selectedFeature.name = e.target.value;
            });
            editDesc.addEventListener('input', (e) => {
                if(selectedFeature) selectedFeature.description = e.target.value;
            });
             editId.addEventListener('input', (e) => {
                if(selectedFeature) selectedFeature.id = e.target.value;
            });

            deleteBtn.addEventListener('click', () => {
                if (!selectedFeature || !selectedFeatureParent || !confirm('Are you sure you want to delete this feature?')) return;
                
                const type = getFeatureType(selectedFeature);
                let arr;
                if (type === 'poi') arr = selectedFeatureParent.pois;
                else if (type === 'line') arr = selectedFeatureParent.lines;
                else if (type === 'region') arr = selectedFeatureParent.regions;
                
                if (arr) {
                    const index = arr.indexOf(selectedFeature);
                    if (index > -1) {
                        arr.splice(index, 1);
                        selectFeature(null, null);
                        redrawCanvas();
                    }
                }
            });

            exportBtn.addEventListener('click', () => {
                if (!mapData) return;
                const jsonString = JSON.stringify(mapData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'edited_map.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            });
            
             // --- Zoom Logic ---
            function setZoom(newZoom) {
                zoom = Math.max(0.1, Math.min(5, newZoom)); // Clamp zoom between 10% and 500%
                canvas.style.transform = `scale(${zoom})`;
                canvas.style.transformOrigin = 'top left';
                zoomLevelEl.textContent = `${Math.round(zoom * 100)}%`;
                redrawCanvas();
            }

            zoomInBtn.addEventListener('click', () => setZoom(zoom + 0.1));
            zoomOutBtn.addEventListener('click', () => setZoom(zoom - 0.1));

            // Set initial state
            setEditMode('select');
        });
    </script>

</body>
</html>